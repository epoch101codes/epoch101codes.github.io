diff --git a/Documentation/kdump/gdbmacros.txt b/Documentation/kdump/gdbmacros.txt
index 9b9b454..e1d30d8 100644
--- a/Documentation/kdump/gdbmacros.txt
+++ b/Documentation/kdump/gdbmacros.txt
@@ -56,40 +56,41 @@ end
 
 define btt
 	set $tasks_off=((size_t)&((struct task_struct *)0)->tasks)
-	set $pid_off=((size_t)&((struct task_struct *)0)->pids[1].pid_list.next)
+	set $pid_off=((size_t)&((struct task_struct *)0)->pids[1].node.next)
 	set $init_t=&init_task
 	set $next_t=(((char *)($init_t->tasks).next) - $tasks_off)
+	
 	while ($next_t != $init_t)
 		set $next_t=(struct task_struct *)$next_t
 		printf "\npid %d; comm %s:\n", $next_t.pid, $next_t.comm
 		printf "===================\n"
-		set var $stackp = $next_t.thread.esp
+		set var $stackp = $next_t.thread.sp
 		set var $stack_top = ($stackp & ~4095) + 4096
 		set var $stack_bot = ($stackp & ~4095)
 
 		set $stackp = *($stackp)
 		while (($stackp < $stack_top) && ($stackp > $stack_bot))
-			set var $addr = *($stackp + 4)
+			set var $addr = *($stackp + 8)
 			info symbol $addr
 			set $stackp = *($stackp)
 		end
 
-		set $next_th=(((char *)$next_t->pids[1].pid_list.next) - $pid_off)
+		set $next_th=(((char *)$next_t->pids[1].node.next) - $pid_off)
 		while ($next_th != $next_t)
 			set $next_th=(struct task_struct *)$next_th
 			printf "\npid %d; comm %s:\n", $next_t.pid, $next_t.comm
 			printf "===================\n"
-			set var $stackp = $next_t.thread.esp
+			set var $stackp = $next_t.thread.sp
 			set var $stack_top = ($stackp & ~4095) + 4096
 			set var $stack_bot = ($stackp & ~4095)
 
 			set $stackp = *($stackp)
 			while (($stackp < $stack_top) && ($stackp > $stack_bot))
-				set var $addr = *($stackp + 4)
+				set var $addr = *($stackp + 8)
 				info symbol $addr
 				set $stackp = *($stackp)
 			end
-			set $next_th=(((char *)$next_th->pids[1].pid_list.next) - $pid_off)
+			set $next_th=(((char *)$next_th->pids[1].node.next) - $pid_off)
 		end
 		set $next_t=(char *)($next_t->tasks.next) - $tasks_off
 	end
@@ -101,7 +102,7 @@ end
 define btpid
 	set var $pid = $arg0
 	set $tasks_off=((size_t)&((struct task_struct *)0)->tasks)
-	set $pid_off=((size_t)&((struct task_struct *)0)->pids[1].pid_list.next)
+	set $pid_off=((size_t)&((struct task_struct *)0)->pids[1].node.next)
 	set $init_t=&init_task
 	set $next_t=(((char *)($init_t->tasks).next) - $tasks_off)
 	set var $pid_task = 0
@@ -113,26 +114,26 @@ define btpid
 			set $pid_task = $next_t
 		end
 
-		set $next_th=(((char *)$next_t->pids[1].pid_list.next) - $pid_off)
+		set $next_th=(((char *)$next_t->pids[1].node.next) - $pid_off)
 		while ($next_th != $next_t)
 			set $next_th=(struct task_struct *)$next_th
 			if ($next_th.pid == $pid)
 				set $pid_task = $next_th
 			end
-			set $next_th=(((char *)$next_th->pids[1].pid_list.next) - $pid_off)
+			set $next_th=(((char *)$next_th->pids[1].node.next) - $pid_off)
 		end
 		set $next_t=(char *)($next_t->tasks.next) - $tasks_off
 	end
 
 	printf "\npid %d; comm %s:\n", $pid_task.pid, $pid_task.comm
 	printf "===================\n"
-	set var $stackp = $pid_task.thread.esp
+	set var $stackp = $pid_task.thread.sp
 	set var $stack_top = ($stackp & ~4095) + 4096
 	set var $stack_bot = ($stackp & ~4095)
 
 	set $stackp = *($stackp)
 	while (($stackp < $stack_top) && ($stackp > $stack_bot))
-		set var $addr = *($stackp + 4)
+		set var $addr = *($stackp + 8)
 		info symbol $addr
 		set $stackp = *($stackp)
 	end
diff --git a/Makefile b/Makefile
index afe4c7d..97dbfde 100644
--- a/Makefile
+++ b/Makefile
@@ -708,7 +708,7 @@ export mod_strip_cmd
 
 
 ifeq ($(KBUILD_EXTMOD),)
-core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
+core-y		+= kernel/ mm/ fs/ ipc/ pcnmsg/ security/ crypto/ block/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index efb4294..cfd690b 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -75,6 +75,7 @@ config X86
 	select HAVE_BPF_JIT if (X86_64 && NET)
 	select CLKEVT_I8253
 	select ARCH_HAVE_NMI_SAFE_CMPXCHG
+	select HAVE_POPCORN_ARCH_SUPPORT
 
 config INSTRUCTION_DECODER
 	def_bool (KPROBES || PERF_EVENTS)
@@ -237,6 +238,10 @@ config X86_32_LAZY_GS
 	def_bool y
 	depends on X86_32 && !CC_STACKPROTECTOR
 
+config HAVE_POPCORN_ARCH_SUPPORT
+	def_bool y
+	depends on X86_64_SMP
+
 config ARCH_HWEIGHT_CFLAGS
 	string
 	default "-fcall-saved-ecx -fcall-saved-edx" if X86_32
@@ -2177,3 +2182,5 @@ source "crypto/Kconfig"
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+source "kernel/Kconfig.popcorn"
diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 1a6c09a..1ae7949 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -220,6 +220,8 @@ extern void enable_IR_x2apic(void);
 
 extern int get_physical_broadcast(void);
 
+extern int is_bsp_cluster; // must maybe declared as static and do not directly accessed by functions... TODO
+extern unsigned int lapic_is_bsp(void);
 extern int lapic_get_maxlvt(void);
 extern void clear_local_APIC(void);
 extern void connect_bsp_APIC(void);
diff --git a/arch/x86/include/asm/bootparam.h b/arch/x86/include/asm/bootparam.h
index e020d88..22f7a4a 100644
--- a/arch/x86/include/asm/bootparam.h
+++ b/arch/x86/include/asm/bootparam.h
@@ -57,7 +57,9 @@ struct setup_header {
 	__u32	initrd_addr_max;
 	__u32	kernel_alignment;
 	__u8	relocatable_kernel;
-	__u8	_pad2[3];
+	__u8	ramdisk_shift;
+	__u8    ramdisk_magic;
+	__u8	_pad2[1];
 	__u32	cmdline_size;
 	__u32	hardware_subarch;
 	__u64	hardware_subarch_data;
@@ -117,7 +119,8 @@ struct boot_params {
 	struct e820entry e820_map[E820MAX];		/* 0x2d0 */
 	__u8  _pad8[48];				/* 0xcd0 */
 	struct edd_info eddbuf[EDDMAXNR];		/* 0xd00 */
-	__u8  _pad9[276];				/* 0xeec */
+	__u8  _pad9[268];				/* 0xeec */
+	__u64  pcn_kmsg_master_window;
 } __attribute__((packed));
 
 enum {
diff --git a/arch/x86/include/asm/cpu.h b/arch/x86/include/asm/cpu.h
index 4564c8e..139dcd9 100644
--- a/arch/x86/include/asm/cpu.h
+++ b/arch/x86/include/asm/cpu.h
@@ -10,6 +10,7 @@
 #ifdef CONFIG_SMP
 
 extern void prefill_possible_map(void);
+extern void prefill_present_map(void);
 
 #else /* CONFIG_SMP */
 
diff --git a/arch/x86/include/asm/entry_arch.h b/arch/x86/include/asm/entry_arch.h
index 0baa628..4d91c9d 100644
--- a/arch/x86/include/asm/entry_arch.h
+++ b/arch/x86/include/asm/entry_arch.h
@@ -11,6 +11,10 @@
  */
 #ifdef CONFIG_SMP
 BUILD_INTERRUPT(reschedule_interrupt,RESCHEDULE_VECTOR)
+
+/*****VTY Changes single line code change****************/
+BUILD_INTERRUPT(vty_interrupt,MK_VTY)
+
 BUILD_INTERRUPT(call_function_interrupt,CALL_FUNCTION_VECTOR)
 BUILD_INTERRUPT(call_function_single_interrupt,CALL_FUNCTION_SINGLE_VECTOR)
 BUILD_INTERRUPT(irq_move_cleanup_interrupt,IRQ_MOVE_CLEANUP_VECTOR)
diff --git a/arch/x86/include/asm/hardirq.h b/arch/x86/include/asm/hardirq.h
index 55e4de6..6c8e461 100644
--- a/arch/x86/include/asm/hardirq.h
+++ b/arch/x86/include/asm/hardirq.h
@@ -26,6 +26,9 @@ typedef struct {
 #ifdef CONFIG_X86_MCE_THRESHOLD
 	unsigned int irq_threshold_count;
 #endif
+#ifdef CONFIG_POPCORN_KMSG
+	unsigned int irq_popcorn_kmsg_count;
+#endif
 } ____cacheline_aligned irq_cpustat_t;
 
 DECLARE_PER_CPU_SHARED_ALIGNED(irq_cpustat_t, irq_stat);
diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index eb92a6e..fbbbad1 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -35,6 +35,11 @@ extern void spurious_interrupt(void);
 extern void thermal_interrupt(void);
 extern void reschedule_interrupt(void);
 
+#ifdef CONFIG_POPCORN_KMSG
+extern void popcorn_kmsg_interrupt(void);
+extern void popcorn_ipi_latency_interrupt(void);
+#endif
+
 extern void invalidate_interrupt(void);
 extern void invalidate_interrupt0(void);
 extern void invalidate_interrupt1(void);
@@ -152,6 +157,7 @@ extern asmlinkage void smp_irq_move_cleanup_interrupt(void);
 #endif
 #ifdef CONFIG_SMP
 extern void smp_reschedule_interrupt(struct pt_regs *);
+//extern void smp_vty_interrupt(struct pt_regs *);
 extern void smp_call_function_interrupt(struct pt_regs *);
 extern void smp_call_function_single_interrupt(struct pt_regs *);
 #ifdef CONFIG_X86_32
diff --git a/arch/x86/include/asm/irq_vectors.h b/arch/x86/include/asm/irq_vectors.h
index 4b44487..981d8fe 100644
--- a/arch/x86/include/asm/irq_vectors.h
+++ b/arch/x86/include/asm/irq_vectors.h
@@ -137,6 +137,11 @@
 #define	FIRST_VM86_IRQ			   3
 #define LAST_VM86_IRQ			  15
 
+#ifdef CONFIG_POPCORN_KMSG
+#define POPCORN_IPI_LATENCY_VECTOR 0xcc
+#define POPCORN_KMSG_VECTOR 0xcd
+#endif
+
 #ifndef __ASSEMBLY__
 static inline int invalid_vm86_irq(int irq)
 {
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index bb3ee36..4aa33e5 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -774,7 +774,7 @@ extern struct desc_ptr		early_gdt_descr;
 extern void cpu_set_gdt(int);
 extern void switch_to_new_gdt(int);
 extern void load_percpu_segment(int);
-extern void cpu_init(void);
+extern void cpu_init(int);
 
 static inline unsigned long get_debugctlmsr(void)
 {
diff --git a/arch/x86/include/asm/smp.h b/arch/x86/include/asm/smp.h
index 73b11bc..5649868 100644
--- a/arch/x86/include/asm/smp.h
+++ b/arch/x86/include/asm/smp.h
@@ -160,6 +160,8 @@ void play_dead_common(void);
 void wbinvd_on_cpu(int cpu);
 int wbinvd_on_all_cpus(void);
 
+int mkbsp_boot_cpu(int apicid, int cpu, unsigned long kernel_start_address);
+
 void native_send_call_func_ipi(const struct cpumask *mask);
 void native_send_call_func_single_ipi(int cpu);
 
diff --git a/arch/x86/include/asm/trampoline.h b/arch/x86/include/asm/trampoline.h
index feca311..9f3d180 100644
--- a/arch/x86/include/asm/trampoline.h
+++ b/arch/x86/include/asm/trampoline.h
@@ -15,25 +15,48 @@ extern const unsigned char x86_trampoline_start [];
 extern const unsigned char x86_trampoline_end   [];
 extern unsigned char *x86_trampoline_base;
 
+extern const unsigned char x86_trampoline_bsp_start [];
+extern const unsigned char x86_trampoline_bsp_end   [];
+extern unsigned char *x86_trampoline_bsp_base;
+extern unsigned long kernel_phys_addr;
+extern unsigned long boot_params_phys_addr;
+
 extern unsigned long init_rsp;
 extern unsigned long initial_code;
 extern unsigned long initial_gs;
 
+extern unsigned long mkbsp_load_addr;
+extern unsigned long mkbsp_boot_params;
+
 extern void __init setup_trampolines(void);
+extern void __init setup_trampolines_bsp(void);
 
 extern const unsigned char trampoline_data[];
 extern const unsigned char trampoline_status[];
 
+extern const unsigned char trampoline_data_bsp[];
+extern const unsigned char trampoline_status_bsp[];
+
 #define TRAMPOLINE_SYM(x)						\
 	((void *)(x86_trampoline_base +					\
 		  ((const unsigned char *)(x) - x86_trampoline_start)))
 
+#define TRAMPOLINE_SYM_BSP(x)						\
+	((void *)(x86_trampoline_bsp_base +					\
+		  ((const unsigned char *)(x) - x86_trampoline_bsp_start)))
+
 /* Address of the SMP trampoline */
 static inline unsigned long trampoline_address(void)
 {
 	return virt_to_phys(TRAMPOLINE_SYM(trampoline_data));
 }
 
+/* Address of the SMP trampoline */
+static inline unsigned long trampoline_bsp_address(void)
+{
+	return virt_to_phys(TRAMPOLINE_SYM_BSP(trampoline_data_bsp));
+}
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _ASM_X86_TRAMPOLINE_H */
diff --git a/arch/x86/include/asm/unistd_64.h b/arch/x86/include/asm/unistd_64.h
index 0431f19..7df53db 100644
--- a/arch/x86/include/asm/unistd_64.h
+++ b/arch/x86/include/asm/unistd_64.h
@@ -686,6 +686,14 @@ __SYSCALL(__NR_getcpu, sys_getcpu)
 __SYSCALL(__NR_process_vm_readv, sys_process_vm_readv)
 #define __NR_process_vm_writev			311
 __SYSCALL(__NR_process_vm_writev, sys_process_vm_writev)
+#define __NR_multikernel_boot                   312
+__SYSCALL(__NR_multikernel_boot, sys_multikernel_boot)
+#define __NR_get_boot_params_addr               313
+__SYSCALL(__NR_get_boot_params_addr, sys_get_boot_params_addr)
+#define __NR_popcorn_test_kmsg			314
+__SYSCALL(__NR_popcorn_test_kmsg, sys_popcorn_test_kmsg)
+#define __NR_popcorn_test_ipi_latency		315
+__SYSCALL(__NR_popcorn_test_ipi_latency, sys_popcorn_test_ipi_latency)
 
 #ifndef __NO_STUBS
 #define __ARCH_WANT_OLD_READDIR
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 8baca3c..cbf0d3d 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -35,6 +35,7 @@ obj-y			+= pci-iommu_table.o
 obj-y			+= resource.o
 
 obj-y				+= trampoline.o trampoline_$(BITS).o
+obj-$(CONFIG_POPCORN)           += trampoline_$(BITS)_bsp.o
 obj-y				+= process.o
 obj-y				+= i387.o xsave.o
 obj-y				+= ptrace.o
diff --git a/arch/x86/kernel/aperture_64.c b/arch/x86/kernel/aperture_64.c
index 3d2661c..ed4f7da 100644
--- a/arch/x86/kernel/aperture_64.c
+++ b/arch/x86/kernel/aperture_64.c
@@ -44,7 +44,13 @@
  * code for safe.
  */
 #define GART_MIN_ADDR	(512ULL << 20)
+
+#ifdef CONFIG_POPCORN
+#define GART_MAX_ADDR	(1ULL   << 64)
+#else
 #define GART_MAX_ADDR	(1ULL   << 32)
+#endif
+
 
 int gart_iommu_aperture;
 int gart_iommu_aperture_disabled __initdata;
@@ -370,6 +376,11 @@ int __init gart_iommu_hole_init(void)
 	int fix, slot, valid_agp = 0;
 	int i, node;
 
+	/* POPCORN -- disable IOMMU aperture for now */
+#ifdef CONFIG_POPCORN
+	gart_iommu_aperture_disabled = 1;
+#endif
+
 	if (gart_iommu_aperture_disabled || !fix_aperture ||
 	    !early_pci_allowed())
 		return -ENODEV;
diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c
index f98d84c..068eb85 100644
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@ -34,6 +34,7 @@
 #include <linux/dmi.h>
 #include <linux/smp.h>
 #include <linux/mm.h>
+#include <linux/multikernel.h>
 
 #include <asm/perf_event.h>
 #include <asm/x86_init.h>
@@ -54,7 +55,7 @@
 #include <asm/tsc.h>
 #include <asm/hypervisor.h>
 
-unsigned int num_processors;
+unsigned int num_processors = 0;
 
 unsigned disabled_cpus __cpuinitdata;
 
@@ -282,6 +283,21 @@ int get_physical_broadcast(void)
 }
 #endif
 
+int is_bsp_cluster=0;
+
+unsigned int lapic_is_bsp(void)
+{
+	unsigned int msr, msr2;
+
+	rdmsr(MSR_IA32_APICBASE, msr, msr2);
+	msr &= MSR_IA32_APICBASE_BSP;
+	
+	if (!is_bsp_cluster && msr)
+	  is_bsp_cluster = msr;
+
+	return msr;
+}
+
 /**
  * lapic_get_maxlvt - get the maximum number of local vector table entries
  */
@@ -1994,8 +2010,8 @@ void __cpuinit generic_processor_info(int apicid, int version)
 		return;
 	}
 
-	num_processors++;
-	if (apicid == boot_cpu_physical_apicid) {
+	cpu = num_processors++;
+//	if (apicid == boot_cpu_physical_apicid) {
 		/*
 		 * x86_bios_cpu_apicid is required to have processors listed
 		 * in same order as logical cpu numbers. Hence the first
@@ -2003,9 +2019,9 @@ void __cpuinit generic_processor_info(int apicid, int version)
 		 * boot_cpu_init() already hold bit 0 in cpu_present_mask
 		 * for BSP.
 		 */
-		cpu = 0;
-	} else
-		cpu = cpumask_next_zero(-1, cpu_present_mask);
+//		cpu = 0;
+//	} else
+//		cpu = cpumask_next_zero(-1, cpu_present_mask);
 
 	/*
 	 * Validate version
@@ -2365,6 +2381,14 @@ static int __init parse_nolapic_timer(char *arg)
 }
 early_param("nolapic_timer", parse_nolapic_timer);
 
+static int __init parse_lapic_timer(char *arg)
+{
+	lapic_timer_frequency = simple_strtoul(arg, NULL, 0); // set the value
+	pr_info("APIC: lapic_timer_frequency set to %d\n", lapic_timer_frequency);
+	return 0;
+}
+early_param("lapic_timer", parse_lapic_timer);
+
 static int __init apic_set_verbosity(char *arg)
 {
 	if (!arg)  {
diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c
index a25e276..09ff9ed 100644
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@ -1417,7 +1417,7 @@ static int setup_ioapic_entry(int irq, struct IO_APIC_route_entry *entry,
 static void setup_ioapic_irq(unsigned int irq, struct irq_cfg *cfg,
 				struct io_apic_irq_attr *attr)
 {
-	struct IO_APIC_route_entry entry;
+	struct IO_APIC_route_entry entry, tmp_entry;
 	unsigned int dest;
 
 	if (!IO_APIC_IRQ(irq))
@@ -1435,15 +1435,19 @@ static void setup_ioapic_irq(unsigned int irq, struct irq_cfg *cfg,
 
 	dest = apic->cpu_mask_to_apicid_and(cfg->domain, apic->target_cpus());
 
+	printk("%s: domain %lx target_cpus() %lx dest %x DBG smp id %d is_bsp %d is_bsp_cluster %d\n",
+			__func__, cpumask_bits(cfg->domain)[0],
+			cpumask_bits(apic->target_cpus())[0], dest,
+			smp_processor_id(), !(!lapic_is_bsp()), is_bsp_cluster );
 	apic_printk(APIC_VERBOSE,KERN_DEBUG
-		    "IOAPIC[%d]: Set routing entry (%d-%d -> 0x%x -> "
-		    "IRQ %d Mode:%i Active:%i Dest:%d)\n",
-		    attr->ioapic, mpc_ioapic_id(attr->ioapic), attr->ioapic_pin,
-		    cfg->vector, irq, attr->trigger, attr->polarity, dest);
+			"IOAPIC[%d]: Set routing entry (%d-%d -> 0x%x -> "
+			"IRQ %d Mode:%i Active:%i Dest:%d)\n",
+			attr->ioapic, mpc_ioapic_id(attr->ioapic), attr->ioapic_pin,
+			cfg->vector, irq, attr->trigger, attr->polarity, dest);
 
 	if (setup_ioapic_entry(irq, &entry, dest, cfg->vector, attr)) {
 		pr_warn("Failed to setup ioapic entry for ioapic  %d, pin %d\n",
-			mpc_ioapic_id(attr->ioapic), attr->ioapic_pin);
+				mpc_ioapic_id(attr->ioapic), attr->ioapic_pin);
 		__clear_irq_vector(irq, cfg);
 
 		return;
@@ -1453,7 +1457,10 @@ static void setup_ioapic_irq(unsigned int irq, struct irq_cfg *cfg,
 	if (irq < legacy_pic->nr_legacy_irqs)
 		legacy_pic->mask(irq);
 
-	ioapic_write_entry(attr->ioapic, attr->ioapic_pin, entry);
+	tmp_entry = ioapic_read_entry(attr->ioapic, attr->ioapic_pin);
+
+	if ( !(!lapic_is_bsp()) || is_bsp_cluster) // write only if we are on the bsp (the master)
+		ioapic_write_entry(attr->ioapic, attr->ioapic_pin, entry);
 }
 
 static bool __init io_apic_pin_not_connected(int idx, int ioapic_idx, int pin)
@@ -1468,9 +1475,11 @@ static bool __init io_apic_pin_not_connected(int idx, int ioapic_idx, int pin)
 
 static void __init __io_apic_setup_irqs(unsigned int ioapic_idx)
 {
-	int idx, node = cpu_to_node(0);
+	int idx, node;
 	struct io_apic_irq_attr attr;
 	unsigned int pin, irq;
+	char buffer[128];
+	node = cpu_to_node(0); // note: node is always node zero! Have sense in single kernel
 
 	for (pin = 0; pin < ioapics[ioapic_idx].nr_registers; pin++) {
 		idx = find_irq_entry(ioapic_idx, pin, mp_INT);
@@ -1487,31 +1496,31 @@ static void __init __io_apic_setup_irqs(unsigned int ioapic_idx)
 		 * installed and if it returns 1:
 		 */
 		if (apic->multi_timer_check &&
-		    apic->multi_timer_check(ioapic_idx, irq))
+				apic->multi_timer_check(ioapic_idx, irq))
 			continue;
 
 		set_io_apic_irq_attr(&attr, ioapic_idx, pin, irq_trigger(idx),
-				     irq_polarity(idx));
+				irq_polarity(idx));
 
 		io_apic_setup_irq_pin(irq, node, &attr);
 	}
-}
+	}
 
-static void __init setup_IO_APIC_irqs(void)
-{
-	unsigned int ioapic_idx;
+	static void __init setup_IO_APIC_irqs(void)
+	{
+		unsigned int ioapic_idx;
 
-	apic_printk(APIC_VERBOSE, KERN_DEBUG "init IO_APIC IRQs\n");
+		apic_printk(APIC_VERBOSE, KERN_DEBUG "init IO_APIC IRQs\n");
 
-	for (ioapic_idx = 0; ioapic_idx < nr_ioapics; ioapic_idx++)
-		__io_apic_setup_irqs(ioapic_idx);
-}
+		for (ioapic_idx = 0; ioapic_idx < nr_ioapics; ioapic_idx++)
+			__io_apic_setup_irqs(ioapic_idx);
+	}
 
-/*
- * for the gsit that is not in first ioapic
- * but could not use acpi_register_gsi()
- * like some special sci in IBM x3330
- */
+	/*
+	 * for the gsit that is not in first ioapic
+	 * but could not use acpi_register_gsi()
+	 * like some special sci in IBM x3330
+	 */
 void setup_IO_APIC_irq_extra(u32 gsi)
 {
 	int ioapic_idx = 0, pin, idx, irq, node = cpu_to_node(0);
@@ -1985,7 +1994,12 @@ void __init enable_IO_APIC(void)
 	/*
 	 * Do not trust the IO-APIC being empty at bootup
 	 */
-	clear_IO_APIC();
+	printk(KERN_WARNING "hard_smp_processor_id=%d boot_cpu_physical_apicid=%d lapic_is_bsp=%d\n",
+			hard_smp_processor_id(), boot_cpu_physical_apicid, !(!lapic_is_bsp()));
+	if (lapic_is_bsp()) { // this maybe substituted with a "mklinux" kernel cmd line parameter
+		printk(KERN_WARNING "clearing the IO APIC content\n");
+		clear_IO_APIC(); // the idea is that only the first kernel will clear the IO APIC content
+	}
 }
 
 /*
@@ -2292,6 +2306,10 @@ static void __target_IO_APIC_irq(unsigned int irq, unsigned int dest, struct irq
 	struct irq_pin_list *entry;
 	u8 vector = cfg->vector;
 
+	/* POPCORN -- continue remapping only on the bsp processor (master) */
+	if (!lapic_is_bsp())
+		return;
+
 	for_each_irq_pin(entry, cfg->irq_2_pin) {
 		unsigned int reg;
 
@@ -2301,12 +2319,12 @@ static void __target_IO_APIC_irq(unsigned int irq, unsigned int dest, struct irq
 		 * With interrupt-remapping, destination information comes
 		 * from interrupt-remapping table entry.
 		 */
-		if (!irq_remapped(cfg))
-			io_apic_write(apic, 0x11 + pin*2, dest);
+		if (!irq_remapped(cfg)) //original code
+			io_apic_write(apic, 0x11 + pin*2, dest); /* WRITE DESTINATION!!! */
 		reg = io_apic_read(apic, 0x10 + pin*2);
 		reg &= ~IO_APIC_REDIR_VECTOR_MASK;
 		reg |= vector;
-		io_apic_modify(apic, 0x10 + pin*2, reg);
+		io_apic_modify(apic, 0x10 + pin*2, reg); /* WRITE NEW MASK!!! */
 	}
 }
 
@@ -2990,7 +3008,7 @@ void __init setup_IO_APIC(void)
 	sync_Arb_IDs();
 	setup_IO_APIC_irqs();
 	init_IO_APIC_traps();
-	if (legacy_pic->nr_legacy_irqs)
+	if (legacy_pic->nr_legacy_irqs && lapic_is_bsp())
 		check_timer();
 }
 
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index aa003b1..0debb51 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -1149,29 +1149,37 @@ static void dbg_restore_debug_regs(void)
  */
 #ifdef CONFIG_X86_64
 
-void __cpuinit cpu_init(void)
+void __cpuinit cpu_init( int flags)
 {
 	struct orig_ist *oist;
 	struct task_struct *me;
 	struct tss_struct *t;
 	unsigned long v;
-	int cpu;
+	int cpu, smp_cpu;
 	int i;
 
 	cpu = stack_smp_processor_id();
+	smp_cpu = smp_processor_id();
+
+	printk("%s: cpu %d smp_cpu %d virtual %p\n",__func__,  cpu, smp_cpu, &cpu);
+
+	if (flags)
+		cpu = smp_cpu;
+
 	t = &per_cpu(init_tss, cpu);
 	oist = &per_cpu(orig_ist, cpu);
 
 #ifdef CONFIG_NUMA
 	if (cpu != 0 && percpu_read(numa_node) == 0 &&
-	    early_cpu_to_node(cpu) != NUMA_NO_NODE)
+			early_cpu_to_node(cpu) != NUMA_NO_NODE)
 		set_numa_node(early_cpu_to_node(cpu));
 #endif
 
 	me = current;
 
+
 	if (cpumask_test_and_set_cpu(cpu, cpu_initialized_mask))
-		panic("CPU#%d already initialized!\n", cpu);
+		panic("CPU#%d APICID %x unit_off=%lx already initialized!\n", cpu, read_apic_id(), per_cpu(this_cpu_off, cpu) );
 
 	pr_debug("Initializing CPU#%d\n", cpu);
 
diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 303a0e4..9487819 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -19,6 +19,7 @@
 #include <linux/acpi.h>
 #include <linux/firmware-map.h>
 #include <linux/memblock.h>
+#include <linux/multikernel.h>
 
 #include <asm/e820.h>
 #include <asm/proto.h>
@@ -824,7 +825,15 @@ unsigned long __init e820_end_of_ram_pfn(void)
 
 unsigned long __init e820_end_of_low_ram_pfn(void)
 {
+#ifdef CONFIG_POPCORN
+	if (mklinux_boot) {
+		return e820_end_pfn(1UL<<(64 - PAGE_SHIFT), E820_RAM);
+	} else {
+		return e820_end_pfn(1UL<<(32 - PAGE_SHIFT), E820_RAM);
+	}
+#else
 	return e820_end_pfn(1UL<<(32 - PAGE_SHIFT), E820_RAM);
+#endif
 }
 
 static void early_panic(char *msg)
diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S
index faf8d5e..11b3788 100644
--- a/arch/x86/kernel/entry_64.S
+++ b/arch/x86/kernel/entry_64.S
@@ -997,6 +997,12 @@ apicinterrupt CALL_FUNCTION_VECTOR \
 	call_function_interrupt smp_call_function_interrupt
 apicinterrupt RESCHEDULE_VECTOR \
 	reschedule_interrupt smp_reschedule_interrupt
+#ifdef CONFIG_POPCORN_KMSG
+apicinterrupt POPCORN_KMSG_VECTOR \
+	popcorn_kmsg_interrupt smp_popcorn_kmsg_interrupt
+apicinterrupt POPCORN_IPI_LATENCY_VECTOR \
+	popcorn_ipi_latency_interrupt smp_popcorn_ipi_latency_interrupt
+#endif
 #endif
 
 apicinterrupt ERROR_APIC_VECTOR \
diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
index 5655c22..fbc7462 100644
--- a/arch/x86/kernel/head64.c
+++ b/arch/x86/kernel/head64.c
@@ -27,6 +27,11 @@
 #include <asm/trampoline.h>
 #include <asm/bios_ebda.h>
 
+#include <linux/module.h>
+
+unsigned long orig_boot_params;
+EXPORT_SYMBOL(orig_boot_params);
+
 static void __init zap_identity_mappings(void)
 {
 	pgd_t *pgd = pgd_offset_k(0UL);
@@ -77,7 +82,7 @@ void __init x86_64_start_kernel(char * real_mode_data)
 	/* Make NULL pointers segfault */
 	zap_identity_mappings();
 
-	max_pfn_mapped = KERNEL_IMAGE_SIZE >> PAGE_SHIFT;
+	max_pfn_mapped = (KERNEL_IMAGE_SIZE >> PAGE_SHIFT) * 256;
 
 	for (i = 0; i < NUM_EXCEPTION_VECTORS; i++) {
 #ifdef CONFIG_EARLY_PRINTK
@@ -91,6 +96,8 @@ void __init x86_64_start_kernel(char * real_mode_data)
 	if (console_loglevel == 10)
 		early_printk("Kernel alive\n");
 
+	orig_boot_params = real_mode_data;
+
 	x86_64_start_reservations(real_mode_data);
 }
 
@@ -103,12 +110,25 @@ void __init x86_64_start_reservations(char *real_mode_data)
 	memblock_x86_reserve_range(__pa_symbol(&_text), __pa_symbol(&__bss_stop), "TEXT DATA BSS");
 
 #ifdef CONFIG_BLK_DEV_INITRD
+#define RAMDISK_MAGIC 0xdf
 	/* Reserve INITRD */
 	if (boot_params.hdr.type_of_loader && boot_params.hdr.ramdisk_image) {
 		/* Assume only end is not page aligned */
-		unsigned long ramdisk_image = boot_params.hdr.ramdisk_image;
+		unsigned long ramdisk_shift = boot_params.hdr.ramdisk_shift;
+		unsigned long ramdisk_image;
 		unsigned long ramdisk_size  = boot_params.hdr.ramdisk_size;
-		unsigned long ramdisk_end   = PAGE_ALIGN(ramdisk_image + ramdisk_size);
+		unsigned long ramdisk_end;
+	
+		/* POPCORN -- the BIOS might not zero out the ramdisk_shift
+		   field, so we need to account for it */
+		if (boot_params.hdr.ramdisk_magic == RAMDISK_MAGIC) {
+			ramdisk_image = boot_params.hdr.ramdisk_image + (ramdisk_shift << 32);
+		} else {
+			ramdisk_image = boot_params.hdr.ramdisk_image;
+		}
+
+		ramdisk_end = PAGE_ALIGN(ramdisk_image + ramdisk_size);
+
 		memblock_x86_reserve_range(ramdisk_image, ramdisk_end, "RAMDISK");
 	}
 #endif
diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S
index e11e394..def11a9 100644
--- a/arch/x86/kernel/head_64.S
+++ b/arch/x86/kernel/head_64.S
@@ -103,6 +103,8 @@ startup_64:
 	andq	$(PTRS_PER_PUD - 1), %rax
 	jz	ident_complete
 
+	/* MKLINUX -- Set the appropriate entry of level3_ident_pgt to 
+	 * point to level2_spare_pgt */
 	leaq	(level2_spare_pgt - __START_KERNEL_map + _KERNPG_TABLE)(%rbp), %rdx
 	leaq	level3_ident_pgt(%rip), %rbx
 	movq	%rdx, 0(%rbx, %rax, 8)
@@ -110,9 +112,24 @@ startup_64:
 	movq	%rdi, %rax
 	shrq	$PMD_SHIFT, %rax
 	andq	$(PTRS_PER_PMD - 1), %rax
+
+	/* MKLINUX -- at this point, %rax should be 0x0
+	 * and %rdi should be rounded down to a multiple of 1 GB */
+	movq    $0, %rax
+	andq    $0xffffffffc0000000, %rdi
+
+	/* MKLINUX -- fill up level2_spare_pgt to map the 1 GB where the
+	 * kernel has been loaded */
+	movq	$512, %rcx
 	leaq	__PAGE_KERNEL_IDENT_LARGE_EXEC(%rdi), %rdx
 	leaq	level2_spare_pgt(%rip), %rbx
-	movq	%rdx, 0(%rbx, %rax, 8)
+
+1:	movq	%rdx, 0(%rbx, %rax, 8)
+	addq	$0x00200000, %rdx
+	incq	%rax
+	decq    %rcx
+        jnz     1b
+
 ident_complete:
 
 	/*
@@ -237,6 +254,7 @@ ENTRY(secondary_startup_64)
 	movl	initial_gs+4(%rip),%edx
 	wrmsr	
 
+	/* MKLINUX -- note that esi contains the pointer to the boot_params structure! */
 	/* esi is pointer to real mode structure with interesting info.
 	   pass it to C */
 	movl	%esi, %edi
diff --git a/arch/x86/kernel/hpet.c b/arch/x86/kernel/hpet.c
index 1bb0bf4..cc6a61e 100644
--- a/arch/x86/kernel/hpet.c
+++ b/arch/x86/kernel/hpet.c
@@ -795,6 +795,11 @@ int __init hpet_enable(void)
 	u64 freq;
 	int i;
 
+	if (!hpet_virt_address) {
+		printk("%s: hpet_virt_address = 0x%p\n", __func__, hpet_virt_address);
+		return 0;
+	}
+
 	if (!is_hpet_capable())
 		return 0;
 
diff --git a/arch/x86/kernel/i387.c b/arch/x86/kernel/i387.c
index 739d859..168c22e 100644
--- a/arch/x86/kernel/i387.c
+++ b/arch/x86/kernel/i387.c
@@ -93,6 +93,7 @@ void __cpuinit fpu_init(void)
 {
 	unsigned long cr0;
 	unsigned long cr4_mask = 0;
+	char buf[96]; memset(buf, 0, 96);
 
 	if (cpu_has_fxsr)
 		cr4_mask |= X86_CR4_OSFXSR;
@@ -107,7 +108,12 @@ void __cpuinit fpu_init(void)
 		cr0 |= X86_CR0_EM;
 	write_cr0(cr0);
 
-	if (!smp_processor_id())
+	cpumask_scnprintf(buf, 96, cpu_present_mask);
+	printk("%s: processor id %d (hard id %x)\npresent_map %d %s",
+			__func__, smp_processor_id(), read_apic_id(), first_cpu(cpu_present_map), buf);
+	// original: if (!smp_processor_id())
+	if ((read_apic_id() == boot_cpu_physical_apicid) 
+			&& (smp_processor_id() == first_cpu(cpu_present_map)))
 		init_thread_xstate();
 
 	mxcsr_feature_mask_init();
diff --git a/arch/x86/kernel/irq.c b/arch/x86/kernel/irq.c
index 429e0c9..1377bbc 100644
--- a/arch/x86/kernel/irq.c
+++ b/arch/x86/kernel/irq.c
@@ -117,6 +117,12 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 		seq_printf(p, "%10u ", per_cpu(mce_poll_count, j));
 	seq_printf(p, "  Machine check polls\n");
 #endif
+#ifdef CONFIG_POPCORN_KMSG
+	seq_printf(p, "%*s: ", prec, "PKM");
+	for_each_online_cpu(j)
+		seq_printf(p, "%10u ", irq_stats(j)->irq_popcorn_kmsg_count);
+	seq_printf(p, "  Popcorn kernel message interrupts\n");
+#endif
 	seq_printf(p, "%*s: %10u\n", prec, "ERR", atomic_read(&irq_err_count));
 #if defined(CONFIG_X86_IO_APIC)
 	seq_printf(p, "%*s: %10u\n", prec, "MIS", atomic_read(&irq_mis_count));
@@ -150,6 +156,9 @@ u64 arch_irq_stat_cpu(unsigned int cpu)
 #ifdef CONFIG_X86_MCE_THRESHOLD
 	sum += irq_stats(cpu)->irq_threshold_count;
 #endif
+#ifdef CONFIG_POPCORN_KMSG
+	sum += irq_stats(cpu)->irq_popcorn_kmsg_count;
+#endif
 #ifdef CONFIG_X86_MCE
 	sum += per_cpu(mce_exception_count, cpu);
 	sum += per_cpu(mce_poll_count, cpu);
diff --git a/arch/x86/kernel/irqinit.c b/arch/x86/kernel/irqinit.c
index b3300e6..c4d4218 100644
--- a/arch/x86/kernel/irqinit.c
+++ b/arch/x86/kernel/irqinit.c
@@ -258,6 +258,13 @@ static void __init smp_intr_init(void)
 
 	/* IPI used for rebooting/stopping */
 	alloc_intr_gate(REBOOT_VECTOR, reboot_interrupt);
+
+#ifdef CONFIG_POPCORN_KMSG
+	/* POPCORN -- IPI used for inter-kernel messaging */
+	alloc_intr_gate(POPCORN_KMSG_VECTOR, popcorn_kmsg_interrupt);
+
+	alloc_intr_gate(POPCORN_IPI_LATENCY_VECTOR, popcorn_ipi_latency_interrupt);
+#endif
 #endif
 #endif /* CONFIG_SMP */
 }
diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
index 6a364a6..0aa245a 100644
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -332,10 +332,14 @@ start_thread_common(struct pt_regs *regs, unsigned long new_ip,
 		    unsigned long new_sp,
 		    unsigned int _cs, unsigned int _ss, unsigned int _ds)
 {
-	loadsegment(fs, 0);
 	loadsegment(es, _ds);
 	loadsegment(ds, _ds);
-	load_gs_index(0);
+	// Multikernel
+	// we are handling FS and GS in process_server_import_address_space
+	if ( !current->executing_for_remote ) {
+	    loadsegment(fs, 0);
+	    load_gs_index(0);
+	} 
 	regs->ip		= new_ip;
 	regs->sp		= new_sp;
 	percpu_write(old_rsp, new_sp);
diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index cf0ef98..843f636 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -316,10 +316,12 @@ static void __init reserve_brk(void)
 #ifdef CONFIG_BLK_DEV_INITRD
 
 #define MAX_MAP_CHUNK	(NR_FIX_BTMAPS << PAGE_SHIFT)
+#define RAMDISK_MAGIC 0xdf
 static void __init relocate_initrd(void)
 {
 	/* Assume only end is not page aligned */
-	u64 ramdisk_image = boot_params.hdr.ramdisk_image;
+	u64 ramdisk_shift = boot_params.hdr.ramdisk_shift;
+	u64 ramdisk_image;
 	u64 ramdisk_size  = boot_params.hdr.ramdisk_size;
 	u64 area_size     = PAGE_ALIGN(ramdisk_size);
 	u64 end_of_lowmem = max_low_pfn_mapped << PAGE_SHIFT;
@@ -327,6 +329,14 @@ static void __init relocate_initrd(void)
 	unsigned long slop, clen, mapaddr;
 	char *p, *q;
 
+	/* POPCORN -- the BIOS might not zero out the ramdisk_shift
+	   field, so we need to account for it */
+	if (boot_params.hdr.ramdisk_magic == RAMDISK_MAGIC) {
+		ramdisk_image = boot_params.hdr.ramdisk_image + (ramdisk_shift << 32);
+	} else {
+		ramdisk_image = boot_params.hdr.ramdisk_image;
+	}
+
 	/* We need to move the initrd down into lowmem */
 	ramdisk_here = memblock_find_in_range(0, end_of_lowmem, area_size,
 					 PAGE_SIZE);
@@ -381,13 +391,29 @@ static void __init relocate_initrd(void)
 static void __init reserve_initrd(void)
 {
 	/* Assume only end is not page aligned */
-	u64 ramdisk_image = boot_params.hdr.ramdisk_image;
+	u64 ramdisk_shift = boot_params.hdr.ramdisk_shift;
+	u64 ramdisk_image;
 	u64 ramdisk_size  = boot_params.hdr.ramdisk_size;
-	u64 ramdisk_end   = PAGE_ALIGN(ramdisk_image + ramdisk_size);
+	u64 ramdisk_end;
 	u64 end_of_lowmem = max_low_pfn_mapped << PAGE_SHIFT;
 
+	/* POPCORN -- the BIOS might not zero out the ramdisk_shift
+	   field, so we need to account for it */
+	if (boot_params.hdr.ramdisk_magic == RAMDISK_MAGIC) {
+		printk("ramdisk magic number is correct (0x%x), applying shift...\n", boot_params.hdr.ramdisk_magic);
+		ramdisk_image = boot_params.hdr.ramdisk_image + (ramdisk_shift << 32);
+	} else {
+		printk("ramdisk magic number is wrong (0x%x)\n", boot_params.hdr.ramdisk_magic);
+		ramdisk_image = boot_params.hdr.ramdisk_image;
+	}
+
+	ramdisk_end = PAGE_ALIGN(ramdisk_image + ramdisk_size);
+
+	printk("ramdisk_image 0x%lx, size 0x%lx, shift 0x%lx, end 0x%lx, end_of_lowmem 0x%lx\n",
+                        ramdisk_image, ramdisk_size, ramdisk_shift, ramdisk_end, end_of_lowmem);
+
 	if (!boot_params.hdr.type_of_loader ||
-	    !ramdisk_image || !ramdisk_size)
+			!ramdisk_image || !ramdisk_size)
 		return;		/* No initrd provided by bootloader */
 
 	initrd_start = 0;
@@ -395,11 +421,11 @@ static void __init reserve_initrd(void)
 	if (ramdisk_size >= (end_of_lowmem>>1)) {
 		memblock_x86_free_range(ramdisk_image, ramdisk_end);
 		printk(KERN_ERR "initrd too large to handle, "
-		       "disabling initrd\n");
+				"disabling initrd\n");
 		return;
 	}
 
-	printk(KERN_INFO "RAMDISK: %08llx - %08llx\n", ramdisk_image,
+	printk(KERN_INFO "RAMDISK: %llx - %llx\n", ramdisk_image,
 			ramdisk_end);
 
 
@@ -409,6 +435,7 @@ static void __init reserve_initrd(void)
 		 * don't need to reserve again, already reserved early
 		 * in i386_start_kernel
 		 */
+		printk("Ramdisk all in lowmem -- easy case\n");
 		initrd_start = ramdisk_image + PAGE_OFFSET;
 		initrd_end = initrd_start + ramdisk_size;
 		return;
@@ -881,12 +908,16 @@ void __init setup_arch(char **cmdline_p)
 
 	check_x2apic();
 
+	printk("max_pfn is 0x%lx\n", max_pfn);
+
 	/* How many end-of-memory variables you have, grandma! */
 	/* need this before calling reserve_initrd */
-	if (max_pfn > (1UL<<(32 - PAGE_SHIFT)))
+	if (max_pfn > (1UL<<(32 - PAGE_SHIFT))) {
+		printk("Setting max_low_pfn to e820_end_of_low_ram_pfn\n");
 		max_low_pfn = e820_end_of_low_ram_pfn();
-	else
+	} else {
 		max_low_pfn = max_pfn;
+	}
 
 	high_memory = (void *)__va(max_pfn * PAGE_SIZE - 1) + 1;
 #endif
@@ -928,9 +959,12 @@ void __init setup_arch(char **cmdline_p)
 			max_pfn_mapped<<PAGE_SHIFT);
 
 	setup_trampolines();
+	setup_trampolines_bsp();
 
 	init_gbpages();
 
+	printk("max_low_pfn 0x%lx, page_shift 0x%lx\n", max_low_pfn, PAGE_SHIFT);
+
 	/* max_pfn_mapped is updated here */
 	max_low_pfn_mapped = init_memory_mapping(0, max_low_pfn<<PAGE_SHIFT);
 	max_pfn_mapped = max_low_pfn_mapped;
@@ -1017,7 +1051,8 @@ void __init setup_arch(char **cmdline_p)
 	if (smp_found_config)
 		get_smp_config();
 
-	prefill_possible_map();
+	prefill_possible_map(); // cpu_possible_mask fill with other cpus from setup_possible_cpus, disabled_cpus...
+	prefill_present_map(); // POPCORN -- reset_present_map(); TODO HERE or before prefile_possible in order to set max_cpus from the present_map
 
 	init_cpu_to_node();
 
diff --git a/arch/x86/kernel/setup_percpu.c b/arch/x86/kernel/setup_percpu.c
index 71f4727..8bc0a17 100644
--- a/arch/x86/kernel/setup_percpu.c
+++ b/arch/x86/kernel/setup_percpu.c
@@ -170,8 +170,10 @@ void __init setup_per_cpu_areas(void)
 	unsigned long delta;
 	int rc;
 
-	pr_info("NR_CPUS:%d nr_cpumask_bits:%d nr_cpu_ids:%d nr_node_ids:%d\n",
-		NR_CPUS, nr_cpumask_bits, nr_cpu_ids, nr_node_ids);
+/*	pr_info("NR_CPUS:%d nr_cpumask_bits:%d nr_cpu_ids:%d nr_node_ids:%d\n",
+			NR_CPUS, nr_cpumask_bits, nr_cpu_ids, nr_node_ids);
+*/	printk("%s NR_CPUS:%d nr_cpumask_bits:%d nr_cpu_ids:%d nr_node_ids:%d\n",
+			__func__, NR_CPUS, nr_cpumask_bits, nr_cpu_ids, nr_node_ids);
 
 	/*
 	 * Allocate percpu area.  Embedding allocator is our favorite;
@@ -206,12 +208,19 @@ void __init setup_per_cpu_areas(void)
 
 	/* alrighty, percpu areas up and running */
 	delta = (unsigned long)pcpu_base_addr - (unsigned long)__per_cpu_start;
+	printk("%s delta=%lx pcpu_base_addr=%lx __per_cpu_start=%lx\n",
+			__func__, delta, (unsigned long)pcpu_base_addr, (unsigned long)__per_cpu_start);
 	for_each_possible_cpu(cpu) {
 		per_cpu_offset(cpu) = delta + pcpu_unit_offsets[cpu];
 		per_cpu(this_cpu_off, cpu) = per_cpu_offset(cpu);
 		per_cpu(cpu_number, cpu) = cpu;
-		setup_percpu_segment(cpu);
-		setup_stack_canary_segment(cpu);
+/*		pr_info("CPU%d per_cpu_offset=%x this_cpu_off=%x cpu_number=%d\n",
+				cpu, per_cpu_offset(cpu), per_cpu(this_cpu_off, cpu), per_cpu(cpu_number, cpu));
+*/		printk("%s CPU%d per_cpu_offset=%lx unit_off=%lx cpu_number=%d\n",
+				__func__, cpu, per_cpu_offset(cpu), pcpu_unit_offsets[cpu], per_cpu(cpu_number, cpu));
+
+		setup_percpu_segment(cpu); // only 32bit
+		setup_stack_canary_segment(cpu); // only 32bit
 		/*
 		 * Copy data used in early init routines from the
 		 * initial arrays to the per cpu data areas.  These
@@ -224,6 +233,8 @@ void __init setup_per_cpu_areas(void)
 			early_per_cpu_map(x86_cpu_to_apicid, cpu);
 		per_cpu(x86_bios_cpu_apicid, cpu) =
 			early_per_cpu_map(x86_bios_cpu_apicid, cpu);
+		printk("%s: cpu %d x86_cpu_to_apicid %d x86_bios_cpu_apicid %d\n", __func__, cpu,
+				early_per_cpu_map(x86_cpu_to_apicid, cpu), early_per_cpu_map(x86_bios_cpu_apicid, cpu));
 #endif
 #ifdef CONFIG_X86_32
 		per_cpu(x86_cpu_to_logical_apicid, cpu) =
@@ -247,12 +258,19 @@ void __init setup_per_cpu_areas(void)
 		 */
 		set_cpu_numa_node(cpu, early_cpu_to_node(cpu));
 #endif
+
 		/*
 		 * Up to this point, the boot CPU has been using .init.data
 		 * area.  Reload any changed state for the boot CPU.
 		 */
-		if (!cpu)
-			switch_to_new_gdt(cpu);
+		/* POPCORN -- This will happen ONLY if the CPU is booting 
+		 * CPU that do not have to be the ZERO */
+		//if (!cpu) // PREVIOUS CODE
+		if ((read_apic_id() == boot_cpu_physical_apicid)
+				&& (cpu == first_cpu(cpu_present_map))) {
+			printk("boot cpu physical acpiid %d\n", cpu);
+			switch_to_new_gdt(cpu); 
+		}
 	}
 
 	/* indicate the early static arrays will soon be gone */
diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index 9f548cb..d03e97e 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -72,6 +72,8 @@
 #include <asm/smpboot_hooks.h>
 #include <asm/i8259.h>
 
+extern unsigned long orig_boot_params;
+
 /* State of each CPU */
 DEFINE_PER_CPU(int, cpu_state) = { 0 };
 
@@ -248,7 +250,7 @@ notrace static void __cpuinit start_secondary(void *unused)
 	 * fragile that we want to limit the things done here to the
 	 * most necessary things.
 	 */
-	cpu_init();
+	cpu_init(0);
 	preempt_disable();
 	smp_callin();
 
@@ -321,7 +323,7 @@ void __cpuinit smp_store_cpu_info(int id)
 
 	*c = boot_cpu_data;
 	c->cpu_index = id;
-	if (id != 0)
+	if (id != first_cpu(cpu_present_map))
 		identify_secondary_cpu(c);
 }
 
@@ -484,7 +486,7 @@ wakeup_secondary_cpu_via_nmi(int logical_apicid, unsigned long start_eip)
 {
 	unsigned long send_status, accept_status = 0;
 	int maxlvt;
-
+	printk(KERN_ERR"%s WANTS LOGICAL %d\n", __func__, logical_apicid);
 	/* Target chip */
 	/* Boot on the stack */
 	/* Kick the second */
@@ -518,7 +520,7 @@ wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
 {
 	unsigned long send_status, accept_status = 0;
 	int maxlvt, num_starts, j;
-
+	printk(KERN_ERR"%s WANTS PHYSICAL %d START ip %lu\n",__func__, phys_apicid, start_eip);
 	maxlvt = lapic_get_maxlvt();
 
 	/*
@@ -664,6 +666,109 @@ static void __cpuinit announce_cpu(int cpu, int apicid)
 			node, cpu, apicid);
 }
 
+
+
+
+/*
+ * NOTE - on most systems this is a PHYSICAL apic ID, but on multiquad
+ * (ie clustered apic addressing mode), this is a LOGICAL apic ID.
+ * Returns zero if CPU booted OK, else error code from
+ * ->wakeup_secondary_cpu.
+ */
+
+int __cpuinit mkbsp_boot_cpu(int apicid, int cpu, unsigned long kernel_start_address)
+{
+	unsigned long boot_error = 0;
+	unsigned long start_ip;
+	int timeout;
+
+	/* POPCORN -- set physical address where kernel has been copied.
+	   Note that this needs to be written to the location where the
+	   trampoline was copied, not to the location within the original
+	   kernel itself. */
+
+	unsigned long *kernel_virt_addr = TRAMPOLINE_SYM_BSP(&kernel_phys_addr);
+	unsigned long *boot_params_virt_addr = TRAMPOLINE_SYM_BSP(&boot_params_phys_addr);
+	
+	*kernel_virt_addr = kernel_start_address;
+	*boot_params_virt_addr = orig_boot_params;
+
+	/* start_ip had better be page-aligned! */
+	start_ip = trampoline_bsp_address();
+
+	/*
+	 * This grunge runs the startup process for
+	 * the targeted processor.
+	 */
+
+	printk("Popcorn boot: CPU %d: start_ip = %lx\n", cpu, start_ip);
+
+	if (get_uv_system_type() != UV_NON_UNIQUE_APIC) {
+
+		pr_debug("Setting warm reset code and vector.\n");
+
+		smpboot_setup_warm_reset_vector(start_ip);
+		/*
+		 * Be paranoid about clearing APIC errors.
+		*/
+		if (APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {
+			apic_write(APIC_ESR, 0);
+			apic_read(APIC_ESR);
+		}
+	}
+
+	/*
+	 * Kick the secondary CPU. Use the method in the APIC driver
+	 * if it's defined - or use an INIT boot APIC message otherwise:
+	 */
+	if (apic->wakeup_secondary_cpu)
+		boot_error = apic->wakeup_secondary_cpu(apicid, start_ip);
+	else
+		boot_error = wakeup_secondary_cpu_via_init(apicid, start_ip);
+
+	if (!boot_error) {
+
+		/*
+		 * Wait 5s total for a response
+		 */
+		for (timeout = 0; timeout < 50000; timeout++) {
+			udelay(100);
+
+			if (*(volatile u32 *)TRAMPOLINE_SYM_BSP(trampoline_status_bsp)
+			    == 0xA5A5A5A5) {
+				/* trampoline started but...? */
+				pr_info("CPU%d: Trampoline has started.\n", cpu);
+				break;
+			} else {
+				/* trampoline code not run */
+				pr_err("CPU%d: Not responding.\n", cpu);
+				boot_error = 1;
+				if (apic->inquire_remote_apic)
+					apic->inquire_remote_apic(apicid);
+			}
+
+			/*
+                         * Allow other tasks to run while we wait for the
+                         * AP to come online. This also gives a chance
+                         * for the MTRR work(triggered by the AP coming online)
+                         * to be completed in the stop machine context.
+                         */
+                        schedule();
+		}
+	}
+
+	if (boot_error) {
+		pr_err("Popcorn: boot error!!!\n");
+	}
+
+	/* mark "stuck" area as not stuck */
+	*(volatile u32 *)TRAMPOLINE_SYM_BSP(trampoline_status_bsp) = 0;
+
+	return boot_error;
+}
+
+
+
 /*
  * NOTE - on most systems this is a PHYSICAL apic ID, but on multiquad
  * (ie clustered apic addressing mode), this is a LOGICAL apic ID.
@@ -918,7 +1023,7 @@ static int __init smp_sanity_check(unsigned max_cpus)
 	preempt_disable();
 
 #if !defined(CONFIG_X86_BIGSMP) && defined(CONFIG_X86_32)
-	if (def_to_bigsmp && nr_cpu_ids > 8) {
+	if (def_to_bigsmp && nr_cpu_idssmp_store_cpu_info > 8) {
 		unsigned int cpu;
 		unsigned nr;
 
@@ -1031,6 +1136,7 @@ static void __init smp_cpu_index_default(void)
 void __init native_smp_prepare_cpus(unsigned int max_cpus)
 {
 	unsigned int i;
+	unsigned int cpu = first_cpu(cpu_present_map);
 
 	preempt_disable();
 	smp_cpu_index_default();
@@ -1038,17 +1144,17 @@ void __init native_smp_prepare_cpus(unsigned int max_cpus)
 	/*
 	 * Setup boot CPU information
 	 */
-	smp_store_cpu_info(0); /* Final full version of the data */
-	cpumask_copy(cpu_callin_mask, cpumask_of(0));
+	smp_store_cpu_info(cpu); /* Final full version of the data */
+	cpumask_copy(cpu_callin_mask, cpumask_of(cpu));
 	mb();
 
-	current_thread_info()->cpu = 0;  /* needed? */
+	current_thread_info()->cpu = cpu;  /* needed? */
 	for_each_possible_cpu(i) {
 		zalloc_cpumask_var(&per_cpu(cpu_sibling_map, i), GFP_KERNEL);
 		zalloc_cpumask_var(&per_cpu(cpu_core_map, i), GFP_KERNEL);
 		zalloc_cpumask_var(&per_cpu(cpu_llc_shared_map, i), GFP_KERNEL);
 	}
-	set_cpu_sibling_map(0);
+	set_cpu_sibling_map(cpu);
 
 
 	if (smp_sanity_check(max_cpus) < 0) {
@@ -1090,8 +1196,8 @@ void __init native_smp_prepare_cpus(unsigned int max_cpus)
 	 * Set up local APIC timer on boot CPU.
 	 */
 
-	printk(KERN_INFO "CPU%d: ", 0);
-	print_cpu_info(&cpu_data(0));
+	printk(KERN_INFO "CPU%d: ", cpu);
+	print_cpu_info(&cpu_data(cpu));
 	x86_init.timers.setup_percpu_clockev();
 
 	if (is_uv_system())
@@ -1157,6 +1263,63 @@ static int __init _setup_possible_cpus(char *str)
 }
 early_param("possible_cpus", _setup_possible_cpus);
 
+static DECLARE_BITMAP(setup_present_bits, CONFIG_NR_CPUS) __read_mostly;
+const struct cpumask *const setup_present_mask = to_cpumask(setup_present_bits);
+
+static int __init _setup_present_mask(char *str)
+{
+	cpulist_parse(str, (struct cpumask *)setup_present_mask);
+	return 0;
+}
+early_param("present_mask", _setup_present_mask);
+
+__init void prefill_present_map(void)
+{
+	int present;
+	int first;
+	char buffer[96];
+	memset(buffer, 0, 96);
+
+	//check present with possible
+	present = cpumask_weight(setup_present_mask);
+	first = cpumask_first(setup_present_mask);
+	// print present mask
+	cpumask_scnprintf(buffer, 96, setup_present_mask);
+	printk(KERN_INFO "%s: present_cpus %d %s, first %d, max_cpus %d\n",
+			__func__, present, buffer, first, setup_max_cpus);
+
+	//we assume that present was never settedif it is 0, prefill it with setup_max_cpus (if setted)
+	if (!present) {
+		int i;
+		for (i=0; i<setup_max_cpus; i++)
+			cpumask_set_cpu(i, (struct cpumask *) setup_present_mask);
+		present = cpumask_weight(setup_present_mask);
+		goto _finalize;
+	}
+
+	// present and setup_max_cpus must be synchronized, setup_max_cpus is imposed by the user
+	// does it affects hot plug? hopefully no
+	if (present != setup_max_cpus)
+		setup_max_cpus = present;
+
+	//figure out which is the current processor and change the present subset accordingly
+	cpumask_copy((struct cpumask *)cpu_present_mask, (struct cpumask *)setup_present_mask);
+
+	//adjust online and active cpu masks
+	cpumask_clear((struct cpumask *)cpu_online_mask);
+	cpumask_set_cpu(first_cpu(cpu_present_map), (struct cpumask *)cpu_online_mask);
+	cpumask_copy((struct cpumask *)cpu_active_mask, (struct cpumask *)cpu_online_mask);
+
+_finalize:
+	// TODO basically a check about the previous setting of cpu_online_mask and cpu_active_mask must be done
+	cpumask_scnprintf(buffer, 96, cpu_present_mask);
+        printk(KERN_INFO "%s: cpu_present_mask %s\n",__func__, buffer);
+        cpumask_scnprintf(buffer, 96, cpu_online_mask);
+        printk(KERN_INFO "%s: cpu_online_mask %s\n",__func__, buffer);
+        cpumask_scnprintf(buffer, 96, cpu_active_mask);
+        printk(KERN_INFO "%s: cpu_active_mask %s\n ",__func__, buffer);
+	return;
+}
 
 /*
  * cpu_possible_mask should be static, it cannot change as cpu's
diff --git a/arch/x86/kernel/trampoline.c b/arch/x86/kernel/trampoline.c
index a91ae77..ddf4212 100644
--- a/arch/x86/kernel/trampoline.c
+++ b/arch/x86/kernel/trampoline.c
@@ -5,7 +5,10 @@
 #include <asm/cacheflush.h>
 #include <asm/pgtable.h>
 
+extern int mklinux_boot;
+
 unsigned char *x86_trampoline_base;
+unsigned char *x86_trampoline_bsp_base;
 
 void __init setup_trampolines(void)
 {
@@ -23,7 +26,38 @@ void __init setup_trampolines(void)
 	printk(KERN_DEBUG "Base memory trampoline at [%p] %llx size %zu\n",
 	       x86_trampoline_base, (unsigned long long)mem, size);
 
-	memcpy(x86_trampoline_base, x86_trampoline_start, size);
+	/* POPCORN -- this is commented out because it breaks clustering.
+	 * TODO -- need to fix! */
+//	if (!mklinux_boot) {
+		memcpy(x86_trampoline_base, x86_trampoline_start, size);
+//	} else {
+//		printk("Popcorn boot: SMP trampoline will NOT be copied\n");
+//	}
+}
+
+
+void __init setup_trampolines_bsp(void)
+{
+	phys_addr_t mem;
+	size_t size = PAGE_ALIGN(x86_trampoline_bsp_end - x86_trampoline_bsp_start);
+
+	/* Has to be in very low memory so we can execute real-mode AP code. */
+	mem = memblock_find_in_range(0, 1<<20, size, PAGE_SIZE);
+	if (mem == MEMBLOCK_ERROR)
+		panic("Cannot allocate trampoline\n");
+
+	x86_trampoline_bsp_base = __va(mem);
+	memblock_x86_reserve_range(mem, mem + size, "TRAMPOLINE_BSP");
+
+	printk(KERN_DEBUG "Base memory trampoline BSP at [%p] %llx size %zu\n",
+	       x86_trampoline_bsp_base, (unsigned long long)mem, size);
+
+	if (!mklinux_boot) {
+		memcpy(x86_trampoline_bsp_base, x86_trampoline_bsp_start, size);
+
+	} else {
+		printk("Popcorn boot: BSP trampoline will NOT be copied\n");
+	}
 }
 
 /*
@@ -39,4 +73,16 @@ static int __init configure_trampolines(void)
 	set_memory_x((unsigned long)x86_trampoline_base, size >> PAGE_SHIFT);
 	return 0;
 }
+
 arch_initcall(configure_trampolines);
+
+static int __init configure_trampolines_bsp(void)
+{
+	size_t size = PAGE_ALIGN(x86_trampoline_bsp_end - x86_trampoline_bsp_start);
+
+	set_memory_x((unsigned long)x86_trampoline_bsp_base, size >> PAGE_SHIFT);
+	return 0;
+}
+
+arch_initcall(configure_trampolines_bsp);
+
diff --git a/arch/x86/kernel/trampoline_64_bsp.S b/arch/x86/kernel/trampoline_64_bsp.S
new file mode 100644
index 0000000..590bb7c
--- /dev/null
+++ b/arch/x86/kernel/trampoline_64_bsp.S
@@ -0,0 +1,305 @@
+/*
+ *
+ *	Trampoline.S	Derived from Setup.S by Linus Torvalds
+ *
+ *	4 Jan 1997 Michael Chastain: changed to gnu as.
+ *	15 Sept 2005 Eric Biederman: 64bit PIC support
+ *
+ *	Entry: CS:IP point to the start of our code, we are 
+ *	in real mode with no stack, but the rest of the 
+ *	trampoline page to make our stack and everything else
+ *	is a mystery.
+ *
+ *	On entry to trampoline_data, the processor is in real mode
+ *	with 16-bit addressing and 16-bit data.  CS has some value
+ *	and IP is zero.  Thus, data addresses need to be absolute
+ *	(no relocation) and are taken with regard to r_base.
+ *
+ *	With the addition of trampoline_level4_pgt this code can
+ *	now enter a 64bit kernel that lives at arbitrary 64bit
+ *	physical addresses.
+ *
+ *	If you work on this file, check the object module with objdump
+ *	--full-contents --reloc to make sure there are no relocation
+ *	entries.
+ */
+
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/pgtable_types.h>
+#include <asm/page_types.h>
+#include <asm/msr.h>
+#include <asm/segment.h>
+#include <asm/processor-flags.h>
+
+	.section ".x86_trampoline_bsp","a"
+	.balign PAGE_SIZE
+	.code16
+
+ENTRY(trampoline_data_bsp)
+bsp_base = .
+	cli			# We should be safe anyway
+	wbinvd
+	mov	%cs, %ax	# Code and data in the same place
+	mov	%ax, %ds
+	mov	%ax, %es
+	mov	%ax, %ss
+
+
+	movl	$0xA5A5A5A5, trampoline_status_bsp - bsp_base
+				# write marker for master knows we're running
+
+					# Setup stack
+	movw	$(trampoline_stack_bsp_end - bsp_base), %sp
+
+	# call	verify_cpu		# Verify the cpu supports long mode
+	# testl   %eax, %eax		# Check for return code
+	# jnz	no_longmode_bsp
+
+	mov	%cs, %ax
+	movzx	%ax, %esi		# Find the 32bit trampoline location
+	shll	$4, %esi
+
+					# Fixup the absolute vectors
+	leal	(startup_32_bsp - bsp_base)(%esi), %eax
+	movl	%eax, startup_32_vector_bsp - bsp_base
+	leal	(startup_64_bsp - bsp_base)(%esi), %eax
+	movl	%eax, startup_64_vector_bsp - bsp_base
+	leal	(tgdt_bsp - bsp_base)(%esi), %eax
+	movl	%eax, (tgdt_bsp + 2 - bsp_base)
+
+	/*
+	 * GDT tables in non default location kernel can be beyond 16MB and
+	 * lgdt will not be able to load the address as in real mode default
+	 * operand size is 16bit. Use lgdtl instead to force operand size
+	 * to 32 bit.
+	 */
+
+	lidtl	tidt_bsp - bsp_base	# load idt with 0, 0
+	lgdtl	tgdt_bsp - bsp_base	# load gdt with whatever is appropriate
+
+	mov	$X86_CR0_PE, %ax	# protected mode (PE) bit
+	lmsw	%ax			# into protected mode
+
+	# flush prefetch and jump to startup_32
+	ljmpl	*(startup_32_vector_bsp - bsp_base)
+
+	.code32
+	.balign 4
+startup_32_bsp:
+
+	/* MKLINUX -- at this point, we're in 32-bit protected mode */
+
+	/* MKLINUX -- at this point, the segment selector registers point to
+	 * the beginning of the trampoline (usually 0x92000), and we need to 
+	 * change them to point to the beginning of the address space (0x0) */
+	cli
+        movl    $(__KERNEL_DS), %eax
+        movl    %eax, %ds
+        movl    %eax, %es
+        movl    %eax, %ss
+
+	/* MKLINUX -- from boot/compressed/head_64.S */
+
+	/* Load new GDT with the 64bit segments using 32bit descriptor.
+	 * The new GDT labels the entire address space as 64-bit, so we
+	 * can switch into long mode later. */
+        leal    (gdt_bsp_64 - bsp_base)(%esi), %eax
+        movl    %eax, (gdt_bsp_64 - bsp_base + 2)(%esi)
+        lgdt    (gdt_bsp_64 - bsp_base)(%esi)
+
+	/* Enable PAE mode.  Note that this does not actually take effect
+	 * until paging is enabled */
+	movl	%cr4, %eax
+        orl     $(X86_CR4_PAE), %eax
+        movl    %eax, %cr4
+
+	/* MKLINUX -- this is code from arch/x86/boot/compressed/head_64.S
+         * It's necessary here in order to set up pagetables to identity-map
+	 * the first 4 GB of the address space prior to entering the kernel. */
+
+        /* Initialize Page tables to 0 */
+	leal    (pgtable_bsp - bsp_base)(%esi), %edi
+	xorl    %eax, %eax
+        movl    $((4096*6)/4), %ecx
+        rep     stosl
+
+        /* Build Level 4 */
+        leal    (pgtable_bsp - bsp_base)(%esi), %edi
+        leal    0x1007 (%edi), %eax
+        movl    %eax, 0(%edi)
+
+        /* Build Level 3 */
+        leal    (pgtable_bsp - bsp_base + 0x1000)(%esi), %edi
+        leal    0x1007(%edi), %eax
+        movl    $4, %ecx
+1:      movl    %eax, 0x00(%edi)
+        addl    $0x00001000, %eax
+        addl    $8, %edi
+        decl    %ecx
+        jnz     1b
+
+        /* Build Level 2 */
+        leal    (pgtable_bsp - bsp_base + 0x2000)(%esi), %edi
+        movl    $0x00000183, %eax
+        movl    $2048, %ecx
+1:      movl    %eax, 0(%edi)
+        addl    $0x00200000, %eax
+        addl    $8, %edi
+        decl    %ecx
+        jnz     1b
+
+        /* Enable the boot page tables */
+        leal    (pgtable_bsp - bsp_base)(%esi), %eax
+        movl    %eax, %cr3
+
+        /* Enable Long mode in EFER (Extended Feature Enable Register) */
+        movl    $MSR_EFER, %ecx
+        rdmsr
+        btsl    $_EFER_LME, %eax
+        wrmsr
+
+        /*
+         * Setup for the jump to 64bit mode
+         *
+         * When the jump is performend we will be in long mode but
+         * in 32bit compatibility mode with EFER.LME = 1, CS.L = 0, CS.D = 1
+         * (and in turn EFER.LMA = 1).  To jump into 64bit mode we use
+         * the new gdt/idt that has __KERNEL_CS with CS.L = 1.
+         * We place all of the values on our mini stack so lret can
+         * used to perform that far jump.
+         */
+        pushl   $__KERNEL_CS
+        leal    (startup_64_bsp - bsp_base)(%esi), %eax
+        pushl   %eax
+
+	/* Enter paged protected Mode, activating Long Mode */
+        movl    $(X86_CR0_PG | X86_CR0_PE), %eax /* Enable Paging and Protected mode */
+        movl    %eax, %cr0
+
+	/* Jump from 32bit compatibility mode into 64bit mode. */
+        lret
+
+	.code64
+	.balign 4
+startup_64_bsp:
+
+	/* MKLINUX -- We should be in full 64-bit mode here, so we're 
+	 * able to jump to a kernel anywhere in the address space */
+
+	/* Get physical address of boot_params structure */
+	movq    (boot_params_phys_addr - bsp_base)(%rsi), %r15
+
+	/* Load kernel address into register */
+	movq    (kernel_phys_addr - bsp_base)(%rsi), %r14
+
+	/* Check whether the kernel is in the 4 GB we mapped already,
+	 * and if not, add an additional mapping */
+	movq	$0xffffffff00000000, %r8
+	testq	%r8, %r14
+	je	2f
+
+	/* If we got here, we need to identity-map an additional 1 GB */
+	
+	/* Mask off to figure out what our directory pointer should be */
+	movq	%r14, %r13
+	movq	$0xffffffffc0000000, %r12
+	andq	%r12, %r13
+
+	/* Set our PDPTE */
+	movq	%r13, %r11
+	shrq	$(30-3), %r11
+	leaq    (pgtable_bsp - bsp_base + 0x1000)(%rsi), %rdi
+	addq	%r11, %rdi
+	leaq	(pgtable_extra_bsp - bsp_base + 0x7)(%rsi), %rax
+	movq	%rax, 0(%rdi)
+
+	/* Populate the page directory */
+	leaq    (pgtable_extra_bsp - bsp_base)(%rsi), %rdi
+	movq    $0x00000183, %rax
+	addq	%r13, %rax
+	movq    $512, %rcx
+1:      movq    %rax, 0(%rdi)
+	addq    $0x00200000, %rax
+	addq    $8, %rdi
+	decq    %rcx
+	jnz     1b
+
+	/* Set esi to point to the boot_params structure */
+2:	movq	%r15, %rsi
+	jmp	*%r14
+
+	.align 8
+	ENTRY(boot_params_phys_addr)
+	.quad  0
+
+	.align 8
+	ENTRY(kernel_phys_addr)
+	.quad  0
+
+	.code16
+	.balign 4
+	# Careful these need to be in the same 64K segment as the above;
+tidt_bsp:
+	.word	0			# idt limit = 0
+	.word	0, 0			# idt base = 0L
+
+	# Duplicate the global descriptor table
+	# so the kernel can live anywhere
+	.balign 4
+tgdt_bsp:
+	.short	tgdt_bsp_end - tgdt_bsp		# gdt limit
+	.long	tgdt_bsp - bsp_base
+	.short 0
+	.quad	0x00cf9b000000ffff	# __KERNEL32_CS
+	.quad	0x00af9b000000ffff	# __KERNEL_CS
+	.quad	0x00cf93000000ffff	# __KERNEL_DS
+tgdt_bsp_end:
+
+	.code64
+	.balign 4
+gdt_bsp_64:
+        .word   gdt_bsp_64_end - gdt_bsp_64
+        .long   gdt_bsp_64 - bsp_base
+        .word   0
+        .quad   0x0000000000000000      /* NULL descriptor */
+        .quad   0x00af9a000000ffff      /* __KERNEL_CS */
+        .quad   0x00cf92000000ffff      /* __KERNEL_DS */
+        .quad   0x0080890000000000      /* TS descriptor */
+        .quad   0x0000000000000000      /* TS continued */
+gdt_bsp_64_end:
+
+	.code16
+	.balign 4
+startup_32_vector_bsp:
+	.long	startup_32_bsp - bsp_base
+	.word	__KERNEL32_CS, 0
+
+	.balign 4
+startup_64_vector_bsp:
+	.long	startup_64_bsp - bsp_base
+	.word	__KERNEL_CS, 0
+
+	.balign 4
+ENTRY(trampoline_status_bsp)
+	.long	0
+
+	.balign 4
+ENTRY(trampoline_location)
+	.quad   0
+
+trampoline_stack_bsp:
+	.fill 512,8,0
+trampoline_stack_bsp_end:
+
+ENTRY(trampoline_bsp_end)
+
+/*
+ * Space for page tables (not in .bss so not zeroed)
+ */
+        .balign 4096
+pgtable_bsp:
+        .fill 6*4096, 1, 0
+pgtable_extra_bsp:
+	.fill 1*4096, 1, 0
+
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index 31d9d0f..d4b038f 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -729,7 +729,7 @@ void __init trap_init(void)
 	/*
 	 * Should be a barrier for any external CPU state:
 	 */
-	cpu_init();
+	cpu_init(1);
 
 	x86_init.irqs.trap_init();
 }
diff --git a/arch/x86/kernel/vmlinux.lds.S b/arch/x86/kernel/vmlinux.lds.S
index 0f703f1..abb97d1 100644
--- a/arch/x86/kernel/vmlinux.lds.S
+++ b/arch/x86/kernel/vmlinux.lds.S
@@ -209,6 +209,14 @@ SECTIONS
 		x86_trampoline_end = .;
 	}
 
+#ifdef CONFIG_POPCORN
+	 .x86_trampoline_bsp : AT(ADDR(.x86_trampoline_bsp) - LOAD_OFFSET) {
+		x86_trampoline_bsp_start = .;
+		*(.x86_trampoline_bsp)
+		x86_trampoline_bsp_end = .;
+	}
+#endif
+
 	.x86_cpu_dev.init : AT(ADDR(.x86_cpu_dev.init) - LOAD_OFFSET) {
 		__x86_cpu_dev_start = .;
 		*(.x86_cpu_dev.init)
diff --git a/arch/x86/mm/dump_pagetables.c b/arch/x86/mm/dump_pagetables.c
index 0002a3a..74b4231 100644
--- a/arch/x86/mm/dump_pagetables.c
+++ b/arch/x86/mm/dump_pagetables.c
@@ -29,6 +29,8 @@ struct pg_state {
 	pgprot_t current_prot;
 	unsigned long start_address;
 	unsigned long current_address;
+	unsigned long start_physical;
+	unsigned long current_physical;
 	const struct addr_marker *marker;
 };
 
@@ -139,7 +141,7 @@ static void printk_prot(struct seq_file *m, pgprot_t prot, int level)
 		else
 			seq_printf(m, "x  ");
 	}
-	seq_printf(m, "%s\n", level_name[level]);
+	seq_printf(m, "%s ", level_name[level]);
 }
 
 /*
@@ -200,6 +202,10 @@ static void note_page(struct seq_file *m, struct pg_state *st,
 		seq_printf(m, "%9lu%c ", delta, *unit);
 		printk_prot(m, st->current_prot, st->level);
 
+		seq_printf(m, "0x%0*lx-0x%0*lx\n",
+			   width, st->start_physical,
+			   width, st->current_physical);
+
 		/*
 		 * We print markers for special areas of address space,
 		 * such as the start of vmalloc space etc.
@@ -210,6 +216,7 @@ static void note_page(struct seq_file *m, struct pg_state *st,
 			seq_printf(m, "---[ %s ]---\n", st->marker->name);
 		}
 
+		st->start_physical = st->current_physical;
 		st->start_address = st->current_address;
 		st->current_prot = new_prot;
 		st->level = level;
@@ -310,6 +317,7 @@ static void walk_pgd_level(struct seq_file *m)
 
 	for (i = 0; i < PTRS_PER_PGD; i++) {
 		st.current_address = normalize_addr(i * PGD_LEVEL_MULT);
+		st.current_physical = (pgd_val(*start) & (0xFFFFFFFF << PAGE_SHIFT));
 		if (!pgd_none(*start)) {
 			pgprotval_t prot = pgd_val(*start) & PTE_FLAGS_MASK;
 
@@ -326,12 +334,13 @@ static void walk_pgd_level(struct seq_file *m)
 
 	/* Flush out the last page */
 	st.current_address = normalize_addr(PTRS_PER_PGD*PGD_LEVEL_MULT);
+	st.current_physical = (pgd_val(*start) & (0xFFFFFFFF << PAGE_SHIFT));
 	note_page(m, &st, __pgprot(0), 0);
 }
 
 static int ptdump_show(struct seq_file *m, void *v)
 {
-	walk_pgd_level(m);
+	walk_pgd_level(m); //main call
 	return 0;
 }
 
diff --git a/ben_config b/ben_config
new file mode 100644
index 0000000..01b7d90
--- /dev/null
+++ b/ben_config
@@ -0,0 +1,4073 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86_64 3.2.14 Kernel Configuration
+#
+CONFIG_64BIT=y
+# CONFIG_X86_32 is not set
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ZONE_DMA32=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_X86_64_SMP=y
+CONFIG_X86_HT=y
+CONFIG_HAVE_POPCORN_ARCH_SUPPORT=y
+CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11"
+# CONFIG_KTIME_SCALAR is not set
+CONFIG_ARCH_CPU_PROBE_RELEASE=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION="davek"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+# CONFIG_FHANDLE is not set
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=64
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP_ENABLED=y
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_MM_OWNER=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+CONFIG_PERF_COUNTERS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_OPROFILE=m
+# CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+# CONFIG_JUMP_LABEL is not set
+CONFIG_OPTPROBES=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_SMP=y
+CONFIG_X86_MPPARSE=y
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_VSMP is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_PARAVIRT_GUEST is not set
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MEMTEST is not set
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=7
+CONFIG_X86_CMPXCHG=y
+CONFIG_CMPXCHG_LOCAL=y
+CONFIG_CMPXCHG_DOUBLE=y
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_XADD=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=64
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+CONFIG_X86_MCE_INJECT=m
+CONFIG_X86_THERMAL_VECTOR=y
+CONFIG_I8K=m
+CONFIG_MICROCODE=m
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_X86_MSR=m
+CONFIG_X86_CPUID=m
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+# CONFIG_NUMA_EMU is not set
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+CONFIG_X86_CHECK_BIOS_CORRUPTION=y
+CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_EFI=y
+CONFIG_SECCOMP=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_KEXEC_JUMP=y
+CONFIG_PHYSICAL_START=0x200000
+CONFIG_RELOCATABLE=y
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_ARCH_HIBERNATION_HEADER=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_TRACE=y
+CONFIG_PM_TRACE_RTC=y
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_VIDEO=m
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_PROCESSOR=y
+# CONFIG_ACPI_IPMI is not set
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+CONFIG_ACPI_THERMAL=y
+CONFIG_ACPI_NUMA=y
+CONFIG_ACPI_CUSTOM_DSDT_FILE=""
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_SBS=y
+# CONFIG_ACPI_HED is not set
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+# CONFIG_ACPI_APEI is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# x86 CPU frequency scaling drivers
+#
+# CONFIG_X86_PCC_CPUFREQ is not set
+CONFIG_X86_ACPI_CPUFREQ=y
+CONFIG_X86_POWERNOW_K8=y
+CONFIG_X86_SPEEDSTEP_CENTRINO=y
+CONFIG_X86_P4_CLOCKMOD=m
+
+#
+# shared options
+#
+CONFIG_X86_SPEEDSTEP_LIB=m
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_INTEL_IDLE is not set
+
+#
+# Memory power savings
+#
+CONFIG_I7300_IDLE_IOAT_CHANNEL=y
+CONFIG_I7300_IDLE=m
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIE_PME=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_STUB=m
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+CONFIG_PCI_IOAPIC=y
+CONFIG_PCI_LABEL=y
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_FAKE=m
+CONFIG_HOTPLUG_PCI_ACPI=m
+CONFIG_HOTPLUG_PCI_ACPI_IBM=m
+CONFIG_HOTPLUG_PCI_CPCI=y
+CONFIG_HOTPLUG_PCI_CPCI_ZT5550=m
+CONFIG_HOTPLUG_PCI_CPCI_GENERIC=m
+CONFIG_HOTPLUG_PCI_SHPC=m
+# CONFIG_RAPIDIO is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_IA32_EMULATION=y
+# CONFIG_IA32_AOUT is not set
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_KEYS_COMPAT=y
+CONFIG_HAVE_TEXT_POKE_SMP=y
+CONFIG_NET=y
+CONFIG_COMPAT_NETLINK_MESSAGES=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_ROUTE_CLASSID=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=m
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_TCP_CONG_HTCP=m
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_TCP_CONG_VEGAS=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_TCP_CONG_VENO=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_TCP_CONG_ILLINOIS=m
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+# CONFIG_IPV6_MIP6 is not set
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_NETLABEL=y
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=m
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CT_PROTO_UDPLITE=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_BROADCAST=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_TPROXY=m
+CONFIG_NETFILTER_XTABLES=m
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_CONNMARK=m
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HL=m
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+# CONFIG_NETFILTER_XT_MATCH_IPVS is not set
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=m
+CONFIG_IP_VS_IPV6=y
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_AH_ESP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=m
+CONFIG_IP_VS_NFCT=y
+# CONFIG_IP_VS_PE_SIP is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_NF_NAT_PROTO_DCCP=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_PROTO_UDPLITE=m
+CONFIG_NF_NAT_PROTO_SCTP=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_SECURITY=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_IP6_NF_SECURITY=m
+
+#
+# DECnet: Netfilter Configuration
+#
+CONFIG_DECNET_NF_GRABULATOR=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+CONFIG_IP_DCCP=m
+CONFIG_INET_DCCP_DIAG=m
+
+#
+# DCCP CCIDs Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP_CCID2_DEBUG is not set
+CONFIG_IP_DCCP_CCID3=y
+# CONFIG_IP_DCCP_CCID3_DEBUG is not set
+CONFIG_IP_DCCP_TFRC_LIB=y
+
+#
+# DCCP Kernel Hacking
+#
+# CONFIG_IP_DCCP_DEBUG is not set
+CONFIG_NET_DCCPPROBE=m
+CONFIG_IP_SCTP=m
+# CONFIG_NET_SCTPPROBE is not set
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+CONFIG_RDS=m
+CONFIG_RDS_TCP=m
+# CONFIG_RDS_DEBUG is not set
+CONFIG_TIPC=m
+# CONFIG_TIPC_ADVANCED is not set
+# CONFIG_TIPC_DEBUG is not set
+CONFIG_ATM=m
+CONFIG_ATM_CLIP=m
+# CONFIG_ATM_CLIP_NO_ICMP is not set
+CONFIG_ATM_LANE=m
+CONFIG_ATM_MPOA=m
+CONFIG_ATM_BR2684=m
+# CONFIG_ATM_BR2684_IPFILTER is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_GARP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_NET_DSA=y
+CONFIG_NET_DSA_TAG_DSA=y
+CONFIG_NET_DSA_TAG_EDSA=y
+CONFIG_NET_DSA_TAG_TRAILER=y
+CONFIG_NET_DSA_MV88E6XXX=y
+CONFIG_NET_DSA_MV88E6060=y
+CONFIG_NET_DSA_MV88E6XXX_NEED_PPU=y
+CONFIG_NET_DSA_MV88E6131=y
+CONFIG_NET_DSA_MV88E6123_61_65=y
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_DECNET=m
+# CONFIG_DECNET_ROUTER is not set
+CONFIG_LLC=y
+CONFIG_LLC2=m
+CONFIG_IPX=m
+# CONFIG_IPX_INTERN is not set
+CONFIG_ATALK=m
+CONFIG_DEV_APPLETALK=m
+CONFIG_IPDDP=m
+CONFIG_IPDDP_ENCAP=y
+CONFIG_IPDDP_DECAP=y
+CONFIG_X25=m
+CONFIG_LAPB=m
+CONFIG_ECONET=m
+CONFIG_ECONET_AUNUDP=y
+CONFIG_ECONET_NATIVE=y
+CONFIG_WAN_ROUTER=m
+CONFIG_PHONET=m
+CONFIG_IEEE802154=m
+# CONFIG_IEEE802154_6LOWPAN is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_ATM=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_RED=m
+# CONFIG_NET_SCH_SFB is not set
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_DRR=m
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+CONFIG_NET_SCH_INGRESS=m
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_CLS_FLOW=m
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_NET_EMATCH_TEXT=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_NAT=m
+CONFIG_NET_ACT_PEDIT=m
+CONFIG_NET_ACT_SIMP=m
+CONFIG_NET_ACT_SKBEDIT=m
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_HAVE_BPF_JIT=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+CONFIG_NET_TCPPROBE=m
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_AF_RXRPC=m
+# CONFIG_AF_RXRPC_DEBUG is not set
+CONFIG_RXKAD=m
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_EXT_SYSFS is not set
+CONFIG_LIB80211=m
+CONFIG_LIB80211_CRYPT_WEP=m
+CONFIG_LIB80211_CRYPT_CCMP=m
+CONFIG_LIB80211_CRYPT_TKIP=m
+# CONFIG_LIB80211_DEBUG is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_LEDS=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_RFKILL_REGULATOR is not set
+CONFIG_NET_9P=m
+CONFIG_NET_9P_VIRTIO=m
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=m
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=m
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_REDBOOT_PARTS=m
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+CONFIG_MTD_AR7_PARTS=m
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=m
+CONFIG_HAVE_MTD_OTP=y
+CONFIG_MTD_BLKDEVS=m
+CONFIG_MTD_BLOCK=m
+CONFIG_MTD_BLOCK_RO=m
+CONFIG_FTL=m
+CONFIG_NFTL=m
+CONFIG_NFTL_RW=y
+CONFIG_INFTL=m
+CONFIG_RFD_FTL=m
+CONFIG_SSFDC=m
+# CONFIG_SM_FTL is not set
+CONFIG_MTD_OOPS=m
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=m
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_GEN_PROBE=m
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=m
+CONFIG_MTD_CFI_AMDSTD=m
+CONFIG_MTD_CFI_STAA=m
+CONFIG_MTD_CFI_UTIL=m
+CONFIG_MTD_RAM=m
+CONFIG_MTD_ROM=m
+CONFIG_MTD_ABSENT=m
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+CONFIG_MTD_PHYSMAP=m
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+CONFIG_MTD_SC520CDP=m
+CONFIG_MTD_NETSC520=m
+CONFIG_MTD_TS5500=m
+CONFIG_MTD_SBC_GXX=m
+CONFIG_MTD_AMD76XROM=m
+CONFIG_MTD_ICHXROM=m
+CONFIG_MTD_ESB2ROM=m
+CONFIG_MTD_CK804XROM=m
+CONFIG_MTD_SCB2_FLASH=m
+CONFIG_MTD_NETtel=m
+CONFIG_MTD_L440GX=m
+CONFIG_MTD_PCI=m
+CONFIG_MTD_GPIO_ADDR=m
+CONFIG_MTD_INTEL_VR_NOR=m
+CONFIG_MTD_PLATRAM=m
+# CONFIG_MTD_LATCH_ADDR is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_PMC551=m
+# CONFIG_MTD_PMC551_BUGFIX is not set
+# CONFIG_MTD_PMC551_DEBUG is not set
+CONFIG_MTD_DATAFLASH=m
+# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
+CONFIG_MTD_DATAFLASH_OTP=y
+CONFIG_MTD_M25P80=m
+CONFIG_M25PXX_USE_FAST_READ=y
+CONFIG_MTD_SST25L=m
+CONFIG_MTD_SLRAM=m
+CONFIG_MTD_PHRAM=m
+CONFIG_MTD_MTDRAM=m
+CONFIG_MTDRAM_TOTAL_SIZE=4096
+CONFIG_MTDRAM_ERASE_SIZE=128
+CONFIG_MTD_BLOCK2MTD=m
+
+#
+# Disk-On-Chip Device Drivers
+#
+CONFIG_MTD_DOC2000=m
+CONFIG_MTD_DOC2001=m
+CONFIG_MTD_DOC2001PLUS=m
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_DOCPROBE=m
+CONFIG_MTD_DOCECC=m
+# CONFIG_MTD_DOCPROBE_ADVANCED is not set
+CONFIG_MTD_DOCPROBE_ADDRESS=0x0
+CONFIG_MTD_NAND_ECC=m
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=m
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_DENALI is not set
+CONFIG_MTD_NAND_IDS=m
+# CONFIG_MTD_NAND_RICOH is not set
+CONFIG_MTD_NAND_DISKONCHIP=m
+# CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADVANCED is not set
+CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS=0
+# CONFIG_MTD_NAND_DISKONCHIP_BBTWRITE is not set
+CONFIG_MTD_NAND_CAFE=m
+CONFIG_MTD_NAND_NANDSIM=m
+CONFIG_MTD_NAND_PLATFORM=m
+CONFIG_MTD_ALAUDA=m
+CONFIG_MTD_ONENAND=m
+CONFIG_MTD_ONENAND_VERIFY_WRITE=y
+CONFIG_MTD_ONENAND_GENERIC=m
+# CONFIG_MTD_ONENAND_OTP is not set
+CONFIG_MTD_ONENAND_2X_PROGRAM=y
+CONFIG_MTD_ONENAND_SIM=m
+
+#
+# LPDDR flash memory drivers
+#
+CONFIG_MTD_LPDDR=m
+CONFIG_MTD_QINFO_PROBE=m
+CONFIG_MTD_UBI=m
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+CONFIG_MTD_UBI_GLUEBI=m
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+CONFIG_PNP_DEBUG_MESSAGES=y
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+CONFIG_BLK_DEV_FD=m
+CONFIG_BLK_CPQ_DA=m
+CONFIG_BLK_CPQ_CISS_DA=m
+CONFIG_CISS_SCSI_TAPE=y
+CONFIG_BLK_DEV_DAC960=m
+CONFIG_BLK_DEV_UMEM=m
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_OSD=m
+CONFIG_BLK_DEV_SX8=m
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_BLK_DEV_XIP is not set
+CONFIG_CDROM_PKTCDVD=y
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+CONFIG_ATA_OVER_ETH=m
+CONFIG_VIRTIO_BLK=m
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+CONFIG_IBM_ASM=m
+CONFIG_PHANTOM=m
+# CONFIG_INTEL_MID_PTI is not set
+CONFIG_SGI_IOC4=m
+CONFIG_TIFM_CORE=m
+CONFIG_TIFM_7XX1=m
+CONFIG_ICS932S401=m
+CONFIG_ENCLOSURE_SERVICES=m
+CONFIG_HP_ILO=m
+# CONFIG_APDS9802ALS is not set
+CONFIG_ISL29003=m
+# CONFIG_ISL29020 is not set
+CONFIG_SENSORS_TSL2550=m
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+CONFIG_DS1682=m
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_VMWARE_BALLOON is not set
+# CONFIG_BMP085 is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+CONFIG_C2PORT=m
+CONFIG_C2PORT_DURAMAR_2150=m
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=m
+CONFIG_EEPROM_AT25=m
+CONFIG_EEPROM_LEGACY=m
+CONFIG_EEPROM_MAX6875=m
+CONFIG_EEPROM_93CX6=m
+# CONFIG_EEPROM_93XX46 is not set
+CONFIG_CB710_CORE=m
+# CONFIG_CB710_DEBUG is not set
+CONFIG_CB710_DEBUG_ASSUMPTIONS=y
+CONFIG_IWMC3200TOP=m
+# CONFIG_IWMC3200TOP_DEBUG is not set
+# CONFIG_IWMC3200TOP_DEBUGFS is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=m
+CONFIG_SCSI_NETLINK=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=m
+CONFIG_SCSI_ENCLOSURE=m
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_FC_TGT_ATTRS=y
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+CONFIG_SCSI_SAS_LIBSAS=m
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_SAS_HOST_SMP=y
+CONFIG_SCSI_SRP_ATTRS=m
+CONFIG_SCSI_SRP_TGT_ATTRS=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_ISCSI_TCP=m
+CONFIG_ISCSI_BOOT_SYSFS=m
+CONFIG_SCSI_CXGB3_ISCSI=m
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+CONFIG_SCSI_BNX2_ISCSI=m
+# CONFIG_SCSI_BNX2X_FCOE is not set
+CONFIG_BE2ISCSI=m
+CONFIG_BLK_DEV_3W_XXXX_RAID=m
+# CONFIG_SCSI_HPSA is not set
+CONFIG_SCSI_3W_9XXX=m
+# CONFIG_SCSI_3W_SAS is not set
+CONFIG_SCSI_ACARD=m
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=8
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+CONFIG_AIC7XXX_DEBUG_ENABLE=y
+CONFIG_AIC7XXX_DEBUG_MASK=0
+CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+CONFIG_SCSI_AIC79XX=m
+CONFIG_AIC79XX_CMDS_PER_DEVICE=32
+CONFIG_AIC79XX_RESET_DELAY_MS=5000
+CONFIG_AIC79XX_DEBUG_ENABLE=y
+CONFIG_AIC79XX_DEBUG_MASK=0
+CONFIG_AIC79XX_REG_PRETTY_PRINT=y
+CONFIG_SCSI_AIC94XX=m
+# CONFIG_AIC94XX_DEBUG is not set
+CONFIG_SCSI_MVSAS=m
+CONFIG_SCSI_MVSAS_DEBUG=y
+# CONFIG_SCSI_MVSAS_TASKLET is not set
+# CONFIG_SCSI_MVUMI is not set
+CONFIG_SCSI_DPT_I2O=m
+CONFIG_SCSI_ADVANSYS=m
+CONFIG_SCSI_ARCMSR=m
+CONFIG_MEGARAID_NEWGEN=y
+CONFIG_MEGARAID_MM=m
+CONFIG_MEGARAID_MAILBOX=m
+CONFIG_MEGARAID_LEGACY=m
+CONFIG_MEGARAID_SAS=m
+CONFIG_SCSI_MPT2SAS=m
+CONFIG_SCSI_MPT2SAS_MAX_SGE=128
+# CONFIG_SCSI_MPT2SAS_LOGGING is not set
+CONFIG_SCSI_HPTIOP=m
+CONFIG_SCSI_BUSLOGIC=m
+CONFIG_VMWARE_PVSCSI=m
+CONFIG_LIBFC=m
+CONFIG_LIBFCOE=m
+CONFIG_FCOE=m
+CONFIG_FCOE_FNIC=m
+CONFIG_SCSI_DMX3191D=m
+CONFIG_SCSI_EATA=m
+CONFIG_SCSI_EATA_TAGGED_QUEUE=y
+CONFIG_SCSI_EATA_LINKED_COMMANDS=y
+CONFIG_SCSI_EATA_MAX_TAGS=16
+CONFIG_SCSI_FUTURE_DOMAIN=m
+CONFIG_SCSI_GDTH=m
+# CONFIG_SCSI_ISCI is not set
+CONFIG_SCSI_IPS=m
+CONFIG_SCSI_INITIO=m
+CONFIG_SCSI_INIA100=m
+CONFIG_SCSI_STEX=m
+CONFIG_SCSI_SYM53C8XX_2=m
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+CONFIG_SCSI_SYM53C8XX_MMIO=y
+CONFIG_SCSI_IPR=m
+# CONFIG_SCSI_IPR_TRACE is not set
+# CONFIG_SCSI_IPR_DUMP is not set
+CONFIG_SCSI_QLOGIC_1280=m
+CONFIG_SCSI_QLA_FC=m
+CONFIG_SCSI_QLA_ISCSI=m
+CONFIG_SCSI_LPFC=m
+CONFIG_SCSI_LPFC_DEBUG_FS=y
+CONFIG_SCSI_DC395x=m
+CONFIG_SCSI_DC390T=m
+CONFIG_SCSI_DEBUG=m
+CONFIG_SCSI_PMCRAID=m
+# CONFIG_SCSI_PM8001 is not set
+CONFIG_SCSI_SRP=m
+CONFIG_SCSI_BFA_FC=m
+CONFIG_SCSI_DH=y
+CONFIG_SCSI_DH_RDAC=m
+CONFIG_SCSI_DH_HP_SW=m
+CONFIG_SCSI_DH_EMC=m
+CONFIG_SCSI_DH_ALUA=m
+CONFIG_SCSI_OSD_INITIATOR=m
+CONFIG_SCSI_OSD_ULD=m
+CONFIG_SCSI_OSD_DPRINT_SENSE=1
+# CONFIG_SCSI_OSD_DEBUG is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+CONFIG_SATA_INIC162X=m
+# CONFIG_SATA_ACARD_AHCI is not set
+CONFIG_SATA_SIL24=m
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+CONFIG_PDC_ADMA=y
+CONFIG_SATA_QSTOR=m
+CONFIG_SATA_SX4=m
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+CONFIG_ATA_PIIX=y
+CONFIG_SATA_MV=m
+CONFIG_SATA_NV=m
+CONFIG_SATA_PROMISE=m
+CONFIG_SATA_SIL=m
+CONFIG_SATA_SIS=m
+CONFIG_SATA_SVW=m
+CONFIG_SATA_ULI=m
+CONFIG_SATA_VIA=m
+CONFIG_SATA_VITESSE=m
+
+#
+# PATA SFF controllers with BMDMA
+#
+CONFIG_PATA_ALI=m
+CONFIG_PATA_AMD=m
+# CONFIG_PATA_ARASAN_CF is not set
+CONFIG_PATA_ARTOP=m
+CONFIG_PATA_ATIIXP=m
+CONFIG_PATA_ATP867X=m
+CONFIG_PATA_CMD64X=m
+CONFIG_PATA_CS5520=m
+CONFIG_PATA_CS5530=m
+# CONFIG_PATA_CS5536 is not set
+CONFIG_PATA_CYPRESS=m
+CONFIG_PATA_EFAR=m
+CONFIG_PATA_HPT366=m
+CONFIG_PATA_HPT37X=m
+CONFIG_PATA_HPT3X2N=m
+CONFIG_PATA_HPT3X3=m
+# CONFIG_PATA_HPT3X3_DMA is not set
+CONFIG_PATA_IT8213=m
+CONFIG_PATA_IT821X=m
+CONFIG_PATA_JMICRON=m
+CONFIG_PATA_MARVELL=m
+CONFIG_PATA_NETCELL=m
+CONFIG_PATA_NINJA32=m
+CONFIG_PATA_NS87415=m
+CONFIG_PATA_OLDPIIX=m
+CONFIG_PATA_OPTIDMA=m
+CONFIG_PATA_PDC2027X=m
+CONFIG_PATA_PDC_OLD=m
+CONFIG_PATA_RADISYS=m
+CONFIG_PATA_RDC=m
+CONFIG_PATA_SC1200=m
+CONFIG_PATA_SCH=m
+CONFIG_PATA_SERVERWORKS=m
+CONFIG_PATA_SIL680=m
+CONFIG_PATA_SIS=y
+# CONFIG_PATA_TOSHIBA is not set
+CONFIG_PATA_TRIFLEX=m
+CONFIG_PATA_VIA=m
+CONFIG_PATA_WINBOND=m
+
+#
+# PIO-only SFF controllers
+#
+CONFIG_PATA_CMD640_PCI=m
+CONFIG_PATA_MPIIX=m
+CONFIG_PATA_NS87410=m
+CONFIG_PATA_OPTI=m
+CONFIG_PATA_RZ1000=m
+
+#
+# Generic fallback / legacy drivers
+#
+CONFIG_PATA_ACPI=y
+CONFIG_ATA_GENERIC=y
+# CONFIG_PATA_LEGACY is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_AUTODETECT=y
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID456=m
+# CONFIG_MULTICORE_RAID456 is not set
+CONFIG_MD_MULTIPATH=m
+CONFIG_MD_FAULTY=m
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=y
+# CONFIG_DM_THIN_PROVISIONING is not set
+CONFIG_DM_MIRROR=y
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=y
+CONFIG_DM_MULTIPATH_QL=m
+CONFIG_DM_MULTIPATH_ST=m
+# CONFIG_DM_DELAY is not set
+CONFIG_DM_UEVENT=y
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+CONFIG_FIREWIRE=m
+CONFIG_FIREWIRE_OHCI=m
+CONFIG_FIREWIRE_OHCI_DEBUG=y
+CONFIG_FIREWIRE_SBP2=m
+CONFIG_FIREWIRE_NET=m
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+CONFIG_MACINTOSH_DRIVERS=y
+CONFIG_MAC_EMUMOUSEBTN=y
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+CONFIG_BONDING=m
+CONFIG_DUMMY=m
+CONFIG_EQUALIZER=m
+CONFIG_NET_FC=y
+CONFIG_MII=m
+CONFIG_IEEE802154_DRIVERS=m
+# CONFIG_IEEE802154_FAKEHARD is not set
+CONFIG_IFB=m
+CONFIG_MACVLAN=m
+# CONFIG_MACVTAP is not set
+CONFIG_NETCONSOLE=m
+CONFIG_NETCONSOLE_DYNAMIC=y
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_TUN=y
+CONFIG_VETH=m
+CONFIG_VIRTIO_NET=m
+CONFIG_SUNGEM_PHY=m
+CONFIG_ARCNET=m
+CONFIG_ARCNET_1201=m
+CONFIG_ARCNET_1051=m
+CONFIG_ARCNET_RAW=m
+CONFIG_ARCNET_CAP=m
+CONFIG_ARCNET_COM90xx=m
+CONFIG_ARCNET_COM90xxIO=m
+CONFIG_ARCNET_RIM_I=m
+CONFIG_ARCNET_COM20020=m
+CONFIG_ARCNET_COM20020_PCI=m
+CONFIG_ATM_DRIVERS=y
+# CONFIG_ATM_DUMMY is not set
+CONFIG_ATM_TCP=m
+CONFIG_ATM_LANAI=m
+CONFIG_ATM_ENI=m
+# CONFIG_ATM_ENI_DEBUG is not set
+# CONFIG_ATM_ENI_TUNE_BURST is not set
+CONFIG_ATM_FIRESTREAM=m
+CONFIG_ATM_ZATM=m
+# CONFIG_ATM_ZATM_DEBUG is not set
+# CONFIG_ATM_NICSTAR is not set
+CONFIG_ATM_IDT77252=m
+# CONFIG_ATM_IDT77252_DEBUG is not set
+# CONFIG_ATM_IDT77252_RCV_ALL is not set
+CONFIG_ATM_IDT77252_USE_SUNI=y
+CONFIG_ATM_AMBASSADOR=m
+# CONFIG_ATM_AMBASSADOR_DEBUG is not set
+CONFIG_ATM_HORIZON=m
+# CONFIG_ATM_HORIZON_DEBUG is not set
+CONFIG_ATM_IA=m
+# CONFIG_ATM_IA_DEBUG is not set
+CONFIG_ATM_FORE200E=m
+# CONFIG_ATM_FORE200E_USE_TASKLET is not set
+CONFIG_ATM_FORE200E_TX_RETRY=16
+CONFIG_ATM_FORE200E_DEBUG=0
+CONFIG_ATM_HE=m
+CONFIG_ATM_HE_USE_SUNI=y
+CONFIG_ATM_SOLOS=m
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_VORTEX=m
+CONFIG_TYPHOON=m
+CONFIG_NET_VENDOR_ADAPTEC=y
+CONFIG_ADAPTEC_STARFIRE=m
+CONFIG_NET_VENDOR_ALTEON=y
+CONFIG_ACENIC=m
+# CONFIG_ACENIC_OMIT_TIGON_I is not set
+CONFIG_NET_VENDOR_AMD=y
+CONFIG_AMD8111_ETH=m
+CONFIG_PCNET32=m
+CONFIG_NET_VENDOR_ATHEROS=y
+CONFIG_ATL2=m
+CONFIG_ATL1=m
+CONFIG_ATL1E=m
+CONFIG_ATL1C=m
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_B44=m
+CONFIG_B44_PCI_AUTOSELECT=y
+CONFIG_B44_PCICORE_AUTOSELECT=y
+CONFIG_B44_PCI=y
+CONFIG_BNX2=m
+CONFIG_CNIC=m
+CONFIG_TIGON3=m
+CONFIG_BNX2X=m
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_BNA is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+CONFIG_CHELSIO_T1=m
+CONFIG_CHELSIO_T1_1G=y
+CONFIG_CHELSIO_T3=m
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+CONFIG_NET_VENDOR_CISCO=y
+CONFIG_ENIC=m
+CONFIG_DNET=m
+CONFIG_NET_VENDOR_DEC=y
+CONFIG_NET_TULIP=y
+CONFIG_DE2104X=m
+CONFIG_DE2104X_DSL=0
+CONFIG_TULIP=m
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_TULIP_NAPI is not set
+CONFIG_DE4X5=m
+CONFIG_WINBOND_840=m
+CONFIG_DM9102=m
+CONFIG_ULI526X=m
+CONFIG_NET_VENDOR_DLINK=y
+# CONFIG_DL2K is not set
+CONFIG_SUNDANCE=m
+# CONFIG_SUNDANCE_MMIO is not set
+CONFIG_NET_VENDOR_EMULEX=y
+CONFIG_BE2NET=m
+CONFIG_NET_VENDOR_EXAR=y
+CONFIG_S2IO=m
+CONFIG_VXGE=m
+# CONFIG_VXGE_DEBUG_TRACE_ALL is not set
+CONFIG_NET_VENDOR_HP=y
+CONFIG_HP100=m
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_E100=m
+CONFIG_E1000=m
+CONFIG_E1000E=m
+CONFIG_IGB=m
+CONFIG_IGB_DCA=y
+CONFIG_IGBVF=m
+CONFIG_IXGB=m
+CONFIG_IXGBE=m
+CONFIG_IXGBE_DCA=y
+CONFIG_IXGBE_DCB=y
+# CONFIG_IXGBEVF is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_ZNET is not set
+CONFIG_IP1000=m
+CONFIG_JME=m
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_SKGE=m
+# CONFIG_SKGE_DEBUG is not set
+# CONFIG_SKGE_GENESIS is not set
+CONFIG_SKY2=m
+# CONFIG_SKY2_DEBUG is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_MLX4_EN=m
+CONFIG_MLX4_CORE=m
+CONFIG_MLX4_DEBUG=y
+CONFIG_NET_VENDOR_MICREL=y
+CONFIG_KS8842=m
+CONFIG_KS8851=m
+CONFIG_KS8851_MLL=m
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+CONFIG_NET_VENDOR_MYRI=y
+CONFIG_MYRI10GE=m
+CONFIG_MYRI10GE_DCA=y
+CONFIG_FEALNX=m
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NATSEMI=m
+CONFIG_NS83820=m
+CONFIG_NET_VENDOR_8390=y
+CONFIG_NE2K_PCI=m
+CONFIG_NET_VENDOR_NVIDIA=y
+CONFIG_FORCEDETH=m
+CONFIG_NET_VENDOR_OKI=y
+# CONFIG_PCH_GBE is not set
+CONFIG_ETHOC=m
+CONFIG_NET_PACKET_ENGINE=y
+CONFIG_HAMACHI=m
+CONFIG_YELLOWFIN=m
+CONFIG_NET_VENDOR_QLOGIC=y
+CONFIG_QLA3XXX=m
+# CONFIG_QLCNIC is not set
+CONFIG_QLGE=m
+CONFIG_NETXEN_NIC=m
+CONFIG_NET_VENDOR_REALTEK=y
+CONFIG_8139CP=m
+CONFIG_8139TOO=m
+CONFIG_8139TOO_PIO=y
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+CONFIG_8139TOO_8129=y
+# CONFIG_8139_OLD_RX_RESET is not set
+CONFIG_R8169=m
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_R6040 is not set
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_VENDOR_SILAN=y
+CONFIG_SC92031=m
+CONFIG_NET_VENDOR_SIS=y
+CONFIG_SIS900=m
+CONFIG_SIS190=m
+CONFIG_SFC=m
+CONFIG_SFC_MTD=y
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_EPIC100=m
+CONFIG_SMSC9420=m
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_SUN=y
+CONFIG_HAPPYMEAL=m
+CONFIG_SUNGEM=m
+CONFIG_CASSINI=m
+CONFIG_NIU=m
+CONFIG_NET_VENDOR_TEHUTI=y
+CONFIG_TEHUTI=m
+CONFIG_NET_VENDOR_TI=y
+CONFIG_TLAN=m
+CONFIG_NET_VENDOR_VIA=y
+CONFIG_VIA_RHINE=m
+CONFIG_VIA_RHINE_MMIO=y
+CONFIG_VIA_VELOCITY=m
+CONFIG_FDDI=y
+CONFIG_DEFXX=m
+# CONFIG_DEFXX_MMIO is not set
+CONFIG_SKFP=m
+CONFIG_HIPPI=y
+CONFIG_ROADRUNNER=m
+# CONFIG_ROADRUNNER_LARGE_RINGS is not set
+CONFIG_NET_SB1000=m
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_BROADCOM_PHY=y
+CONFIG_ICPLUS_PHY=y
+CONFIG_REALTEK_PHY=y
+CONFIG_NATIONAL_PHY=y
+CONFIG_STE10XP=y
+CONFIG_LSI_ET1011C_PHY=y
+# CONFIG_MICREL_PHY is not set
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_GPIO=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOATM=m
+CONFIG_PPPOE=m
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_SLIP=m
+CONFIG_SLHC=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+CONFIG_SLIP_MODE_SLIP6=y
+CONFIG_TR=y
+CONFIG_IBMOL=m
+CONFIG_3C359=m
+CONFIG_TMS380TR=m
+CONFIG_TMSPCI=m
+CONFIG_ABYSS=m
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_USB_NET_CDC_NCM=m
+CONFIG_USB_NET_DM9601=m
+# CONFIG_USB_NET_SMSC75XX is not set
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_USB_EPSON2888=y
+CONFIG_USB_KC2190=y
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+CONFIG_USB_HSO=m
+CONFIG_USB_NET_INT51X1=m
+CONFIG_USB_CDC_PHONET=m
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
+CONFIG_WLAN=y
+CONFIG_AIRO=m
+CONFIG_ATMEL=m
+CONFIG_PCI_ATMEL=m
+CONFIG_PRISM54=m
+CONFIG_USB_ZD1201=m
+CONFIG_HOSTAP=m
+CONFIG_HOSTAP_FIRMWARE=y
+CONFIG_HOSTAP_FIRMWARE_NVRAM=y
+CONFIG_HOSTAP_PLX=m
+CONFIG_HOSTAP_PCI=m
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+CONFIG_WAN=y
+CONFIG_LANMEDIA=m
+CONFIG_HDLC=m
+CONFIG_HDLC_RAW=m
+CONFIG_HDLC_RAW_ETH=m
+CONFIG_HDLC_CISCO=m
+CONFIG_HDLC_FR=m
+CONFIG_HDLC_PPP=m
+CONFIG_HDLC_X25=m
+CONFIG_PCI200SYN=m
+CONFIG_WANXL=m
+# CONFIG_PC300TOO is not set
+CONFIG_FARSYNC=m
+CONFIG_DSCC4=m
+CONFIG_DSCC4_PCISYNC=y
+CONFIG_DSCC4_PCI_RST=y
+CONFIG_DLCI=m
+CONFIG_DLCI_MAX=8
+CONFIG_WAN_ROUTER_DRIVERS=m
+CONFIG_CYCLADES_SYNC=m
+CONFIG_CYCLOMX_X25=y
+CONFIG_LAPBETHER=m
+CONFIG_X25_ASY=m
+CONFIG_SBNI=m
+# CONFIG_SBNI_MULTILINE is not set
+CONFIG_VMXNET3=m
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=m
+CONFIG_INPUT_POLLDEV=m
+CONFIG_INPUT_SPARSEKMAP=m
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ADP5588=m
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+CONFIG_KEYBOARD_LKKBD=m
+CONFIG_KEYBOARD_GPIO=m
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+CONFIG_KEYBOARD_MATRIX=m
+CONFIG_KEYBOARD_LM8323=m
+CONFIG_KEYBOARD_MAX7359=m
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+CONFIG_KEYBOARD_NEWTON=m
+CONFIG_KEYBOARD_OPENCORES=m
+CONFIG_KEYBOARD_STOWAWAY=m
+CONFIG_KEYBOARD_SUNKBD=m
+CONFIG_KEYBOARD_TWL4030=m
+CONFIG_KEYBOARD_XTKBD=m
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_MOUSE_PS2_SENTELIC=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_SERIAL=m
+CONFIG_MOUSE_APPLETOUCH=m
+CONFIG_MOUSE_BCM5974=m
+CONFIG_MOUSE_VSXXXAA=m
+CONFIG_MOUSE_GPIO=m
+CONFIG_MOUSE_SYNAPTICS_I2C=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_ANALOG=m
+CONFIG_JOYSTICK_A3D=m
+CONFIG_JOYSTICK_ADI=m
+CONFIG_JOYSTICK_COBRA=m
+CONFIG_JOYSTICK_GF2K=m
+CONFIG_JOYSTICK_GRIP=m
+CONFIG_JOYSTICK_GRIP_MP=m
+CONFIG_JOYSTICK_GUILLEMOT=m
+CONFIG_JOYSTICK_INTERACT=m
+CONFIG_JOYSTICK_SIDEWINDER=m
+CONFIG_JOYSTICK_TMDC=m
+CONFIG_JOYSTICK_IFORCE=m
+CONFIG_JOYSTICK_IFORCE_USB=y
+CONFIG_JOYSTICK_IFORCE_232=y
+CONFIG_JOYSTICK_WARRIOR=m
+CONFIG_JOYSTICK_MAGELLAN=m
+CONFIG_JOYSTICK_SPACEORB=m
+CONFIG_JOYSTICK_SPACEBALL=m
+CONFIG_JOYSTICK_STINGER=m
+CONFIG_JOYSTICK_TWIDJOY=m
+CONFIG_JOYSTICK_ZHENHUA=m
+# CONFIG_JOYSTICK_AS5011 is not set
+CONFIG_JOYSTICK_JOYDUMP=m
+CONFIG_JOYSTICK_XPAD=m
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=m
+CONFIG_TABLET_USB_AIPTEK=m
+CONFIG_TABLET_USB_GTCO=m
+# CONFIG_TABLET_USB_HANWANG is not set
+CONFIG_TABLET_USB_KBTAB=m
+CONFIG_TABLET_USB_WACOM=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=m
+CONFIG_TOUCHSCREEN_AD7877=m
+CONFIG_TOUCHSCREEN_AD7879=m
+CONFIG_TOUCHSCREEN_AD7879_I2C=m
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+CONFIG_TOUCHSCREEN_DA9034=m
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+CONFIG_TOUCHSCREEN_EETI=m
+CONFIG_TOUCHSCREEN_FUJITSU=m
+CONFIG_TOUCHSCREEN_GUNZE=m
+CONFIG_TOUCHSCREEN_ELO=m
+CONFIG_TOUCHSCREEN_WACOM_W8001=m
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+CONFIG_TOUCHSCREEN_MCS5000=m
+CONFIG_TOUCHSCREEN_MTOUCH=m
+CONFIG_TOUCHSCREEN_INEXIO=m
+CONFIG_TOUCHSCREEN_MK712=m
+CONFIG_TOUCHSCREEN_PENMOUNT=m
+CONFIG_TOUCHSCREEN_TOUCHRIGHT=m
+CONFIG_TOUCHSCREEN_TOUCHWIN=m
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=m
+CONFIG_TOUCHSCREEN_USB_EGALAX=y
+CONFIG_TOUCHSCREEN_USB_PANJIT=y
+CONFIG_TOUCHSCREEN_USB_3M=y
+CONFIG_TOUCHSCREEN_USB_ITM=y
+CONFIG_TOUCHSCREEN_USB_ETURBO=y
+CONFIG_TOUCHSCREEN_USB_GUNZE=y
+CONFIG_TOUCHSCREEN_USB_DMC_TSC10=y
+CONFIG_TOUCHSCREEN_USB_IRTOUCH=y
+CONFIG_TOUCHSCREEN_USB_IDEALTEK=y
+CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH=y
+CONFIG_TOUCHSCREEN_USB_GOTOP=y
+CONFIG_TOUCHSCREEN_USB_JASTEC=y
+CONFIG_TOUCHSCREEN_USB_E2I=y
+CONFIG_TOUCHSCREEN_USB_ZYTRONIC=y
+CONFIG_TOUCHSCREEN_USB_ETT_TC45USB=y
+CONFIG_TOUCHSCREEN_USB_NEXIO=y
+CONFIG_TOUCHSCREEN_TOUCHIT213=m
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+CONFIG_TOUCHSCREEN_TSC2007=m
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+CONFIG_INPUT_PCSPKR=m
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_APANEL is not set
+CONFIG_INPUT_ATLAS_BTNS=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+# CONFIG_INPUT_KXTJ9 is not set
+CONFIG_INPUT_POWERMATE=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_CM109=m
+CONFIG_INPUT_TWL4030_PWRBUTTON=m
+# CONFIG_INPUT_TWL4030_VIBRA is not set
+# CONFIG_INPUT_TWL6040_VIBRA is not set
+CONFIG_INPUT_UINPUT=m
+CONFIG_INPUT_PCF50633_PMU=m
+# CONFIG_INPUT_PCF8574 is not set
+CONFIG_INPUT_GPIO_ROTARY_ENCODER=m
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=m
+CONFIG_SERIO_CT82C710=m
+CONFIG_SERIO_PCIPS2=m
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+CONFIG_GAMEPORT=m
+CONFIG_GAMEPORT_NS558=m
+CONFIG_GAMEPORT_L4=m
+CONFIG_GAMEPORT_EMU10K1=m
+CONFIG_GAMEPORT_FM801=m
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_VTY=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=0
+CONFIG_SERIAL_NONSTANDARD=y
+CONFIG_ROCKETPORT=m
+CONFIG_CYCLADES=m
+# CONFIG_CYZ_INTR is not set
+CONFIG_MOXA_INTELLIO=m
+CONFIG_MOXA_SMARTIO=m
+CONFIG_SYNCLINK=m
+CONFIG_SYNCLINKMP=m
+CONFIG_SYNCLINK_GT=m
+CONFIG_NOZOMI=m
+# CONFIG_ISI is not set
+CONFIG_N_HDLC=m
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_STALDRV=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_NR_UARTS=48
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MAX3100=m
+# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_CONSOLE_POLL=y
+CONFIG_SERIAL_JSM=m
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+CONFIG_HVC_DRIVER=y
+CONFIG_VIRTIO_CONSOLE=m
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_TIMERIOMEM=m
+CONFIG_HW_RANDOM_INTEL=m
+CONFIG_HW_RANDOM_AMD=m
+CONFIG_HW_RANDOM_VIA=m
+CONFIG_HW_RANDOM_VIRTIO=m
+CONFIG_NVRAM=m
+CONFIG_R3964=m
+CONFIG_APPLICOM=m
+CONFIG_MWAVE=m
+CONFIG_RAW_DRIVER=m
+CONFIG_MAX_RAW_DEVS=256
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HANGCHECK_TIMER=m
+CONFIG_TCG_TPM=m
+CONFIG_TCG_TIS=m
+CONFIG_TCG_NSC=m
+CONFIG_TCG_ATMEL=m
+CONFIG_TCG_INFINEON=m
+CONFIG_TELCLOCK=m
+CONFIG_DEVPORT=y
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=m
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_SMBUS=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+CONFIG_I2C_ALI1535=m
+CONFIG_I2C_ALI1563=m
+CONFIG_I2C_ALI15X3=m
+CONFIG_I2C_AMD756=m
+CONFIG_I2C_AMD756_S4882=m
+CONFIG_I2C_AMD8111=m
+CONFIG_I2C_I801=m
+CONFIG_I2C_ISCH=m
+CONFIG_I2C_PIIX4=m
+CONFIG_I2C_NFORCE2=m
+CONFIG_I2C_NFORCE2_S4985=m
+CONFIG_I2C_SIS5595=m
+CONFIG_I2C_SIS630=m
+CONFIG_I2C_SIS96X=m
+CONFIG_I2C_VIA=m
+CONFIG_I2C_VIAPRO=m
+
+#
+# ACPI drivers
+#
+CONFIG_I2C_SCMI=m
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+CONFIG_I2C_GPIO=m
+# CONFIG_I2C_INTEL_MID is not set
+CONFIG_I2C_OCORES=m
+CONFIG_I2C_PCA_PLATFORM=m
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_I2C_SIMTEC=m
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I2C_EG20T is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+CONFIG_I2C_PARPORT_LIGHT=m
+CONFIG_I2C_TAOS_EVM=m
+CONFIG_I2C_TINY_USB=m
+
+#
+# Other I2C/SMBus bus drivers
+#
+CONFIG_I2C_STUB=m
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=m
+CONFIG_SPI_GPIO=m
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPI_TLE62X0=m
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_MAX730X=m
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_SCH is not set
+# CONFIG_GPIO_VX855 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+CONFIG_GPIO_MAX732X=m
+CONFIG_GPIO_PCA953X=m
+CONFIG_GPIO_PCF857X=m
+# CONFIG_GPIO_SX150X is not set
+CONFIG_GPIO_TWL4030=m
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+CONFIG_GPIO_LANGWELL=y
+# CONFIG_GPIO_PCH is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+
+#
+# SPI GPIO expanders:
+#
+CONFIG_GPIO_MAX7301=m
+CONFIG_GPIO_MCP23S08=m
+CONFIG_GPIO_MC33880=m
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+CONFIG_PDA_POWER=m
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+CONFIG_BATTERY_DS2782=m
+# CONFIG_BATTERY_BQ20Z75 is not set
+CONFIG_BATTERY_BQ27x00=m
+CONFIG_BATTERY_BQ27X00_I2C=y
+CONFIG_BATTERY_BQ27X00_PLATFORM=y
+CONFIG_BATTERY_DA9030=m
+CONFIG_BATTERY_MAX17040=m
+# CONFIG_BATTERY_MAX17042 is not set
+CONFIG_CHARGER_PCF50633=m
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_TWL4030 is not set
+# CONFIG_CHARGER_GPIO is not set
+CONFIG_HWMON=y
+CONFIG_HWMON_VID=m
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+CONFIG_SENSORS_ABITUGURU=m
+CONFIG_SENSORS_ABITUGURU3=m
+# CONFIG_SENSORS_AD7314 is not set
+CONFIG_SENSORS_AD7414=m
+CONFIG_SENSORS_AD7418=m
+CONFIG_SENSORS_ADCXX=m
+CONFIG_SENSORS_ADM1021=m
+CONFIG_SENSORS_ADM1025=m
+CONFIG_SENSORS_ADM1026=m
+CONFIG_SENSORS_ADM1029=m
+CONFIG_SENSORS_ADM1031=m
+CONFIG_SENSORS_ADM9240=m
+# CONFIG_SENSORS_ADT7411 is not set
+CONFIG_SENSORS_ADT7462=m
+CONFIG_SENSORS_ADT7470=m
+CONFIG_SENSORS_ADT7475=m
+# CONFIG_SENSORS_ASC7621 is not set
+CONFIG_SENSORS_K8TEMP=m
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+CONFIG_SENSORS_ASB100=m
+CONFIG_SENSORS_ATXP1=m
+# CONFIG_SENSORS_DS620 is not set
+CONFIG_SENSORS_DS1621=m
+CONFIG_SENSORS_I5K_AMB=m
+CONFIG_SENSORS_F71805F=m
+CONFIG_SENSORS_F71882FG=m
+CONFIG_SENSORS_F75375S=m
+CONFIG_SENSORS_FSCHMD=m
+CONFIG_SENSORS_G760A=m
+CONFIG_SENSORS_GL518SM=m
+CONFIG_SENSORS_GL520SM=m
+# CONFIG_SENSORS_GPIO_FAN is not set
+CONFIG_SENSORS_CORETEMP=m
+CONFIG_SENSORS_IBMAEM=m
+CONFIG_SENSORS_IBMPEX=m
+CONFIG_SENSORS_IT87=m
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+CONFIG_SENSORS_LM63=m
+CONFIG_SENSORS_LM70=m
+# CONFIG_SENSORS_LM73 is not set
+CONFIG_SENSORS_LM75=m
+CONFIG_SENSORS_LM77=m
+CONFIG_SENSORS_LM78=m
+CONFIG_SENSORS_LM80=m
+CONFIG_SENSORS_LM83=m
+CONFIG_SENSORS_LM85=m
+CONFIG_SENSORS_LM87=m
+CONFIG_SENSORS_LM90=m
+CONFIG_SENSORS_LM92=m
+CONFIG_SENSORS_LM93=m
+# CONFIG_SENSORS_LTC4151 is not set
+CONFIG_SENSORS_LTC4215=m
+CONFIG_SENSORS_LTC4245=m
+# CONFIG_SENSORS_LTC4261 is not set
+CONFIG_SENSORS_LM95241=m
+# CONFIG_SENSORS_LM95245 is not set
+CONFIG_SENSORS_MAX1111=m
+# CONFIG_SENSORS_MAX16065 is not set
+CONFIG_SENSORS_MAX1619=m
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+CONFIG_SENSORS_MAX6650=m
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+CONFIG_SENSORS_PC87360=m
+CONFIG_SENSORS_PC87427=m
+CONFIG_SENSORS_PCF8591=m
+# CONFIG_PMBUS is not set
+CONFIG_SENSORS_SHT15=m
+# CONFIG_SENSORS_SHT21 is not set
+CONFIG_SENSORS_SIS5595=m
+# CONFIG_SENSORS_SMM665 is not set
+CONFIG_SENSORS_DME1737=m
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+CONFIG_SENSORS_SMSC47M1=m
+CONFIG_SENSORS_SMSC47M192=m
+CONFIG_SENSORS_SMSC47B397=m
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+CONFIG_SENSORS_ADS7828=m
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+CONFIG_SENSORS_THMC50=m
+# CONFIG_SENSORS_TMP102 is not set
+CONFIG_SENSORS_TMP401=m
+CONFIG_SENSORS_TMP421=m
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+CONFIG_SENSORS_VIA686A=m
+CONFIG_SENSORS_VT1211=m
+CONFIG_SENSORS_VT8231=m
+CONFIG_SENSORS_W83781D=m
+CONFIG_SENSORS_W83791D=m
+CONFIG_SENSORS_W83792D=m
+CONFIG_SENSORS_W83793=m
+# CONFIG_SENSORS_W83795 is not set
+CONFIG_SENSORS_W83L785TS=m
+CONFIG_SENSORS_W83L786NG=m
+CONFIG_SENSORS_W83627HF=m
+CONFIG_SENSORS_W83627EHF=m
+CONFIG_SENSORS_APPLESMC=m
+
+#
+# ACPI drivers
+#
+# CONFIG_SENSORS_ACPI_POWER is not set
+CONFIG_SENSORS_ATK0110=m
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=m
+CONFIG_TWL4030_WATCHDOG=m
+CONFIG_ACQUIRE_WDT=m
+CONFIG_ADVANTECH_WDT=m
+CONFIG_ALIM1535_WDT=m
+CONFIG_ALIM7101_WDT=m
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+CONFIG_SC520_WDT=m
+CONFIG_SBC_FITPC2_WATCHDOG=m
+CONFIG_EUROTECH_WDT=m
+CONFIG_IB700_WDT=m
+CONFIG_IBMASR=m
+CONFIG_WAFER_WDT=m
+CONFIG_I6300ESB_WDT=m
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+CONFIG_IT8712F_WDT=m
+CONFIG_IT87_WDT=m
+# CONFIG_HP_WATCHDOG is not set
+CONFIG_SC1200_WDT=m
+CONFIG_PC87413_WDT=m
+# CONFIG_NV_TCO is not set
+CONFIG_60XX_WDT=m
+CONFIG_SBC8360_WDT=m
+CONFIG_CPU5_WDT=m
+CONFIG_SMSC_SCH311X_WDT=m
+CONFIG_SMSC37B787_WDT=m
+CONFIG_W83627HF_WDT=m
+CONFIG_W83697HF_WDT=m
+CONFIG_W83697UG_WDT=m
+CONFIG_W83877F_WDT=m
+CONFIG_W83977F_WDT=m
+CONFIG_MACHZ_WDT=m
+CONFIG_SBC_EPX_C3_WATCHDOG=m
+
+#
+# PCI-based Watchdog Cards
+#
+CONFIG_PCIPCWATCHDOG=m
+CONFIG_WDTPCI=m
+
+#
+# USB-based Watchdog Cards
+#
+CONFIG_USBPCWATCHDOG=m
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=m
+CONFIG_SSB_SPROM=y
+CONFIG_SSB_PCIHOST_POSSIBLE=y
+CONFIG_SSB_PCIHOST=y
+# CONFIG_SSB_B43_PCI_BRIDGE is not set
+CONFIG_SSB_SDIOHOST_POSSIBLE=y
+CONFIG_SSB_SDIOHOST=y
+# CONFIG_SSB_DEBUG is not set
+CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
+CONFIG_SSB_DRIVER_PCICORE=y
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=m
+# CONFIG_MFD_88PM860X is not set
+CONFIG_MFD_SM501=m
+# CONFIG_MFD_SM501_GPIO is not set
+CONFIG_HTC_PASIC3=m
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+CONFIG_TPS65010=m
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+CONFIG_TWL4030_CORE=y
+# CONFIG_TWL4030_MADC is not set
+# CONFIG_MFD_TWL4030_AUDIO is not set
+# CONFIG_TWL6030_PWM is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+CONFIG_PMIC_DA903X=y
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+CONFIG_MFD_WM8400=m
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+CONFIG_MFD_PCF50633=m
+CONFIG_PCF50633_ADC=m
+CONFIG_PCF50633_GPIO=m
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_TIMBERDALE is not set
+CONFIG_LPC_SCH=m
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+CONFIG_REGULATOR_VIRTUAL_CONSUMER=m
+CONFIG_REGULATOR_USERSPACE_CONSUMER=m
+# CONFIG_REGULATOR_GPIO is not set
+CONFIG_REGULATOR_BQ24022=m
+CONFIG_REGULATOR_MAX1586=m
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+CONFIG_REGULATOR_TWL4030=y
+CONFIG_REGULATOR_WM8400=m
+CONFIG_REGULATOR_DA903X=m
+CONFIG_REGULATOR_PCF50633=m
+CONFIG_REGULATOR_LP3971=m
+# CONFIG_REGULATOR_LP3972 is not set
+CONFIG_REGULATOR_TPS65023=m
+CONFIG_REGULATOR_TPS6507X=m
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=m
+CONFIG_AGP_SIS=m
+CONFIG_AGP_VIA=m
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+# CONFIG_VGA_SWITCHEROO is not set
+CONFIG_DRM=m
+CONFIG_DRM_KMS_HELPER=m
+CONFIG_DRM_TTM=m
+CONFIG_DRM_TDFX=m
+CONFIG_DRM_R128=m
+CONFIG_DRM_RADEON=m
+CONFIG_DRM_RADEON_KMS=y
+CONFIG_DRM_I810=m
+CONFIG_DRM_I915=m
+CONFIG_DRM_I915_KMS=y
+CONFIG_DRM_MGA=m
+CONFIG_DRM_SIS=m
+CONFIG_DRM_VIA=m
+CONFIG_DRM_SAVAGE=m
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_STUB_POULSBO is not set
+CONFIG_VGASTATE=m
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB_DDC=m
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=m
+CONFIG_FB_SYS_COPYAREA=m
+CONFIG_FB_SYS_IMAGEBLIT=m
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=m
+# CONFIG_FB_WMT_GE_ROPS is not set
+CONFIG_FB_DEFERRED_IO=y
+CONFIG_FB_HECUBA=m
+CONFIG_FB_SVGALIB=m
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_CIRRUS=m
+CONFIG_FB_PM2=m
+CONFIG_FB_PM2_FIFO_DISCONNECT=y
+CONFIG_FB_CYBER2000=m
+CONFIG_FB_CYBER2000_DDC=y
+CONFIG_FB_ARC=m
+CONFIG_FB_ASILIANT=y
+CONFIG_FB_IMSTT=y
+CONFIG_FB_VGA16=m
+CONFIG_FB_UVESA=m
+# CONFIG_FB_VESA is not set
+CONFIG_FB_EFI=y
+CONFIG_FB_N411=m
+CONFIG_FB_HGA=m
+CONFIG_FB_S1D13XXX=m
+CONFIG_FB_NVIDIA=m
+CONFIG_FB_NVIDIA_I2C=y
+# CONFIG_FB_NVIDIA_DEBUG is not set
+CONFIG_FB_NVIDIA_BACKLIGHT=y
+CONFIG_FB_RIVA=m
+CONFIG_FB_RIVA_I2C=y
+# CONFIG_FB_RIVA_DEBUG is not set
+CONFIG_FB_RIVA_BACKLIGHT=y
+CONFIG_FB_LE80578=m
+CONFIG_FB_CARILLO_RANCH=m
+CONFIG_FB_MATROX=m
+CONFIG_FB_MATROX_MILLENIUM=y
+CONFIG_FB_MATROX_MYSTIQUE=y
+CONFIG_FB_MATROX_G=y
+CONFIG_FB_MATROX_I2C=m
+CONFIG_FB_MATROX_MAVEN=m
+CONFIG_FB_RADEON=m
+CONFIG_FB_RADEON_I2C=y
+CONFIG_FB_RADEON_BACKLIGHT=y
+# CONFIG_FB_RADEON_DEBUG is not set
+CONFIG_FB_ATY128=m
+CONFIG_FB_ATY128_BACKLIGHT=y
+CONFIG_FB_ATY=m
+CONFIG_FB_ATY_CT=y
+CONFIG_FB_ATY_GENERIC_LCD=y
+CONFIG_FB_ATY_GX=y
+CONFIG_FB_ATY_BACKLIGHT=y
+CONFIG_FB_S3=m
+CONFIG_FB_S3_DDC=y
+CONFIG_FB_SAVAGE=m
+CONFIG_FB_SAVAGE_I2C=y
+CONFIG_FB_SAVAGE_ACCEL=y
+CONFIG_FB_SIS=m
+CONFIG_FB_SIS_300=y
+CONFIG_FB_SIS_315=y
+CONFIG_FB_VIA=m
+# CONFIG_FB_VIA_DIRECT_PROCFS is not set
+# CONFIG_FB_VIA_X_COMPATIBILITY is not set
+CONFIG_FB_NEOMAGIC=m
+CONFIG_FB_KYRO=m
+CONFIG_FB_3DFX=m
+# CONFIG_FB_3DFX_ACCEL is not set
+CONFIG_FB_3DFX_I2C=y
+CONFIG_FB_VOODOO1=m
+CONFIG_FB_VT8623=m
+CONFIG_FB_TRIDENT=m
+CONFIG_FB_ARK=m
+CONFIG_FB_PM3=m
+CONFIG_FB_CARMINE=m
+CONFIG_FB_CARMINE_DRAM_EVAL=y
+# CONFIG_CARMINE_DRAM_CUSTOM is not set
+CONFIG_FB_GEODE=y
+CONFIG_FB_GEODE_LX=m
+CONFIG_FB_GEODE_GX=m
+CONFIG_FB_GEODE_GX1=m
+CONFIG_FB_TMIO=m
+CONFIG_FB_TMIO_ACCELL=y
+CONFIG_FB_SM501=m
+# CONFIG_FB_SMSCUFX is not set
+CONFIG_FB_UDL=m
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FB_METRONOME=m
+CONFIG_FB_MB862XX=m
+CONFIG_FB_MB862XX_PCI_GDC=y
+CONFIG_FB_MB862XX_I2C=y
+CONFIG_FB_BROADSHEET=m
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_L4F00242T03 is not set
+CONFIG_LCD_LMS283GF05=m
+CONFIG_LCD_LTV350QV=m
+CONFIG_LCD_ILI9320=m
+CONFIG_LCD_TDO24M=m
+CONFIG_LCD_VGG2432A4=m
+CONFIG_LCD_PLATFORM=m
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=m
+CONFIG_BACKLIGHT_PROGEAR=m
+CONFIG_BACKLIGHT_CARILLO_RANCH=m
+CONFIG_BACKLIGHT_DA903X=m
+# CONFIG_BACKLIGHT_APPLE is not set
+CONFIG_BACKLIGHT_SAHARA=m
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_PCF50633 is not set
+
+#
+# Display device support
+#
+CONFIG_DISPLAY_SUPPORT=m
+
+#
+# Display hardware drivers
+#
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=m
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=m
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=m
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=m
+CONFIG_HID_BELKIN=m
+CONFIG_HID_CHERRY=m
+CONFIG_HID_CHICONY=m
+CONFIG_HID_CYPRESS=m
+CONFIG_HID_DRAGONRISE=m
+CONFIG_DRAGONRISE_FF=y
+# CONFIG_HID_EMS_FF is not set
+CONFIG_HID_EZKEY=m
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=m
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+CONFIG_HID_GYRATION=m
+CONFIG_HID_TWINHAN=m
+CONFIG_HID_KENSINGTON=m
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=m
+CONFIG_HID_LOGITECH_DJ=m
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+# CONFIG_LOGIG940_FF is not set
+CONFIG_LOGIWHEELS_FF=y
+CONFIG_HID_MICROSOFT=m
+CONFIG_HID_MONTEREY=m
+# CONFIG_HID_MULTITOUCH is not set
+CONFIG_HID_NTRIG=m
+CONFIG_HID_ORTEK=m
+CONFIG_HID_PANTHERLORD=m
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=m
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+CONFIG_HID_QUANTA=m
+# CONFIG_HID_ROCCAT is not set
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+# CONFIG_HID_SPEEDLINK is not set
+CONFIG_HID_SUNPLUS=m
+CONFIG_HID_GREENASIA=m
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=m
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=m
+CONFIG_HID_THRUSTMASTER=m
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_ZEROPLUS=m
+CONFIG_ZEROPLUS_FF=y
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_DWC3 is not set
+CONFIG_USB_MON=y
+CONFIG_USB_WUSB=m
+CONFIG_USB_WUSB_CBAF=m
+# CONFIG_USB_WUSB_CBAF_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_C67X00_HCD=m
+CONFIG_USB_XHCI_HCD=m
+# CONFIG_USB_XHCI_HCD_DEBUGGING is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_OXU210HP_HCD=m
+CONFIG_USB_ISP116X_HCD=m
+CONFIG_USB_ISP1760_HCD=m
+CONFIG_USB_ISP1362_HCD=m
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=y
+CONFIG_USB_U132_HCD=m
+CONFIG_USB_SL811_HCD=m
+# CONFIG_USB_SL811_HCD_ISO is not set
+CONFIG_USB_R8A66597_HCD=m
+CONFIG_USB_WHCI_HCD=m
+CONFIG_USB_HWA_HCD=m
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+CONFIG_USB_TMC=m
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_EZUSB=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_MOTOROLA=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+# CONFIG_USB_SERIAL_QCAUX is not set
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_USB_SERIAL_SAFE=m
+# CONFIG_USB_SERIAL_SAFE_PADDED is not set
+CONFIG_USB_SERIAL_SIEMENS_MPI=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_SYMBOL=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_WWAN=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_USB_SERIAL_OPTICON=m
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+CONFIG_USB_SERIAL_DEBUG=m
+
+#
+# USB Miscellaneous drivers
+#
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_SEVSEG=m
+CONFIG_USB_RIO500=m
+CONFIG_USB_LEGOTOWER=m
+CONFIG_USB_LCD=m
+CONFIG_USB_LED=m
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_CYTHERM=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_SISUSBVGA=m
+# CONFIG_USB_SISUSBVGA_CON is not set
+CONFIG_USB_LD=m
+CONFIG_USB_TRANCEVIBRATOR=m
+CONFIG_USB_IOWARRIOR=m
+CONFIG_USB_TEST=m
+CONFIG_USB_ISIGHTFW=m
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_ATM=m
+CONFIG_USB_SPEEDTOUCH=m
+CONFIG_USB_CXACRU=m
+CONFIG_USB_UEAGLEATM=m
+CONFIG_USB_XUSBATM=m
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_CI13XXX_PCI is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_EG20T is not set
+CONFIG_USB_DUMMY_HCD=m
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_SUPERSPEED=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_ETH_EEM is not set
+# CONFIG_USB_G_NCM is not set
+CONFIG_USB_GADGETFS=m
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_MASS_STORAGE is not set
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_G_PRINTER=m
+CONFIG_USB_CDC_COMPOSITE=m
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+CONFIG_USB_GPIO_VBUS=m
+CONFIG_TWL4030_USB=m
+# CONFIG_TWL6030_USB is not set
+CONFIG_NOP_USB_XCEIV=m
+CONFIG_UWB=m
+CONFIG_UWB_HWA=m
+CONFIG_UWB_WHCI=m
+CONFIG_UWB_I1480U=m
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=m
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_SDIO_UART=m
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_SDHCI_PCI=m
+# CONFIG_MMC_RICOH_MMC is not set
+CONFIG_MMC_SDHCI_PLTFM=m
+CONFIG_MMC_WBSD=m
+CONFIG_MMC_TIFM_SD=m
+CONFIG_MMC_SPI=m
+CONFIG_MMC_CB710=m
+CONFIG_MMC_VIA_SDMMC=m
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+CONFIG_LEDS_PCA9532=m
+# CONFIG_LEDS_PCA9532_GPIO is not set
+CONFIG_LEDS_GPIO=m
+CONFIG_LEDS_LP3944=m
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_CLEVO_MAIL is not set
+CONFIG_LEDS_PCA955X=m
+CONFIG_LEDS_DA903X=m
+CONFIG_LEDS_DAC124S085=m
+# CONFIG_LEDS_REGULATOR is not set
+CONFIG_LEDS_BD2802=m
+# CONFIG_LEDS_INTEL_SS4200 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_DELL_NETBOOKS=m
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=m
+CONFIG_LEDS_TRIGGER_HEARTBEAT=m
+CONFIG_LEDS_TRIGGER_BACKLIGHT=m
+CONFIG_LEDS_TRIGGER_GPIO=m
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=m
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC=y
+
+#
+# Reporting subsystems
+#
+# CONFIG_EDAC_DEBUG is not set
+CONFIG_EDAC_DECODE_MCE=m
+# CONFIG_EDAC_MCE_INJ is not set
+CONFIG_EDAC_MM_EDAC=m
+CONFIG_EDAC_AMD64=m
+# CONFIG_EDAC_AMD64_ERROR_INJECTION is not set
+CONFIG_EDAC_E752X=m
+CONFIG_EDAC_I82975X=m
+CONFIG_EDAC_I3000=m
+CONFIG_EDAC_I3200=m
+CONFIG_EDAC_X38=m
+CONFIG_EDAC_I5400=m
+# CONFIG_EDAC_I7CORE is not set
+CONFIG_EDAC_I5000=m
+CONFIG_EDAC_I5100=m
+# CONFIG_EDAC_I7300 is not set
+# CONFIG_EDAC_SBRIDGE is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+CONFIG_RTC_DRV_TEST=m
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=m
+CONFIG_RTC_DRV_DS1374=m
+CONFIG_RTC_DRV_DS1672=m
+# CONFIG_RTC_DRV_DS3232 is not set
+CONFIG_RTC_DRV_MAX6900=m
+CONFIG_RTC_DRV_RS5C372=m
+CONFIG_RTC_DRV_ISL1208=m
+# CONFIG_RTC_DRV_ISL12022 is not set
+CONFIG_RTC_DRV_X1205=m
+CONFIG_RTC_DRV_PCF8563=m
+CONFIG_RTC_DRV_PCF8583=m
+CONFIG_RTC_DRV_M41T80=m
+CONFIG_RTC_DRV_M41T80_WDT=y
+# CONFIG_RTC_DRV_BQ32K is not set
+CONFIG_RTC_DRV_TWL4030=m
+CONFIG_RTC_DRV_S35390A=m
+CONFIG_RTC_DRV_FM3130=m
+CONFIG_RTC_DRV_RX8581=m
+CONFIG_RTC_DRV_RX8025=m
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+CONFIG_RTC_DRV_M41T94=m
+CONFIG_RTC_DRV_DS1305=m
+CONFIG_RTC_DRV_DS1390=m
+CONFIG_RTC_DRV_MAX6902=m
+CONFIG_RTC_DRV_R9701=m
+CONFIG_RTC_DRV_RS5C348=m
+CONFIG_RTC_DRV_DS3234=m
+CONFIG_RTC_DRV_PCF2123=m
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+CONFIG_RTC_DRV_DS1286=m
+CONFIG_RTC_DRV_DS1511=m
+CONFIG_RTC_DRV_DS1553=m
+CONFIG_RTC_DRV_DS1742=m
+CONFIG_RTC_DRV_STK17TA8=m
+CONFIG_RTC_DRV_M48T86=m
+CONFIG_RTC_DRV_M48T35=m
+CONFIG_RTC_DRV_M48T59=m
+# CONFIG_RTC_DRV_MSM6242 is not set
+CONFIG_RTC_DRV_BQ4802=m
+# CONFIG_RTC_DRV_RP5C01 is not set
+CONFIG_RTC_DRV_V3020=m
+CONFIG_RTC_DRV_PCF50633=m
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+# CONFIG_INTEL_MID_DMAC is not set
+CONFIG_INTEL_IOATDMA=m
+# CONFIG_TIMB_DMA is not set
+# CONFIG_PCH_DMA is not set
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+CONFIG_NET_DMA=y
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+CONFIG_DCA=m
+CONFIG_AUXDISPLAY=y
+CONFIG_UIO=m
+CONFIG_UIO_CIF=m
+CONFIG_UIO_PDRV=m
+CONFIG_UIO_PDRV_GENIRQ=m
+CONFIG_UIO_AEC=m
+CONFIG_UIO_SERCOS3=m
+CONFIG_UIO_PCI_GENERIC=m
+# CONFIG_UIO_NETX is not set
+CONFIG_VIRTIO=m
+CONFIG_VIRTIO_RING=m
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=m
+CONFIG_VIRTIO_BALLOON=m
+# CONFIG_VIRTIO_MMIO is not set
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+CONFIG_ACER_WMI=m
+CONFIG_ACERHDF=m
+CONFIG_ASUS_LAPTOP=m
+CONFIG_DELL_WMI=m
+# CONFIG_DELL_WMI_AIO is not set
+CONFIG_FUJITSU_LAPTOP=m
+# CONFIG_FUJITSU_LAPTOP_DEBUG is not set
+# CONFIG_HP_ACCEL is not set
+CONFIG_HP_WMI=m
+CONFIG_MSI_LAPTOP=m
+CONFIG_PANASONIC_LAPTOP=m
+CONFIG_COMPAL_LAPTOP=m
+CONFIG_SONY_LAPTOP=m
+CONFIG_SONYPI_COMPAT=y
+# CONFIG_IDEAPAD_LAPTOP is not set
+CONFIG_THINKPAD_ACPI=m
+CONFIG_THINKPAD_ACPI_DEBUGFACILITIES=y
+# CONFIG_THINKPAD_ACPI_DEBUG is not set
+# CONFIG_THINKPAD_ACPI_UNSAFE_LEDS is not set
+CONFIG_THINKPAD_ACPI_VIDEO=y
+CONFIG_THINKPAD_ACPI_HOTKEY_POLL=y
+CONFIG_SENSORS_HDAPS=m
+CONFIG_INTEL_MENLOW=m
+CONFIG_EEEPC_LAPTOP=m
+# CONFIG_ASUS_WMI is not set
+CONFIG_ACPI_WMI=y
+# CONFIG_MSI_WMI is not set
+# CONFIG_ACPI_ASUS is not set
+CONFIG_TOPSTAR_LAPTOP=m
+CONFIG_ACPI_TOSHIBA=m
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_ACPI_CMPC is not set
+# CONFIG_INTEL_IPS is not set
+# CONFIG_IBM_RTL is not set
+# CONFIG_XO15_EBOOK is not set
+# CONFIG_SAMSUNG_LAPTOP is not set
+CONFIG_MXM_WMI=m
+# CONFIG_INTEL_OAKTRAIL is not set
+# CONFIG_SAMSUNG_Q10 is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_HYPERV is not set
+# CONFIG_PM_DEVFREQ is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=y
+CONFIG_EDD_OFF=y
+CONFIG_FIRMWARE_MEMMAP=y
+CONFIG_EFI_VARS=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+# CONFIG_DMI_SYSFS is not set
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_SIGMA is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=m
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=m
+CONFIG_QFMT_V1=m
+CONFIG_QFMT_V2=m
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=m
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+CONFIG_FSCACHE=m
+# CONFIG_FSCACHE_STATS is not set
+# CONFIG_FSCACHE_HISTOGRAM is not set
+# CONFIG_FSCACHE_DEBUG is not set
+# CONFIG_FSCACHE_OBJECT_LIST is not set
+CONFIG_CACHEFILES=m
+# CONFIG_CACHEFILES_DEBUG is not set
+# CONFIG_CACHEFILES_HISTOGRAM is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_ADFS_FS=m
+# CONFIG_ADFS_FS_RW is not set
+CONFIG_AFFS_FS=m
+CONFIG_ECRYPT_FS=y
+CONFIG_HFS_FS=m
+CONFIG_HFSPLUS_FS=m
+CONFIG_BEFS_FS=m
+# CONFIG_BEFS_DEBUG is not set
+CONFIG_BFS_FS=m
+CONFIG_EFS_FS=m
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_LZO=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+# CONFIG_JFFS2_CMODE_PRIORITY is not set
+# CONFIG_JFFS2_CMODE_SIZE is not set
+CONFIG_JFFS2_CMODE_FAVOURLZO=y
+CONFIG_UBIFS_FS=m
+CONFIG_UBIFS_FS_XATTR=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=m
+CONFIG_SQUASHFS=m
+# CONFIG_SQUASHFS_XATTR is not set
+CONFIG_SQUASHFS_ZLIB=y
+# CONFIG_SQUASHFS_LZO is not set
+# CONFIG_SQUASHFS_XZ is not set
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+CONFIG_VXFS_FS=m
+CONFIG_MINIX_FS=m
+CONFIG_OMFS_FS=m
+CONFIG_HPFS_FS=m
+CONFIG_QNX4FS_FS=m
+CONFIG_ROMFS_FS=m
+CONFIG_ROMFS_BACKED_BY_BLOCK=y
+# CONFIG_ROMFS_BACKED_BY_MTD is not set
+# CONFIG_ROMFS_BACKED_BY_BOTH is not set
+CONFIG_ROMFS_ON_BLOCK=y
+# CONFIG_PSTORE is not set
+CONFIG_SYSV_FS=m
+CONFIG_UFS_FS=m
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_UFS_DEBUG is not set
+CONFIG_EXOFS_FS=m
+# CONFIG_EXOFS_DEBUG is not set
+CONFIG_ORE=m
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_NFS_FSCACHE is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFS_USE_NEW_IDMAPPER is not set
+CONFIG_NFSD=m
+CONFIG_NFSD_V2_ACL=y
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_RPCSEC_GSS_KRB5=m
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+CONFIG_CIFS_WEAK_PW_HASH=y
+CONFIG_CIFS_UPCALL=y
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_DEBUG2 is not set
+CONFIG_CIFS_DFS_UPCALL=y
+# CONFIG_CIFS_FSCACHE is not set
+# CONFIG_CIFS_ACL is not set
+CONFIG_NCP_FS=m
+CONFIG_NCPFS_PACKET_SIGNING=y
+CONFIG_NCPFS_IOCTL_LOCKING=y
+CONFIG_NCPFS_STRONG=y
+CONFIG_NCPFS_NFS_NS=y
+CONFIG_NCPFS_OS2_NS=y
+# CONFIG_NCPFS_SMALLDOS is not set
+CONFIG_NCPFS_NLS=y
+CONFIG_NCPFS_EXTRAS=y
+CONFIG_CODA_FS=m
+CONFIG_AFS_FS=m
+# CONFIG_AFS_DEBUG is not set
+# CONFIG_AFS_FSCACHE is not set
+CONFIG_9P_FS=m
+# CONFIG_9P_FSCACHE is not set
+# CONFIG_9P_FS_POSIX_ACL is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ACORN_PARTITION=y
+# CONFIG_ACORN_PARTITION_CUMANA is not set
+# CONFIG_ACORN_PARTITION_EESOX is not set
+CONFIG_ACORN_PARTITION_ICS=y
+# CONFIG_ACORN_PARTITION_ADFS is not set
+# CONFIG_ACORN_PARTITION_POWERTEC is not set
+CONFIG_ACORN_PARTITION_RISCIX=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_ATARI_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_LDM_PARTITION=y
+# CONFIG_LDM_DEBUG is not set
+CONFIG_SGI_PARTITION=y
+CONFIG_ULTRIX_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_SYSV68_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+CONFIG_DLM=m
+# CONFIG_DLM_DEBUG is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+CONFIG_BOOT_PRINTK_DELAY=y
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_CPU_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_LATENCYTOP=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FTRACE_NMI_ENTER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_RING_BUFFER=y
+CONFIG_FTRACE_NMI_ENTER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_EVENT_POWER_TRACING_DEPRECATED=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_FUNCTION_PROFILER=y
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_FIREWIRE_OHCI_REMOTE_DMA is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+CONFIG_ASYNC_RAID6_TEST=m
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_KGDB=y
+CONFIG_KGDB_SERIAL_CONSOLE=y
+# CONFIG_KGDB_TESTS is not set
+# CONFIG_KGDB_LOW_LEVEL_TRAP is not set
+# CONFIG_KGDB_KDB is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_DEBUG_RODATA is not set
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_DEBUG_NX_TEST is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+# CONFIG_IO_DELAY_0X80 is not set
+CONFIG_IO_DELAY_0XED=y
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=1
+CONFIG_DEBUG_BOOT_PARAMS=y
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_TRUSTED_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+CONFIG_SECURITY_PATH=y
+CONFIG_LSM_MMAP_MIN_ADDR=0
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=0
+CONFIG_SECURITY_SELINUX_DISABLE=y
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
+CONFIG_SECURITY_SMACK=y
+CONFIG_SECURITY_TOMOYO=y
+CONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY=2048
+CONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG=1024
+# CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER is not set
+CONFIG_SECURITY_TOMOYO_POLICY_LOADER="/sbin/tomoyo-init"
+CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER="/sbin/init"
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE=1
+# CONFIG_IMA is not set
+# CONFIG_EVM is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_APPARMOR=y
+# CONFIG_DEFAULT_SECURITY_DAC is not set
+CONFIG_DEFAULT_SECURITY="apparmor"
+CONFIG_XOR_BLOCKS=m
+CONFIG_ASYNC_CORE=m
+CONFIG_ASYNC_MEMCPY=m
+CONFIG_ASYNC_XOR=m
+CONFIG_ASYNC_PQ=m
+CONFIG_ASYNC_RAID6_RECOV=m
+CONFIG_ASYNC_TX_DISABLE_PQ_VAL_DMA=y
+CONFIG_ASYNC_TX_DISABLE_XOR_VAL_DMA=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=m
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=m
+CONFIG_CRYPTO_NULL=m
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_CRYPTD=m
+CONFIG_CRYPTO_AUTHENC=m
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=m
+CONFIG_CRYPTO_GCM=m
+CONFIG_CRYPTO_SEQIV=m
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=m
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_LRW=m
+CONFIG_CRYPTO_PCBC=m
+CONFIG_CRYPTO_XTS=m
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=m
+CONFIG_CRYPTO_VMAC=m
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=m
+CONFIG_CRYPTO_CRC32C_INTEL=m
+CONFIG_CRYPTO_GHASH=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL=m
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_AES_X86_64=m
+CONFIG_CRYPTO_AES_NI_INTEL=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_BLOWFISH_COMMON=m
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SALSA20_X86_64=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+CONFIG_CRYPTO_TWOFISH_X86_64=m
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=m
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_REED_SOLOMON=m
+CONFIG_REED_SOLOMON_DEC16=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_NLATTR=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
+
+#
+# Popcorn Multi-Kernel Support
+#
+CONFIG_POPCORN=y
+CONFIG_DEBUG_POPCORN=y
+CONFIG_POPCORN_KMSG=y
+# CONFIG_POPCORN_UMSG is not set
diff --git a/ben_config_base b/ben_config_base
new file mode 100644
index 0000000..d3ec9d1
--- /dev/null
+++ b/ben_config_base
@@ -0,0 +1,4063 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86_64 3.2.14 Kernel Configuration
+#
+CONFIG_64BIT=y
+# CONFIG_X86_32 is not set
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ZONE_DMA32=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_X86_64_SMP=y
+CONFIG_X86_HT=y
+CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11"
+# CONFIG_KTIME_SCALAR is not set
+CONFIG_ARCH_CPU_PROBE_RELEASE=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+# CONFIG_FHANDLE is not set
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=64
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP_ENABLED=y
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_MM_OWNER=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+CONFIG_PERF_COUNTERS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_OPROFILE=m
+# CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+# CONFIG_JUMP_LABEL is not set
+CONFIG_OPTPROBES=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_SMP=y
+CONFIG_X86_MPPARSE=y
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_VSMP is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_PARAVIRT_GUEST is not set
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MEMTEST is not set
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=7
+CONFIG_X86_CMPXCHG=y
+CONFIG_CMPXCHG_LOCAL=y
+CONFIG_CMPXCHG_DOUBLE=y
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_XADD=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=64
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+CONFIG_X86_MCE_INJECT=m
+CONFIG_X86_THERMAL_VECTOR=y
+CONFIG_I8K=m
+CONFIG_MICROCODE=m
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_X86_MSR=m
+CONFIG_X86_CPUID=m
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+# CONFIG_NUMA_EMU is not set
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+CONFIG_X86_CHECK_BIOS_CORRUPTION=y
+CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_EFI=y
+CONFIG_SECCOMP=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_KEXEC_JUMP=y
+CONFIG_PHYSICAL_START=0x200000
+CONFIG_RELOCATABLE=y
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_ARCH_HIBERNATION_HEADER=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_TRACE=y
+CONFIG_PM_TRACE_RTC=y
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_VIDEO=m
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_PROCESSOR=y
+# CONFIG_ACPI_IPMI is not set
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+CONFIG_ACPI_THERMAL=y
+CONFIG_ACPI_NUMA=y
+CONFIG_ACPI_CUSTOM_DSDT_FILE=""
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_SBS=y
+# CONFIG_ACPI_HED is not set
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+# CONFIG_ACPI_APEI is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+
+#
+# x86 CPU frequency scaling drivers
+#
+# CONFIG_X86_PCC_CPUFREQ is not set
+CONFIG_X86_ACPI_CPUFREQ=y
+CONFIG_X86_POWERNOW_K8=y
+CONFIG_X86_SPEEDSTEP_CENTRINO=y
+CONFIG_X86_P4_CLOCKMOD=m
+
+#
+# shared options
+#
+CONFIG_X86_SPEEDSTEP_LIB=m
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_INTEL_IDLE is not set
+
+#
+# Memory power savings
+#
+CONFIG_I7300_IDLE_IOAT_CHANNEL=y
+CONFIG_I7300_IDLE=m
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIE_PME=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_STUB=m
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+CONFIG_PCI_IOAPIC=y
+CONFIG_PCI_LABEL=y
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_FAKE=m
+CONFIG_HOTPLUG_PCI_ACPI=m
+CONFIG_HOTPLUG_PCI_ACPI_IBM=m
+CONFIG_HOTPLUG_PCI_CPCI=y
+CONFIG_HOTPLUG_PCI_CPCI_ZT5550=m
+CONFIG_HOTPLUG_PCI_CPCI_GENERIC=m
+CONFIG_HOTPLUG_PCI_SHPC=m
+# CONFIG_RAPIDIO is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_IA32_EMULATION=y
+# CONFIG_IA32_AOUT is not set
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_KEYS_COMPAT=y
+CONFIG_HAVE_TEXT_POKE_SMP=y
+CONFIG_NET=y
+CONFIG_COMPAT_NETLINK_MESSAGES=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_ROUTE_CLASSID=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=m
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_TCP_CONG_HTCP=m
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_TCP_CONG_VEGAS=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_TCP_CONG_VENO=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_TCP_CONG_ILLINOIS=m
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+# CONFIG_IPV6_MIP6 is not set
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_NETLABEL=y
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=m
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CT_PROTO_UDPLITE=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_BROADCAST=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_TPROXY=m
+CONFIG_NETFILTER_XTABLES=m
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_CONNMARK=m
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HL=m
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+# CONFIG_NETFILTER_XT_MATCH_IPVS is not set
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=m
+CONFIG_IP_VS_IPV6=y
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_AH_ESP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=m
+CONFIG_IP_VS_NFCT=y
+# CONFIG_IP_VS_PE_SIP is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_NF_NAT_PROTO_DCCP=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_PROTO_UDPLITE=m
+CONFIG_NF_NAT_PROTO_SCTP=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_SECURITY=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_IP6_NF_SECURITY=m
+
+#
+# DECnet: Netfilter Configuration
+#
+CONFIG_DECNET_NF_GRABULATOR=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+CONFIG_IP_DCCP=m
+CONFIG_INET_DCCP_DIAG=m
+
+#
+# DCCP CCIDs Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP_CCID2_DEBUG is not set
+CONFIG_IP_DCCP_CCID3=y
+# CONFIG_IP_DCCP_CCID3_DEBUG is not set
+CONFIG_IP_DCCP_TFRC_LIB=y
+
+#
+# DCCP Kernel Hacking
+#
+# CONFIG_IP_DCCP_DEBUG is not set
+CONFIG_NET_DCCPPROBE=m
+CONFIG_IP_SCTP=m
+# CONFIG_NET_SCTPPROBE is not set
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+CONFIG_RDS=m
+CONFIG_RDS_TCP=m
+# CONFIG_RDS_DEBUG is not set
+CONFIG_TIPC=m
+# CONFIG_TIPC_ADVANCED is not set
+# CONFIG_TIPC_DEBUG is not set
+CONFIG_ATM=m
+CONFIG_ATM_CLIP=m
+# CONFIG_ATM_CLIP_NO_ICMP is not set
+CONFIG_ATM_LANE=m
+CONFIG_ATM_MPOA=m
+CONFIG_ATM_BR2684=m
+# CONFIG_ATM_BR2684_IPFILTER is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_GARP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_NET_DSA=y
+CONFIG_NET_DSA_TAG_DSA=y
+CONFIG_NET_DSA_TAG_EDSA=y
+CONFIG_NET_DSA_TAG_TRAILER=y
+CONFIG_NET_DSA_MV88E6XXX=y
+CONFIG_NET_DSA_MV88E6060=y
+CONFIG_NET_DSA_MV88E6XXX_NEED_PPU=y
+CONFIG_NET_DSA_MV88E6131=y
+CONFIG_NET_DSA_MV88E6123_61_65=y
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_DECNET=m
+# CONFIG_DECNET_ROUTER is not set
+CONFIG_LLC=y
+CONFIG_LLC2=m
+CONFIG_IPX=m
+# CONFIG_IPX_INTERN is not set
+CONFIG_ATALK=m
+CONFIG_DEV_APPLETALK=m
+CONFIG_IPDDP=m
+CONFIG_IPDDP_ENCAP=y
+CONFIG_IPDDP_DECAP=y
+CONFIG_X25=m
+CONFIG_LAPB=m
+CONFIG_ECONET=m
+CONFIG_ECONET_AUNUDP=y
+CONFIG_ECONET_NATIVE=y
+CONFIG_WAN_ROUTER=m
+CONFIG_PHONET=m
+CONFIG_IEEE802154=m
+# CONFIG_IEEE802154_6LOWPAN is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_ATM=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_RED=m
+# CONFIG_NET_SCH_SFB is not set
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_DRR=m
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+CONFIG_NET_SCH_INGRESS=m
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_CLS_FLOW=m
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_NET_EMATCH_TEXT=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_NAT=m
+CONFIG_NET_ACT_PEDIT=m
+CONFIG_NET_ACT_SIMP=m
+CONFIG_NET_ACT_SKBEDIT=m
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_HAVE_BPF_JIT=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+CONFIG_NET_TCPPROBE=m
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_AF_RXRPC=m
+# CONFIG_AF_RXRPC_DEBUG is not set
+CONFIG_RXKAD=m
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_EXT_SYSFS is not set
+CONFIG_LIB80211=m
+CONFIG_LIB80211_CRYPT_WEP=m
+CONFIG_LIB80211_CRYPT_CCMP=m
+CONFIG_LIB80211_CRYPT_TKIP=m
+# CONFIG_LIB80211_DEBUG is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_LEDS=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_RFKILL_REGULATOR is not set
+CONFIG_NET_9P=m
+CONFIG_NET_9P_VIRTIO=m
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=m
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=m
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_REDBOOT_PARTS=m
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+CONFIG_MTD_AR7_PARTS=m
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=m
+CONFIG_HAVE_MTD_OTP=y
+CONFIG_MTD_BLKDEVS=m
+CONFIG_MTD_BLOCK=m
+CONFIG_MTD_BLOCK_RO=m
+CONFIG_FTL=m
+CONFIG_NFTL=m
+CONFIG_NFTL_RW=y
+CONFIG_INFTL=m
+CONFIG_RFD_FTL=m
+CONFIG_SSFDC=m
+# CONFIG_SM_FTL is not set
+CONFIG_MTD_OOPS=m
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=m
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_GEN_PROBE=m
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=m
+CONFIG_MTD_CFI_AMDSTD=m
+CONFIG_MTD_CFI_STAA=m
+CONFIG_MTD_CFI_UTIL=m
+CONFIG_MTD_RAM=m
+CONFIG_MTD_ROM=m
+CONFIG_MTD_ABSENT=m
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+CONFIG_MTD_PHYSMAP=m
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+CONFIG_MTD_SC520CDP=m
+CONFIG_MTD_NETSC520=m
+CONFIG_MTD_TS5500=m
+CONFIG_MTD_SBC_GXX=m
+CONFIG_MTD_AMD76XROM=m
+CONFIG_MTD_ICHXROM=m
+CONFIG_MTD_ESB2ROM=m
+CONFIG_MTD_CK804XROM=m
+CONFIG_MTD_SCB2_FLASH=m
+CONFIG_MTD_NETtel=m
+CONFIG_MTD_L440GX=m
+CONFIG_MTD_PCI=m
+CONFIG_MTD_GPIO_ADDR=m
+CONFIG_MTD_INTEL_VR_NOR=m
+CONFIG_MTD_PLATRAM=m
+# CONFIG_MTD_LATCH_ADDR is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_PMC551=m
+# CONFIG_MTD_PMC551_BUGFIX is not set
+# CONFIG_MTD_PMC551_DEBUG is not set
+CONFIG_MTD_DATAFLASH=m
+# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
+CONFIG_MTD_DATAFLASH_OTP=y
+CONFIG_MTD_M25P80=m
+CONFIG_M25PXX_USE_FAST_READ=y
+CONFIG_MTD_SST25L=m
+CONFIG_MTD_SLRAM=m
+CONFIG_MTD_PHRAM=m
+CONFIG_MTD_MTDRAM=m
+CONFIG_MTDRAM_TOTAL_SIZE=4096
+CONFIG_MTDRAM_ERASE_SIZE=128
+CONFIG_MTD_BLOCK2MTD=m
+
+#
+# Disk-On-Chip Device Drivers
+#
+CONFIG_MTD_DOC2000=m
+CONFIG_MTD_DOC2001=m
+CONFIG_MTD_DOC2001PLUS=m
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_DOCPROBE=m
+CONFIG_MTD_DOCECC=m
+# CONFIG_MTD_DOCPROBE_ADVANCED is not set
+CONFIG_MTD_DOCPROBE_ADDRESS=0x0
+CONFIG_MTD_NAND_ECC=m
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=m
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_DENALI is not set
+CONFIG_MTD_NAND_IDS=m
+# CONFIG_MTD_NAND_RICOH is not set
+CONFIG_MTD_NAND_DISKONCHIP=m
+# CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADVANCED is not set
+CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS=0
+# CONFIG_MTD_NAND_DISKONCHIP_BBTWRITE is not set
+CONFIG_MTD_NAND_CAFE=m
+CONFIG_MTD_NAND_NANDSIM=m
+CONFIG_MTD_NAND_PLATFORM=m
+CONFIG_MTD_ALAUDA=m
+CONFIG_MTD_ONENAND=m
+CONFIG_MTD_ONENAND_VERIFY_WRITE=y
+CONFIG_MTD_ONENAND_GENERIC=m
+# CONFIG_MTD_ONENAND_OTP is not set
+CONFIG_MTD_ONENAND_2X_PROGRAM=y
+CONFIG_MTD_ONENAND_SIM=m
+
+#
+# LPDDR flash memory drivers
+#
+CONFIG_MTD_LPDDR=m
+CONFIG_MTD_QINFO_PROBE=m
+CONFIG_MTD_UBI=m
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+CONFIG_MTD_UBI_GLUEBI=m
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+CONFIG_PNP_DEBUG_MESSAGES=y
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+CONFIG_BLK_DEV_FD=m
+CONFIG_BLK_CPQ_DA=m
+CONFIG_BLK_CPQ_CISS_DA=m
+CONFIG_CISS_SCSI_TAPE=y
+CONFIG_BLK_DEV_DAC960=m
+CONFIG_BLK_DEV_UMEM=m
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_OSD=m
+CONFIG_BLK_DEV_SX8=m
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_BLK_DEV_XIP is not set
+CONFIG_CDROM_PKTCDVD=y
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+CONFIG_ATA_OVER_ETH=m
+CONFIG_VIRTIO_BLK=m
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+CONFIG_IBM_ASM=m
+CONFIG_PHANTOM=m
+# CONFIG_INTEL_MID_PTI is not set
+CONFIG_SGI_IOC4=m
+CONFIG_TIFM_CORE=m
+CONFIG_TIFM_7XX1=m
+CONFIG_ICS932S401=m
+CONFIG_ENCLOSURE_SERVICES=m
+CONFIG_HP_ILO=m
+# CONFIG_APDS9802ALS is not set
+CONFIG_ISL29003=m
+# CONFIG_ISL29020 is not set
+CONFIG_SENSORS_TSL2550=m
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+CONFIG_DS1682=m
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_VMWARE_BALLOON is not set
+# CONFIG_BMP085 is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+CONFIG_C2PORT=m
+CONFIG_C2PORT_DURAMAR_2150=m
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=m
+CONFIG_EEPROM_AT25=m
+CONFIG_EEPROM_LEGACY=m
+CONFIG_EEPROM_MAX6875=m
+CONFIG_EEPROM_93CX6=m
+# CONFIG_EEPROM_93XX46 is not set
+CONFIG_CB710_CORE=m
+# CONFIG_CB710_DEBUG is not set
+CONFIG_CB710_DEBUG_ASSUMPTIONS=y
+CONFIG_IWMC3200TOP=m
+# CONFIG_IWMC3200TOP_DEBUG is not set
+# CONFIG_IWMC3200TOP_DEBUGFS is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=m
+CONFIG_SCSI_NETLINK=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=m
+CONFIG_SCSI_ENCLOSURE=m
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_FC_TGT_ATTRS=y
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+CONFIG_SCSI_SAS_LIBSAS=m
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_SAS_HOST_SMP=y
+CONFIG_SCSI_SRP_ATTRS=m
+CONFIG_SCSI_SRP_TGT_ATTRS=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_ISCSI_TCP=m
+CONFIG_ISCSI_BOOT_SYSFS=m
+CONFIG_SCSI_CXGB3_ISCSI=m
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+CONFIG_SCSI_BNX2_ISCSI=m
+# CONFIG_SCSI_BNX2X_FCOE is not set
+CONFIG_BE2ISCSI=m
+CONFIG_BLK_DEV_3W_XXXX_RAID=m
+# CONFIG_SCSI_HPSA is not set
+CONFIG_SCSI_3W_9XXX=m
+# CONFIG_SCSI_3W_SAS is not set
+CONFIG_SCSI_ACARD=m
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=8
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+CONFIG_AIC7XXX_DEBUG_ENABLE=y
+CONFIG_AIC7XXX_DEBUG_MASK=0
+CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+CONFIG_SCSI_AIC79XX=m
+CONFIG_AIC79XX_CMDS_PER_DEVICE=32
+CONFIG_AIC79XX_RESET_DELAY_MS=5000
+CONFIG_AIC79XX_DEBUG_ENABLE=y
+CONFIG_AIC79XX_DEBUG_MASK=0
+CONFIG_AIC79XX_REG_PRETTY_PRINT=y
+CONFIG_SCSI_AIC94XX=m
+# CONFIG_AIC94XX_DEBUG is not set
+CONFIG_SCSI_MVSAS=m
+CONFIG_SCSI_MVSAS_DEBUG=y
+# CONFIG_SCSI_MVSAS_TASKLET is not set
+# CONFIG_SCSI_MVUMI is not set
+CONFIG_SCSI_DPT_I2O=m
+CONFIG_SCSI_ADVANSYS=m
+CONFIG_SCSI_ARCMSR=m
+CONFIG_MEGARAID_NEWGEN=y
+CONFIG_MEGARAID_MM=m
+CONFIG_MEGARAID_MAILBOX=m
+CONFIG_MEGARAID_LEGACY=m
+CONFIG_MEGARAID_SAS=m
+CONFIG_SCSI_MPT2SAS=m
+CONFIG_SCSI_MPT2SAS_MAX_SGE=128
+# CONFIG_SCSI_MPT2SAS_LOGGING is not set
+CONFIG_SCSI_HPTIOP=m
+CONFIG_SCSI_BUSLOGIC=m
+CONFIG_VMWARE_PVSCSI=m
+CONFIG_LIBFC=m
+CONFIG_LIBFCOE=m
+CONFIG_FCOE=m
+CONFIG_FCOE_FNIC=m
+CONFIG_SCSI_DMX3191D=m
+CONFIG_SCSI_EATA=m
+CONFIG_SCSI_EATA_TAGGED_QUEUE=y
+CONFIG_SCSI_EATA_LINKED_COMMANDS=y
+CONFIG_SCSI_EATA_MAX_TAGS=16
+CONFIG_SCSI_FUTURE_DOMAIN=m
+CONFIG_SCSI_GDTH=m
+# CONFIG_SCSI_ISCI is not set
+CONFIG_SCSI_IPS=m
+CONFIG_SCSI_INITIO=m
+CONFIG_SCSI_INIA100=m
+CONFIG_SCSI_STEX=m
+CONFIG_SCSI_SYM53C8XX_2=m
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+CONFIG_SCSI_SYM53C8XX_MMIO=y
+CONFIG_SCSI_IPR=m
+# CONFIG_SCSI_IPR_TRACE is not set
+# CONFIG_SCSI_IPR_DUMP is not set
+CONFIG_SCSI_QLOGIC_1280=m
+CONFIG_SCSI_QLA_FC=m
+CONFIG_SCSI_QLA_ISCSI=m
+CONFIG_SCSI_LPFC=m
+CONFIG_SCSI_LPFC_DEBUG_FS=y
+CONFIG_SCSI_DC395x=m
+CONFIG_SCSI_DC390T=m
+CONFIG_SCSI_DEBUG=m
+CONFIG_SCSI_PMCRAID=m
+# CONFIG_SCSI_PM8001 is not set
+CONFIG_SCSI_SRP=m
+CONFIG_SCSI_BFA_FC=m
+CONFIG_SCSI_DH=y
+CONFIG_SCSI_DH_RDAC=m
+CONFIG_SCSI_DH_HP_SW=m
+CONFIG_SCSI_DH_EMC=m
+CONFIG_SCSI_DH_ALUA=m
+CONFIG_SCSI_OSD_INITIATOR=m
+CONFIG_SCSI_OSD_ULD=m
+CONFIG_SCSI_OSD_DPRINT_SENSE=1
+# CONFIG_SCSI_OSD_DEBUG is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+CONFIG_SATA_INIC162X=m
+# CONFIG_SATA_ACARD_AHCI is not set
+CONFIG_SATA_SIL24=m
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+CONFIG_PDC_ADMA=y
+CONFIG_SATA_QSTOR=m
+CONFIG_SATA_SX4=m
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+CONFIG_ATA_PIIX=y
+CONFIG_SATA_MV=m
+CONFIG_SATA_NV=m
+CONFIG_SATA_PROMISE=m
+CONFIG_SATA_SIL=m
+CONFIG_SATA_SIS=m
+CONFIG_SATA_SVW=m
+CONFIG_SATA_ULI=m
+CONFIG_SATA_VIA=m
+CONFIG_SATA_VITESSE=m
+
+#
+# PATA SFF controllers with BMDMA
+#
+CONFIG_PATA_ALI=m
+CONFIG_PATA_AMD=m
+# CONFIG_PATA_ARASAN_CF is not set
+CONFIG_PATA_ARTOP=m
+CONFIG_PATA_ATIIXP=m
+CONFIG_PATA_ATP867X=m
+CONFIG_PATA_CMD64X=m
+CONFIG_PATA_CS5520=m
+CONFIG_PATA_CS5530=m
+# CONFIG_PATA_CS5536 is not set
+CONFIG_PATA_CYPRESS=m
+CONFIG_PATA_EFAR=m
+CONFIG_PATA_HPT366=m
+CONFIG_PATA_HPT37X=m
+CONFIG_PATA_HPT3X2N=m
+CONFIG_PATA_HPT3X3=m
+# CONFIG_PATA_HPT3X3_DMA is not set
+CONFIG_PATA_IT8213=m
+CONFIG_PATA_IT821X=m
+CONFIG_PATA_JMICRON=m
+CONFIG_PATA_MARVELL=m
+CONFIG_PATA_NETCELL=m
+CONFIG_PATA_NINJA32=m
+CONFIG_PATA_NS87415=m
+CONFIG_PATA_OLDPIIX=m
+CONFIG_PATA_OPTIDMA=m
+CONFIG_PATA_PDC2027X=m
+CONFIG_PATA_PDC_OLD=m
+CONFIG_PATA_RADISYS=m
+CONFIG_PATA_RDC=m
+CONFIG_PATA_SC1200=m
+CONFIG_PATA_SCH=m
+CONFIG_PATA_SERVERWORKS=m
+CONFIG_PATA_SIL680=m
+CONFIG_PATA_SIS=y
+# CONFIG_PATA_TOSHIBA is not set
+CONFIG_PATA_TRIFLEX=m
+CONFIG_PATA_VIA=m
+CONFIG_PATA_WINBOND=m
+
+#
+# PIO-only SFF controllers
+#
+CONFIG_PATA_CMD640_PCI=m
+CONFIG_PATA_MPIIX=m
+CONFIG_PATA_NS87410=m
+CONFIG_PATA_OPTI=m
+CONFIG_PATA_RZ1000=m
+
+#
+# Generic fallback / legacy drivers
+#
+CONFIG_PATA_ACPI=y
+CONFIG_ATA_GENERIC=y
+# CONFIG_PATA_LEGACY is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_AUTODETECT=y
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID456=m
+# CONFIG_MULTICORE_RAID456 is not set
+CONFIG_MD_MULTIPATH=m
+CONFIG_MD_FAULTY=m
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=y
+# CONFIG_DM_THIN_PROVISIONING is not set
+CONFIG_DM_MIRROR=y
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=y
+CONFIG_DM_MULTIPATH_QL=m
+CONFIG_DM_MULTIPATH_ST=m
+# CONFIG_DM_DELAY is not set
+CONFIG_DM_UEVENT=y
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+CONFIG_FIREWIRE=m
+CONFIG_FIREWIRE_OHCI=m
+CONFIG_FIREWIRE_OHCI_DEBUG=y
+CONFIG_FIREWIRE_SBP2=m
+CONFIG_FIREWIRE_NET=m
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+CONFIG_MACINTOSH_DRIVERS=y
+CONFIG_MAC_EMUMOUSEBTN=y
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+CONFIG_BONDING=m
+CONFIG_DUMMY=m
+CONFIG_EQUALIZER=m
+CONFIG_NET_FC=y
+CONFIG_MII=m
+CONFIG_IEEE802154_DRIVERS=m
+# CONFIG_IEEE802154_FAKEHARD is not set
+CONFIG_IFB=m
+CONFIG_MACVLAN=m
+# CONFIG_MACVTAP is not set
+CONFIG_NETCONSOLE=m
+CONFIG_NETCONSOLE_DYNAMIC=y
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_TUN=y
+CONFIG_VETH=m
+CONFIG_VIRTIO_NET=m
+CONFIG_SUNGEM_PHY=m
+CONFIG_ARCNET=m
+CONFIG_ARCNET_1201=m
+CONFIG_ARCNET_1051=m
+CONFIG_ARCNET_RAW=m
+CONFIG_ARCNET_CAP=m
+CONFIG_ARCNET_COM90xx=m
+CONFIG_ARCNET_COM90xxIO=m
+CONFIG_ARCNET_RIM_I=m
+CONFIG_ARCNET_COM20020=m
+CONFIG_ARCNET_COM20020_PCI=m
+CONFIG_ATM_DRIVERS=y
+# CONFIG_ATM_DUMMY is not set
+CONFIG_ATM_TCP=m
+CONFIG_ATM_LANAI=m
+CONFIG_ATM_ENI=m
+# CONFIG_ATM_ENI_DEBUG is not set
+# CONFIG_ATM_ENI_TUNE_BURST is not set
+CONFIG_ATM_FIRESTREAM=m
+CONFIG_ATM_ZATM=m
+# CONFIG_ATM_ZATM_DEBUG is not set
+# CONFIG_ATM_NICSTAR is not set
+CONFIG_ATM_IDT77252=m
+# CONFIG_ATM_IDT77252_DEBUG is not set
+# CONFIG_ATM_IDT77252_RCV_ALL is not set
+CONFIG_ATM_IDT77252_USE_SUNI=y
+CONFIG_ATM_AMBASSADOR=m
+# CONFIG_ATM_AMBASSADOR_DEBUG is not set
+CONFIG_ATM_HORIZON=m
+# CONFIG_ATM_HORIZON_DEBUG is not set
+CONFIG_ATM_IA=m
+# CONFIG_ATM_IA_DEBUG is not set
+CONFIG_ATM_FORE200E=m
+# CONFIG_ATM_FORE200E_USE_TASKLET is not set
+CONFIG_ATM_FORE200E_TX_RETRY=16
+CONFIG_ATM_FORE200E_DEBUG=0
+CONFIG_ATM_HE=m
+CONFIG_ATM_HE_USE_SUNI=y
+CONFIG_ATM_SOLOS=m
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_VORTEX=m
+CONFIG_TYPHOON=m
+CONFIG_NET_VENDOR_ADAPTEC=y
+CONFIG_ADAPTEC_STARFIRE=m
+CONFIG_NET_VENDOR_ALTEON=y
+CONFIG_ACENIC=m
+# CONFIG_ACENIC_OMIT_TIGON_I is not set
+CONFIG_NET_VENDOR_AMD=y
+CONFIG_AMD8111_ETH=m
+CONFIG_PCNET32=m
+CONFIG_NET_VENDOR_ATHEROS=y
+CONFIG_ATL2=m
+CONFIG_ATL1=m
+CONFIG_ATL1E=m
+CONFIG_ATL1C=m
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_B44=m
+CONFIG_B44_PCI_AUTOSELECT=y
+CONFIG_B44_PCICORE_AUTOSELECT=y
+CONFIG_B44_PCI=y
+CONFIG_BNX2=m
+CONFIG_CNIC=m
+CONFIG_TIGON3=m
+CONFIG_BNX2X=m
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_BNA is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+CONFIG_CHELSIO_T1=m
+CONFIG_CHELSIO_T1_1G=y
+CONFIG_CHELSIO_T3=m
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+CONFIG_NET_VENDOR_CISCO=y
+CONFIG_ENIC=m
+CONFIG_DNET=m
+CONFIG_NET_VENDOR_DEC=y
+CONFIG_NET_TULIP=y
+CONFIG_DE2104X=m
+CONFIG_DE2104X_DSL=0
+CONFIG_TULIP=m
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_TULIP_NAPI is not set
+CONFIG_DE4X5=m
+CONFIG_WINBOND_840=m
+CONFIG_DM9102=m
+CONFIG_ULI526X=m
+CONFIG_NET_VENDOR_DLINK=y
+# CONFIG_DL2K is not set
+CONFIG_SUNDANCE=m
+# CONFIG_SUNDANCE_MMIO is not set
+CONFIG_NET_VENDOR_EMULEX=y
+CONFIG_BE2NET=m
+CONFIG_NET_VENDOR_EXAR=y
+CONFIG_S2IO=m
+CONFIG_VXGE=m
+# CONFIG_VXGE_DEBUG_TRACE_ALL is not set
+CONFIG_NET_VENDOR_HP=y
+CONFIG_HP100=m
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_E100=m
+CONFIG_E1000=m
+CONFIG_E1000E=m
+CONFIG_IGB=m
+CONFIG_IGB_DCA=y
+CONFIG_IGBVF=m
+CONFIG_IXGB=m
+CONFIG_IXGBE=m
+CONFIG_IXGBE_DCA=y
+CONFIG_IXGBE_DCB=y
+# CONFIG_IXGBEVF is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_ZNET is not set
+CONFIG_IP1000=m
+CONFIG_JME=m
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_SKGE=m
+# CONFIG_SKGE_DEBUG is not set
+# CONFIG_SKGE_GENESIS is not set
+CONFIG_SKY2=m
+# CONFIG_SKY2_DEBUG is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_MLX4_EN=m
+CONFIG_MLX4_CORE=m
+CONFIG_MLX4_DEBUG=y
+CONFIG_NET_VENDOR_MICREL=y
+CONFIG_KS8842=m
+CONFIG_KS8851=m
+CONFIG_KS8851_MLL=m
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+CONFIG_NET_VENDOR_MYRI=y
+CONFIG_MYRI10GE=m
+CONFIG_MYRI10GE_DCA=y
+CONFIG_FEALNX=m
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NATSEMI=m
+CONFIG_NS83820=m
+CONFIG_NET_VENDOR_8390=y
+CONFIG_NE2K_PCI=m
+CONFIG_NET_VENDOR_NVIDIA=y
+CONFIG_FORCEDETH=m
+CONFIG_NET_VENDOR_OKI=y
+# CONFIG_PCH_GBE is not set
+CONFIG_ETHOC=m
+CONFIG_NET_PACKET_ENGINE=y
+CONFIG_HAMACHI=m
+CONFIG_YELLOWFIN=m
+CONFIG_NET_VENDOR_QLOGIC=y
+CONFIG_QLA3XXX=m
+# CONFIG_QLCNIC is not set
+CONFIG_QLGE=m
+CONFIG_NETXEN_NIC=m
+CONFIG_NET_VENDOR_REALTEK=y
+CONFIG_8139CP=m
+CONFIG_8139TOO=m
+CONFIG_8139TOO_PIO=y
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+CONFIG_8139TOO_8129=y
+# CONFIG_8139_OLD_RX_RESET is not set
+CONFIG_R8169=m
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_R6040 is not set
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_VENDOR_SILAN=y
+CONFIG_SC92031=m
+CONFIG_NET_VENDOR_SIS=y
+CONFIG_SIS900=m
+CONFIG_SIS190=m
+CONFIG_SFC=m
+CONFIG_SFC_MTD=y
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_EPIC100=m
+CONFIG_SMSC9420=m
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_SUN=y
+CONFIG_HAPPYMEAL=m
+CONFIG_SUNGEM=m
+CONFIG_CASSINI=m
+CONFIG_NIU=m
+CONFIG_NET_VENDOR_TEHUTI=y
+CONFIG_TEHUTI=m
+CONFIG_NET_VENDOR_TI=y
+CONFIG_TLAN=m
+CONFIG_NET_VENDOR_VIA=y
+CONFIG_VIA_RHINE=m
+CONFIG_VIA_RHINE_MMIO=y
+CONFIG_VIA_VELOCITY=m
+CONFIG_FDDI=y
+CONFIG_DEFXX=m
+# CONFIG_DEFXX_MMIO is not set
+CONFIG_SKFP=m
+CONFIG_HIPPI=y
+CONFIG_ROADRUNNER=m
+# CONFIG_ROADRUNNER_LARGE_RINGS is not set
+CONFIG_NET_SB1000=m
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_BROADCOM_PHY=y
+CONFIG_ICPLUS_PHY=y
+CONFIG_REALTEK_PHY=y
+CONFIG_NATIONAL_PHY=y
+CONFIG_STE10XP=y
+CONFIG_LSI_ET1011C_PHY=y
+# CONFIG_MICREL_PHY is not set
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_GPIO=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOATM=m
+CONFIG_PPPOE=m
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_SLIP=m
+CONFIG_SLHC=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+CONFIG_SLIP_MODE_SLIP6=y
+CONFIG_TR=y
+CONFIG_IBMOL=m
+CONFIG_3C359=m
+CONFIG_TMS380TR=m
+CONFIG_TMSPCI=m
+CONFIG_ABYSS=m
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_USB_NET_CDC_NCM=m
+CONFIG_USB_NET_DM9601=m
+# CONFIG_USB_NET_SMSC75XX is not set
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_USB_EPSON2888=y
+CONFIG_USB_KC2190=y
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+CONFIG_USB_HSO=m
+CONFIG_USB_NET_INT51X1=m
+CONFIG_USB_CDC_PHONET=m
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
+CONFIG_WLAN=y
+CONFIG_AIRO=m
+CONFIG_ATMEL=m
+CONFIG_PCI_ATMEL=m
+CONFIG_PRISM54=m
+CONFIG_USB_ZD1201=m
+CONFIG_HOSTAP=m
+CONFIG_HOSTAP_FIRMWARE=y
+CONFIG_HOSTAP_FIRMWARE_NVRAM=y
+CONFIG_HOSTAP_PLX=m
+CONFIG_HOSTAP_PCI=m
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+CONFIG_WAN=y
+CONFIG_LANMEDIA=m
+CONFIG_HDLC=m
+CONFIG_HDLC_RAW=m
+CONFIG_HDLC_RAW_ETH=m
+CONFIG_HDLC_CISCO=m
+CONFIG_HDLC_FR=m
+CONFIG_HDLC_PPP=m
+CONFIG_HDLC_X25=m
+CONFIG_PCI200SYN=m
+CONFIG_WANXL=m
+# CONFIG_PC300TOO is not set
+CONFIG_FARSYNC=m
+CONFIG_DSCC4=m
+CONFIG_DSCC4_PCISYNC=y
+CONFIG_DSCC4_PCI_RST=y
+CONFIG_DLCI=m
+CONFIG_DLCI_MAX=8
+CONFIG_WAN_ROUTER_DRIVERS=m
+CONFIG_CYCLADES_SYNC=m
+CONFIG_CYCLOMX_X25=y
+CONFIG_LAPBETHER=m
+CONFIG_X25_ASY=m
+CONFIG_SBNI=m
+# CONFIG_SBNI_MULTILINE is not set
+CONFIG_VMXNET3=m
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=m
+CONFIG_INPUT_POLLDEV=m
+CONFIG_INPUT_SPARSEKMAP=m
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ADP5588=m
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+CONFIG_KEYBOARD_LKKBD=m
+CONFIG_KEYBOARD_GPIO=m
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+CONFIG_KEYBOARD_MATRIX=m
+CONFIG_KEYBOARD_LM8323=m
+CONFIG_KEYBOARD_MAX7359=m
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+CONFIG_KEYBOARD_NEWTON=m
+CONFIG_KEYBOARD_OPENCORES=m
+CONFIG_KEYBOARD_STOWAWAY=m
+CONFIG_KEYBOARD_SUNKBD=m
+CONFIG_KEYBOARD_TWL4030=m
+CONFIG_KEYBOARD_XTKBD=m
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_MOUSE_PS2_SENTELIC=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_SERIAL=m
+CONFIG_MOUSE_APPLETOUCH=m
+CONFIG_MOUSE_BCM5974=m
+CONFIG_MOUSE_VSXXXAA=m
+CONFIG_MOUSE_GPIO=m
+CONFIG_MOUSE_SYNAPTICS_I2C=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_ANALOG=m
+CONFIG_JOYSTICK_A3D=m
+CONFIG_JOYSTICK_ADI=m
+CONFIG_JOYSTICK_COBRA=m
+CONFIG_JOYSTICK_GF2K=m
+CONFIG_JOYSTICK_GRIP=m
+CONFIG_JOYSTICK_GRIP_MP=m
+CONFIG_JOYSTICK_GUILLEMOT=m
+CONFIG_JOYSTICK_INTERACT=m
+CONFIG_JOYSTICK_SIDEWINDER=m
+CONFIG_JOYSTICK_TMDC=m
+CONFIG_JOYSTICK_IFORCE=m
+CONFIG_JOYSTICK_IFORCE_USB=y
+CONFIG_JOYSTICK_IFORCE_232=y
+CONFIG_JOYSTICK_WARRIOR=m
+CONFIG_JOYSTICK_MAGELLAN=m
+CONFIG_JOYSTICK_SPACEORB=m
+CONFIG_JOYSTICK_SPACEBALL=m
+CONFIG_JOYSTICK_STINGER=m
+CONFIG_JOYSTICK_TWIDJOY=m
+CONFIG_JOYSTICK_ZHENHUA=m
+# CONFIG_JOYSTICK_AS5011 is not set
+CONFIG_JOYSTICK_JOYDUMP=m
+CONFIG_JOYSTICK_XPAD=m
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=m
+CONFIG_TABLET_USB_AIPTEK=m
+CONFIG_TABLET_USB_GTCO=m
+# CONFIG_TABLET_USB_HANWANG is not set
+CONFIG_TABLET_USB_KBTAB=m
+CONFIG_TABLET_USB_WACOM=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=m
+CONFIG_TOUCHSCREEN_AD7877=m
+CONFIG_TOUCHSCREEN_AD7879=m
+CONFIG_TOUCHSCREEN_AD7879_I2C=m
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+CONFIG_TOUCHSCREEN_DA9034=m
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+CONFIG_TOUCHSCREEN_EETI=m
+CONFIG_TOUCHSCREEN_FUJITSU=m
+CONFIG_TOUCHSCREEN_GUNZE=m
+CONFIG_TOUCHSCREEN_ELO=m
+CONFIG_TOUCHSCREEN_WACOM_W8001=m
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+CONFIG_TOUCHSCREEN_MCS5000=m
+CONFIG_TOUCHSCREEN_MTOUCH=m
+CONFIG_TOUCHSCREEN_INEXIO=m
+CONFIG_TOUCHSCREEN_MK712=m
+CONFIG_TOUCHSCREEN_PENMOUNT=m
+CONFIG_TOUCHSCREEN_TOUCHRIGHT=m
+CONFIG_TOUCHSCREEN_TOUCHWIN=m
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=m
+CONFIG_TOUCHSCREEN_USB_EGALAX=y
+CONFIG_TOUCHSCREEN_USB_PANJIT=y
+CONFIG_TOUCHSCREEN_USB_3M=y
+CONFIG_TOUCHSCREEN_USB_ITM=y
+CONFIG_TOUCHSCREEN_USB_ETURBO=y
+CONFIG_TOUCHSCREEN_USB_GUNZE=y
+CONFIG_TOUCHSCREEN_USB_DMC_TSC10=y
+CONFIG_TOUCHSCREEN_USB_IRTOUCH=y
+CONFIG_TOUCHSCREEN_USB_IDEALTEK=y
+CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH=y
+CONFIG_TOUCHSCREEN_USB_GOTOP=y
+CONFIG_TOUCHSCREEN_USB_JASTEC=y
+CONFIG_TOUCHSCREEN_USB_E2I=y
+CONFIG_TOUCHSCREEN_USB_ZYTRONIC=y
+CONFIG_TOUCHSCREEN_USB_ETT_TC45USB=y
+CONFIG_TOUCHSCREEN_USB_NEXIO=y
+CONFIG_TOUCHSCREEN_TOUCHIT213=m
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+CONFIG_TOUCHSCREEN_TSC2007=m
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+CONFIG_INPUT_PCSPKR=m
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_APANEL is not set
+CONFIG_INPUT_ATLAS_BTNS=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+# CONFIG_INPUT_KXTJ9 is not set
+CONFIG_INPUT_POWERMATE=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_CM109=m
+CONFIG_INPUT_TWL4030_PWRBUTTON=m
+# CONFIG_INPUT_TWL4030_VIBRA is not set
+# CONFIG_INPUT_TWL6040_VIBRA is not set
+CONFIG_INPUT_UINPUT=m
+CONFIG_INPUT_PCF50633_PMU=m
+# CONFIG_INPUT_PCF8574 is not set
+CONFIG_INPUT_GPIO_ROTARY_ENCODER=m
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=m
+CONFIG_SERIO_CT82C710=m
+CONFIG_SERIO_PCIPS2=m
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+CONFIG_GAMEPORT=m
+CONFIG_GAMEPORT_NS558=m
+CONFIG_GAMEPORT_L4=m
+CONFIG_GAMEPORT_EMU10K1=m
+CONFIG_GAMEPORT_FM801=m
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=0
+CONFIG_SERIAL_NONSTANDARD=y
+CONFIG_ROCKETPORT=m
+CONFIG_CYCLADES=m
+# CONFIG_CYZ_INTR is not set
+CONFIG_MOXA_INTELLIO=m
+CONFIG_MOXA_SMARTIO=m
+CONFIG_SYNCLINK=m
+CONFIG_SYNCLINKMP=m
+CONFIG_SYNCLINK_GT=m
+CONFIG_NOZOMI=m
+# CONFIG_ISI is not set
+CONFIG_N_HDLC=m
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_STALDRV=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_NR_UARTS=48
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MAX3100=m
+# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_CONSOLE_POLL=y
+CONFIG_SERIAL_JSM=m
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+CONFIG_HVC_DRIVER=y
+CONFIG_VIRTIO_CONSOLE=m
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_TIMERIOMEM=m
+CONFIG_HW_RANDOM_INTEL=m
+CONFIG_HW_RANDOM_AMD=m
+CONFIG_HW_RANDOM_VIA=m
+CONFIG_HW_RANDOM_VIRTIO=m
+CONFIG_NVRAM=m
+CONFIG_R3964=m
+CONFIG_APPLICOM=m
+CONFIG_MWAVE=m
+CONFIG_RAW_DRIVER=m
+CONFIG_MAX_RAW_DEVS=256
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HANGCHECK_TIMER=m
+CONFIG_TCG_TPM=m
+CONFIG_TCG_TIS=m
+CONFIG_TCG_NSC=m
+CONFIG_TCG_ATMEL=m
+CONFIG_TCG_INFINEON=m
+CONFIG_TELCLOCK=m
+CONFIG_DEVPORT=y
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=m
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_SMBUS=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+CONFIG_I2C_ALI1535=m
+CONFIG_I2C_ALI1563=m
+CONFIG_I2C_ALI15X3=m
+CONFIG_I2C_AMD756=m
+CONFIG_I2C_AMD756_S4882=m
+CONFIG_I2C_AMD8111=m
+CONFIG_I2C_I801=m
+CONFIG_I2C_ISCH=m
+CONFIG_I2C_PIIX4=m
+CONFIG_I2C_NFORCE2=m
+CONFIG_I2C_NFORCE2_S4985=m
+CONFIG_I2C_SIS5595=m
+CONFIG_I2C_SIS630=m
+CONFIG_I2C_SIS96X=m
+CONFIG_I2C_VIA=m
+CONFIG_I2C_VIAPRO=m
+
+#
+# ACPI drivers
+#
+CONFIG_I2C_SCMI=m
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+CONFIG_I2C_GPIO=m
+# CONFIG_I2C_INTEL_MID is not set
+CONFIG_I2C_OCORES=m
+CONFIG_I2C_PCA_PLATFORM=m
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_I2C_SIMTEC=m
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I2C_EG20T is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+CONFIG_I2C_PARPORT_LIGHT=m
+CONFIG_I2C_TAOS_EVM=m
+CONFIG_I2C_TINY_USB=m
+
+#
+# Other I2C/SMBus bus drivers
+#
+CONFIG_I2C_STUB=m
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=m
+CONFIG_SPI_GPIO=m
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPI_TLE62X0=m
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_MAX730X=m
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_SCH is not set
+# CONFIG_GPIO_VX855 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+CONFIG_GPIO_MAX732X=m
+CONFIG_GPIO_PCA953X=m
+CONFIG_GPIO_PCF857X=m
+# CONFIG_GPIO_SX150X is not set
+CONFIG_GPIO_TWL4030=m
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+CONFIG_GPIO_LANGWELL=y
+# CONFIG_GPIO_PCH is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+
+#
+# SPI GPIO expanders:
+#
+CONFIG_GPIO_MAX7301=m
+CONFIG_GPIO_MCP23S08=m
+CONFIG_GPIO_MC33880=m
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+CONFIG_PDA_POWER=m
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+CONFIG_BATTERY_DS2782=m
+# CONFIG_BATTERY_BQ20Z75 is not set
+CONFIG_BATTERY_BQ27x00=m
+CONFIG_BATTERY_BQ27X00_I2C=y
+CONFIG_BATTERY_BQ27X00_PLATFORM=y
+CONFIG_BATTERY_DA9030=m
+CONFIG_BATTERY_MAX17040=m
+# CONFIG_BATTERY_MAX17042 is not set
+CONFIG_CHARGER_PCF50633=m
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_TWL4030 is not set
+# CONFIG_CHARGER_GPIO is not set
+CONFIG_HWMON=y
+CONFIG_HWMON_VID=m
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+CONFIG_SENSORS_ABITUGURU=m
+CONFIG_SENSORS_ABITUGURU3=m
+# CONFIG_SENSORS_AD7314 is not set
+CONFIG_SENSORS_AD7414=m
+CONFIG_SENSORS_AD7418=m
+CONFIG_SENSORS_ADCXX=m
+CONFIG_SENSORS_ADM1021=m
+CONFIG_SENSORS_ADM1025=m
+CONFIG_SENSORS_ADM1026=m
+CONFIG_SENSORS_ADM1029=m
+CONFIG_SENSORS_ADM1031=m
+CONFIG_SENSORS_ADM9240=m
+# CONFIG_SENSORS_ADT7411 is not set
+CONFIG_SENSORS_ADT7462=m
+CONFIG_SENSORS_ADT7470=m
+CONFIG_SENSORS_ADT7475=m
+# CONFIG_SENSORS_ASC7621 is not set
+CONFIG_SENSORS_K8TEMP=m
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+CONFIG_SENSORS_ASB100=m
+CONFIG_SENSORS_ATXP1=m
+# CONFIG_SENSORS_DS620 is not set
+CONFIG_SENSORS_DS1621=m
+CONFIG_SENSORS_I5K_AMB=m
+CONFIG_SENSORS_F71805F=m
+CONFIG_SENSORS_F71882FG=m
+CONFIG_SENSORS_F75375S=m
+CONFIG_SENSORS_FSCHMD=m
+CONFIG_SENSORS_G760A=m
+CONFIG_SENSORS_GL518SM=m
+CONFIG_SENSORS_GL520SM=m
+# CONFIG_SENSORS_GPIO_FAN is not set
+CONFIG_SENSORS_CORETEMP=m
+CONFIG_SENSORS_IBMAEM=m
+CONFIG_SENSORS_IBMPEX=m
+CONFIG_SENSORS_IT87=m
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+CONFIG_SENSORS_LM63=m
+CONFIG_SENSORS_LM70=m
+# CONFIG_SENSORS_LM73 is not set
+CONFIG_SENSORS_LM75=m
+CONFIG_SENSORS_LM77=m
+CONFIG_SENSORS_LM78=m
+CONFIG_SENSORS_LM80=m
+CONFIG_SENSORS_LM83=m
+CONFIG_SENSORS_LM85=m
+CONFIG_SENSORS_LM87=m
+CONFIG_SENSORS_LM90=m
+CONFIG_SENSORS_LM92=m
+CONFIG_SENSORS_LM93=m
+# CONFIG_SENSORS_LTC4151 is not set
+CONFIG_SENSORS_LTC4215=m
+CONFIG_SENSORS_LTC4245=m
+# CONFIG_SENSORS_LTC4261 is not set
+CONFIG_SENSORS_LM95241=m
+# CONFIG_SENSORS_LM95245 is not set
+CONFIG_SENSORS_MAX1111=m
+# CONFIG_SENSORS_MAX16065 is not set
+CONFIG_SENSORS_MAX1619=m
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+CONFIG_SENSORS_MAX6650=m
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+CONFIG_SENSORS_PC87360=m
+CONFIG_SENSORS_PC87427=m
+CONFIG_SENSORS_PCF8591=m
+# CONFIG_PMBUS is not set
+CONFIG_SENSORS_SHT15=m
+# CONFIG_SENSORS_SHT21 is not set
+CONFIG_SENSORS_SIS5595=m
+# CONFIG_SENSORS_SMM665 is not set
+CONFIG_SENSORS_DME1737=m
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+CONFIG_SENSORS_SMSC47M1=m
+CONFIG_SENSORS_SMSC47M192=m
+CONFIG_SENSORS_SMSC47B397=m
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+CONFIG_SENSORS_ADS7828=m
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+CONFIG_SENSORS_THMC50=m
+# CONFIG_SENSORS_TMP102 is not set
+CONFIG_SENSORS_TMP401=m
+CONFIG_SENSORS_TMP421=m
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+CONFIG_SENSORS_VIA686A=m
+CONFIG_SENSORS_VT1211=m
+CONFIG_SENSORS_VT8231=m
+CONFIG_SENSORS_W83781D=m
+CONFIG_SENSORS_W83791D=m
+CONFIG_SENSORS_W83792D=m
+CONFIG_SENSORS_W83793=m
+# CONFIG_SENSORS_W83795 is not set
+CONFIG_SENSORS_W83L785TS=m
+CONFIG_SENSORS_W83L786NG=m
+CONFIG_SENSORS_W83627HF=m
+CONFIG_SENSORS_W83627EHF=m
+CONFIG_SENSORS_APPLESMC=m
+
+#
+# ACPI drivers
+#
+# CONFIG_SENSORS_ACPI_POWER is not set
+CONFIG_SENSORS_ATK0110=m
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=m
+CONFIG_TWL4030_WATCHDOG=m
+CONFIG_ACQUIRE_WDT=m
+CONFIG_ADVANTECH_WDT=m
+CONFIG_ALIM1535_WDT=m
+CONFIG_ALIM7101_WDT=m
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+CONFIG_SC520_WDT=m
+CONFIG_SBC_FITPC2_WATCHDOG=m
+CONFIG_EUROTECH_WDT=m
+CONFIG_IB700_WDT=m
+CONFIG_IBMASR=m
+CONFIG_WAFER_WDT=m
+CONFIG_I6300ESB_WDT=m
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+CONFIG_IT8712F_WDT=m
+CONFIG_IT87_WDT=m
+# CONFIG_HP_WATCHDOG is not set
+CONFIG_SC1200_WDT=m
+CONFIG_PC87413_WDT=m
+# CONFIG_NV_TCO is not set
+CONFIG_60XX_WDT=m
+CONFIG_SBC8360_WDT=m
+CONFIG_CPU5_WDT=m
+CONFIG_SMSC_SCH311X_WDT=m
+CONFIG_SMSC37B787_WDT=m
+CONFIG_W83627HF_WDT=m
+CONFIG_W83697HF_WDT=m
+CONFIG_W83697UG_WDT=m
+CONFIG_W83877F_WDT=m
+CONFIG_W83977F_WDT=m
+CONFIG_MACHZ_WDT=m
+CONFIG_SBC_EPX_C3_WATCHDOG=m
+
+#
+# PCI-based Watchdog Cards
+#
+CONFIG_PCIPCWATCHDOG=m
+CONFIG_WDTPCI=m
+
+#
+# USB-based Watchdog Cards
+#
+CONFIG_USBPCWATCHDOG=m
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=m
+CONFIG_SSB_SPROM=y
+CONFIG_SSB_PCIHOST_POSSIBLE=y
+CONFIG_SSB_PCIHOST=y
+# CONFIG_SSB_B43_PCI_BRIDGE is not set
+CONFIG_SSB_SDIOHOST_POSSIBLE=y
+CONFIG_SSB_SDIOHOST=y
+# CONFIG_SSB_DEBUG is not set
+CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
+CONFIG_SSB_DRIVER_PCICORE=y
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=m
+# CONFIG_MFD_88PM860X is not set
+CONFIG_MFD_SM501=m
+# CONFIG_MFD_SM501_GPIO is not set
+CONFIG_HTC_PASIC3=m
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+CONFIG_TPS65010=m
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+CONFIG_TWL4030_CORE=y
+# CONFIG_TWL4030_MADC is not set
+# CONFIG_MFD_TWL4030_AUDIO is not set
+# CONFIG_TWL6030_PWM is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+CONFIG_PMIC_DA903X=y
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+CONFIG_MFD_WM8400=m
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+CONFIG_MFD_PCF50633=m
+CONFIG_PCF50633_ADC=m
+CONFIG_PCF50633_GPIO=m
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_TIMBERDALE is not set
+CONFIG_LPC_SCH=m
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+CONFIG_REGULATOR_VIRTUAL_CONSUMER=m
+CONFIG_REGULATOR_USERSPACE_CONSUMER=m
+# CONFIG_REGULATOR_GPIO is not set
+CONFIG_REGULATOR_BQ24022=m
+CONFIG_REGULATOR_MAX1586=m
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+CONFIG_REGULATOR_TWL4030=y
+CONFIG_REGULATOR_WM8400=m
+CONFIG_REGULATOR_DA903X=m
+CONFIG_REGULATOR_PCF50633=m
+CONFIG_REGULATOR_LP3971=m
+# CONFIG_REGULATOR_LP3972 is not set
+CONFIG_REGULATOR_TPS65023=m
+CONFIG_REGULATOR_TPS6507X=m
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=m
+CONFIG_AGP_SIS=m
+CONFIG_AGP_VIA=m
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+# CONFIG_VGA_SWITCHEROO is not set
+CONFIG_DRM=m
+CONFIG_DRM_KMS_HELPER=m
+CONFIG_DRM_TTM=m
+CONFIG_DRM_TDFX=m
+CONFIG_DRM_R128=m
+CONFIG_DRM_RADEON=m
+CONFIG_DRM_RADEON_KMS=y
+CONFIG_DRM_I810=m
+CONFIG_DRM_I915=m
+CONFIG_DRM_I915_KMS=y
+CONFIG_DRM_MGA=m
+CONFIG_DRM_SIS=m
+CONFIG_DRM_VIA=m
+CONFIG_DRM_SAVAGE=m
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_STUB_POULSBO is not set
+CONFIG_VGASTATE=m
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB_DDC=m
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=m
+CONFIG_FB_SYS_COPYAREA=m
+CONFIG_FB_SYS_IMAGEBLIT=m
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=m
+# CONFIG_FB_WMT_GE_ROPS is not set
+CONFIG_FB_DEFERRED_IO=y
+CONFIG_FB_HECUBA=m
+CONFIG_FB_SVGALIB=m
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_CIRRUS=m
+CONFIG_FB_PM2=m
+CONFIG_FB_PM2_FIFO_DISCONNECT=y
+CONFIG_FB_CYBER2000=m
+CONFIG_FB_CYBER2000_DDC=y
+CONFIG_FB_ARC=m
+CONFIG_FB_ASILIANT=y
+CONFIG_FB_IMSTT=y
+CONFIG_FB_VGA16=m
+CONFIG_FB_UVESA=m
+# CONFIG_FB_VESA is not set
+CONFIG_FB_EFI=y
+CONFIG_FB_N411=m
+CONFIG_FB_HGA=m
+CONFIG_FB_S1D13XXX=m
+CONFIG_FB_NVIDIA=m
+CONFIG_FB_NVIDIA_I2C=y
+# CONFIG_FB_NVIDIA_DEBUG is not set
+CONFIG_FB_NVIDIA_BACKLIGHT=y
+CONFIG_FB_RIVA=m
+CONFIG_FB_RIVA_I2C=y
+# CONFIG_FB_RIVA_DEBUG is not set
+CONFIG_FB_RIVA_BACKLIGHT=y
+CONFIG_FB_LE80578=m
+CONFIG_FB_CARILLO_RANCH=m
+CONFIG_FB_MATROX=m
+CONFIG_FB_MATROX_MILLENIUM=y
+CONFIG_FB_MATROX_MYSTIQUE=y
+CONFIG_FB_MATROX_G=y
+CONFIG_FB_MATROX_I2C=m
+CONFIG_FB_MATROX_MAVEN=m
+CONFIG_FB_RADEON=m
+CONFIG_FB_RADEON_I2C=y
+CONFIG_FB_RADEON_BACKLIGHT=y
+# CONFIG_FB_RADEON_DEBUG is not set
+CONFIG_FB_ATY128=m
+CONFIG_FB_ATY128_BACKLIGHT=y
+CONFIG_FB_ATY=m
+CONFIG_FB_ATY_CT=y
+CONFIG_FB_ATY_GENERIC_LCD=y
+CONFIG_FB_ATY_GX=y
+CONFIG_FB_ATY_BACKLIGHT=y
+CONFIG_FB_S3=m
+CONFIG_FB_S3_DDC=y
+CONFIG_FB_SAVAGE=m
+CONFIG_FB_SAVAGE_I2C=y
+CONFIG_FB_SAVAGE_ACCEL=y
+CONFIG_FB_SIS=m
+CONFIG_FB_SIS_300=y
+CONFIG_FB_SIS_315=y
+CONFIG_FB_VIA=m
+# CONFIG_FB_VIA_DIRECT_PROCFS is not set
+# CONFIG_FB_VIA_X_COMPATIBILITY is not set
+CONFIG_FB_NEOMAGIC=m
+CONFIG_FB_KYRO=m
+CONFIG_FB_3DFX=m
+# CONFIG_FB_3DFX_ACCEL is not set
+CONFIG_FB_3DFX_I2C=y
+CONFIG_FB_VOODOO1=m
+CONFIG_FB_VT8623=m
+CONFIG_FB_TRIDENT=m
+CONFIG_FB_ARK=m
+CONFIG_FB_PM3=m
+CONFIG_FB_CARMINE=m
+CONFIG_FB_CARMINE_DRAM_EVAL=y
+# CONFIG_CARMINE_DRAM_CUSTOM is not set
+CONFIG_FB_GEODE=y
+CONFIG_FB_GEODE_LX=m
+CONFIG_FB_GEODE_GX=m
+CONFIG_FB_GEODE_GX1=m
+CONFIG_FB_TMIO=m
+CONFIG_FB_TMIO_ACCELL=y
+CONFIG_FB_SM501=m
+# CONFIG_FB_SMSCUFX is not set
+CONFIG_FB_UDL=m
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FB_METRONOME=m
+CONFIG_FB_MB862XX=m
+CONFIG_FB_MB862XX_PCI_GDC=y
+CONFIG_FB_MB862XX_I2C=y
+CONFIG_FB_BROADSHEET=m
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_L4F00242T03 is not set
+CONFIG_LCD_LMS283GF05=m
+CONFIG_LCD_LTV350QV=m
+CONFIG_LCD_ILI9320=m
+CONFIG_LCD_TDO24M=m
+CONFIG_LCD_VGG2432A4=m
+CONFIG_LCD_PLATFORM=m
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=m
+CONFIG_BACKLIGHT_PROGEAR=m
+CONFIG_BACKLIGHT_CARILLO_RANCH=m
+CONFIG_BACKLIGHT_DA903X=m
+# CONFIG_BACKLIGHT_APPLE is not set
+CONFIG_BACKLIGHT_SAHARA=m
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_PCF50633 is not set
+
+#
+# Display device support
+#
+CONFIG_DISPLAY_SUPPORT=m
+
+#
+# Display hardware drivers
+#
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=m
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=m
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=m
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=m
+CONFIG_HID_BELKIN=m
+CONFIG_HID_CHERRY=m
+CONFIG_HID_CHICONY=m
+CONFIG_HID_CYPRESS=m
+CONFIG_HID_DRAGONRISE=m
+CONFIG_DRAGONRISE_FF=y
+# CONFIG_HID_EMS_FF is not set
+CONFIG_HID_EZKEY=m
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=m
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+CONFIG_HID_GYRATION=m
+CONFIG_HID_TWINHAN=m
+CONFIG_HID_KENSINGTON=m
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=m
+CONFIG_HID_LOGITECH_DJ=m
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+# CONFIG_LOGIG940_FF is not set
+CONFIG_LOGIWHEELS_FF=y
+CONFIG_HID_MICROSOFT=m
+CONFIG_HID_MONTEREY=m
+# CONFIG_HID_MULTITOUCH is not set
+CONFIG_HID_NTRIG=m
+CONFIG_HID_ORTEK=m
+CONFIG_HID_PANTHERLORD=m
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=m
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+CONFIG_HID_QUANTA=m
+# CONFIG_HID_ROCCAT is not set
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+# CONFIG_HID_SPEEDLINK is not set
+CONFIG_HID_SUNPLUS=m
+CONFIG_HID_GREENASIA=m
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=m
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=m
+CONFIG_HID_THRUSTMASTER=m
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_ZEROPLUS=m
+CONFIG_ZEROPLUS_FF=y
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_DWC3 is not set
+CONFIG_USB_MON=y
+CONFIG_USB_WUSB=m
+CONFIG_USB_WUSB_CBAF=m
+# CONFIG_USB_WUSB_CBAF_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_C67X00_HCD=m
+CONFIG_USB_XHCI_HCD=m
+# CONFIG_USB_XHCI_HCD_DEBUGGING is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_OXU210HP_HCD=m
+CONFIG_USB_ISP116X_HCD=m
+CONFIG_USB_ISP1760_HCD=m
+CONFIG_USB_ISP1362_HCD=m
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=y
+CONFIG_USB_U132_HCD=m
+CONFIG_USB_SL811_HCD=m
+# CONFIG_USB_SL811_HCD_ISO is not set
+CONFIG_USB_R8A66597_HCD=m
+CONFIG_USB_WHCI_HCD=m
+CONFIG_USB_HWA_HCD=m
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+CONFIG_USB_TMC=m
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_EZUSB=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_MOTOROLA=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+# CONFIG_USB_SERIAL_QCAUX is not set
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_USB_SERIAL_SAFE=m
+# CONFIG_USB_SERIAL_SAFE_PADDED is not set
+CONFIG_USB_SERIAL_SIEMENS_MPI=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_SYMBOL=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_WWAN=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_USB_SERIAL_OPTICON=m
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+CONFIG_USB_SERIAL_DEBUG=m
+
+#
+# USB Miscellaneous drivers
+#
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_SEVSEG=m
+CONFIG_USB_RIO500=m
+CONFIG_USB_LEGOTOWER=m
+CONFIG_USB_LCD=m
+CONFIG_USB_LED=m
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_CYTHERM=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_SISUSBVGA=m
+# CONFIG_USB_SISUSBVGA_CON is not set
+CONFIG_USB_LD=m
+CONFIG_USB_TRANCEVIBRATOR=m
+CONFIG_USB_IOWARRIOR=m
+CONFIG_USB_TEST=m
+CONFIG_USB_ISIGHTFW=m
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_ATM=m
+CONFIG_USB_SPEEDTOUCH=m
+CONFIG_USB_CXACRU=m
+CONFIG_USB_UEAGLEATM=m
+CONFIG_USB_XUSBATM=m
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_CI13XXX_PCI is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_EG20T is not set
+CONFIG_USB_DUMMY_HCD=m
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_SUPERSPEED=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_ETH_EEM is not set
+# CONFIG_USB_G_NCM is not set
+CONFIG_USB_GADGETFS=m
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_MASS_STORAGE is not set
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_G_PRINTER=m
+CONFIG_USB_CDC_COMPOSITE=m
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+CONFIG_USB_GPIO_VBUS=m
+CONFIG_TWL4030_USB=m
+# CONFIG_TWL6030_USB is not set
+CONFIG_NOP_USB_XCEIV=m
+CONFIG_UWB=m
+CONFIG_UWB_HWA=m
+CONFIG_UWB_WHCI=m
+CONFIG_UWB_I1480U=m
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=m
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_SDIO_UART=m
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_SDHCI_PCI=m
+# CONFIG_MMC_RICOH_MMC is not set
+CONFIG_MMC_SDHCI_PLTFM=m
+CONFIG_MMC_WBSD=m
+CONFIG_MMC_TIFM_SD=m
+CONFIG_MMC_SPI=m
+CONFIG_MMC_CB710=m
+CONFIG_MMC_VIA_SDMMC=m
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+CONFIG_LEDS_PCA9532=m
+# CONFIG_LEDS_PCA9532_GPIO is not set
+CONFIG_LEDS_GPIO=m
+CONFIG_LEDS_LP3944=m
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_CLEVO_MAIL is not set
+CONFIG_LEDS_PCA955X=m
+CONFIG_LEDS_DA903X=m
+CONFIG_LEDS_DAC124S085=m
+# CONFIG_LEDS_REGULATOR is not set
+CONFIG_LEDS_BD2802=m
+# CONFIG_LEDS_INTEL_SS4200 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_DELL_NETBOOKS=m
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=m
+CONFIG_LEDS_TRIGGER_HEARTBEAT=m
+CONFIG_LEDS_TRIGGER_BACKLIGHT=m
+CONFIG_LEDS_TRIGGER_GPIO=m
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=m
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC=y
+
+#
+# Reporting subsystems
+#
+# CONFIG_EDAC_DEBUG is not set
+CONFIG_EDAC_DECODE_MCE=m
+# CONFIG_EDAC_MCE_INJ is not set
+CONFIG_EDAC_MM_EDAC=m
+CONFIG_EDAC_AMD64=m
+# CONFIG_EDAC_AMD64_ERROR_INJECTION is not set
+CONFIG_EDAC_E752X=m
+CONFIG_EDAC_I82975X=m
+CONFIG_EDAC_I3000=m
+CONFIG_EDAC_I3200=m
+CONFIG_EDAC_X38=m
+CONFIG_EDAC_I5400=m
+# CONFIG_EDAC_I7CORE is not set
+CONFIG_EDAC_I5000=m
+CONFIG_EDAC_I5100=m
+# CONFIG_EDAC_I7300 is not set
+# CONFIG_EDAC_SBRIDGE is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+CONFIG_RTC_DRV_TEST=m
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=m
+CONFIG_RTC_DRV_DS1374=m
+CONFIG_RTC_DRV_DS1672=m
+# CONFIG_RTC_DRV_DS3232 is not set
+CONFIG_RTC_DRV_MAX6900=m
+CONFIG_RTC_DRV_RS5C372=m
+CONFIG_RTC_DRV_ISL1208=m
+# CONFIG_RTC_DRV_ISL12022 is not set
+CONFIG_RTC_DRV_X1205=m
+CONFIG_RTC_DRV_PCF8563=m
+CONFIG_RTC_DRV_PCF8583=m
+CONFIG_RTC_DRV_M41T80=m
+CONFIG_RTC_DRV_M41T80_WDT=y
+# CONFIG_RTC_DRV_BQ32K is not set
+CONFIG_RTC_DRV_TWL4030=m
+CONFIG_RTC_DRV_S35390A=m
+CONFIG_RTC_DRV_FM3130=m
+CONFIG_RTC_DRV_RX8581=m
+CONFIG_RTC_DRV_RX8025=m
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+CONFIG_RTC_DRV_M41T94=m
+CONFIG_RTC_DRV_DS1305=m
+CONFIG_RTC_DRV_DS1390=m
+CONFIG_RTC_DRV_MAX6902=m
+CONFIG_RTC_DRV_R9701=m
+CONFIG_RTC_DRV_RS5C348=m
+CONFIG_RTC_DRV_DS3234=m
+CONFIG_RTC_DRV_PCF2123=m
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+CONFIG_RTC_DRV_DS1286=m
+CONFIG_RTC_DRV_DS1511=m
+CONFIG_RTC_DRV_DS1553=m
+CONFIG_RTC_DRV_DS1742=m
+CONFIG_RTC_DRV_STK17TA8=m
+CONFIG_RTC_DRV_M48T86=m
+CONFIG_RTC_DRV_M48T35=m
+CONFIG_RTC_DRV_M48T59=m
+# CONFIG_RTC_DRV_MSM6242 is not set
+CONFIG_RTC_DRV_BQ4802=m
+# CONFIG_RTC_DRV_RP5C01 is not set
+CONFIG_RTC_DRV_V3020=m
+CONFIG_RTC_DRV_PCF50633=m
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+# CONFIG_INTEL_MID_DMAC is not set
+CONFIG_INTEL_IOATDMA=m
+# CONFIG_TIMB_DMA is not set
+# CONFIG_PCH_DMA is not set
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+CONFIG_NET_DMA=y
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+CONFIG_DCA=m
+CONFIG_AUXDISPLAY=y
+CONFIG_UIO=m
+CONFIG_UIO_CIF=m
+CONFIG_UIO_PDRV=m
+CONFIG_UIO_PDRV_GENIRQ=m
+CONFIG_UIO_AEC=m
+CONFIG_UIO_SERCOS3=m
+CONFIG_UIO_PCI_GENERIC=m
+# CONFIG_UIO_NETX is not set
+CONFIG_VIRTIO=m
+CONFIG_VIRTIO_RING=m
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=m
+CONFIG_VIRTIO_BALLOON=m
+# CONFIG_VIRTIO_MMIO is not set
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+CONFIG_ACER_WMI=m
+CONFIG_ACERHDF=m
+CONFIG_ASUS_LAPTOP=m
+CONFIG_DELL_WMI=m
+# CONFIG_DELL_WMI_AIO is not set
+CONFIG_FUJITSU_LAPTOP=m
+# CONFIG_FUJITSU_LAPTOP_DEBUG is not set
+# CONFIG_HP_ACCEL is not set
+CONFIG_HP_WMI=m
+CONFIG_MSI_LAPTOP=m
+CONFIG_PANASONIC_LAPTOP=m
+CONFIG_COMPAL_LAPTOP=m
+CONFIG_SONY_LAPTOP=m
+CONFIG_SONYPI_COMPAT=y
+# CONFIG_IDEAPAD_LAPTOP is not set
+CONFIG_THINKPAD_ACPI=m
+CONFIG_THINKPAD_ACPI_DEBUGFACILITIES=y
+# CONFIG_THINKPAD_ACPI_DEBUG is not set
+# CONFIG_THINKPAD_ACPI_UNSAFE_LEDS is not set
+CONFIG_THINKPAD_ACPI_VIDEO=y
+CONFIG_THINKPAD_ACPI_HOTKEY_POLL=y
+CONFIG_SENSORS_HDAPS=m
+CONFIG_INTEL_MENLOW=m
+CONFIG_EEEPC_LAPTOP=m
+# CONFIG_ASUS_WMI is not set
+CONFIG_ACPI_WMI=y
+# CONFIG_MSI_WMI is not set
+# CONFIG_ACPI_ASUS is not set
+CONFIG_TOPSTAR_LAPTOP=m
+CONFIG_ACPI_TOSHIBA=m
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_ACPI_CMPC is not set
+# CONFIG_INTEL_IPS is not set
+# CONFIG_IBM_RTL is not set
+# CONFIG_XO15_EBOOK is not set
+# CONFIG_SAMSUNG_LAPTOP is not set
+CONFIG_MXM_WMI=m
+# CONFIG_INTEL_OAKTRAIL is not set
+# CONFIG_SAMSUNG_Q10 is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_HYPERV is not set
+# CONFIG_PM_DEVFREQ is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=y
+CONFIG_EDD_OFF=y
+CONFIG_FIRMWARE_MEMMAP=y
+CONFIG_EFI_VARS=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+# CONFIG_DMI_SYSFS is not set
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_SIGMA is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=m
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=m
+CONFIG_QFMT_V1=m
+CONFIG_QFMT_V2=m
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=m
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+CONFIG_FSCACHE=m
+# CONFIG_FSCACHE_STATS is not set
+# CONFIG_FSCACHE_HISTOGRAM is not set
+# CONFIG_FSCACHE_DEBUG is not set
+# CONFIG_FSCACHE_OBJECT_LIST is not set
+CONFIG_CACHEFILES=m
+# CONFIG_CACHEFILES_DEBUG is not set
+# CONFIG_CACHEFILES_HISTOGRAM is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_ADFS_FS=m
+# CONFIG_ADFS_FS_RW is not set
+CONFIG_AFFS_FS=m
+CONFIG_ECRYPT_FS=y
+CONFIG_HFS_FS=m
+CONFIG_HFSPLUS_FS=m
+CONFIG_BEFS_FS=m
+# CONFIG_BEFS_DEBUG is not set
+CONFIG_BFS_FS=m
+CONFIG_EFS_FS=m
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_LZO=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+# CONFIG_JFFS2_CMODE_PRIORITY is not set
+# CONFIG_JFFS2_CMODE_SIZE is not set
+CONFIG_JFFS2_CMODE_FAVOURLZO=y
+CONFIG_UBIFS_FS=m
+CONFIG_UBIFS_FS_XATTR=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=m
+CONFIG_SQUASHFS=m
+# CONFIG_SQUASHFS_XATTR is not set
+CONFIG_SQUASHFS_ZLIB=y
+# CONFIG_SQUASHFS_LZO is not set
+# CONFIG_SQUASHFS_XZ is not set
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+CONFIG_VXFS_FS=m
+CONFIG_MINIX_FS=m
+CONFIG_OMFS_FS=m
+CONFIG_HPFS_FS=m
+CONFIG_QNX4FS_FS=m
+CONFIG_ROMFS_FS=m
+CONFIG_ROMFS_BACKED_BY_BLOCK=y
+# CONFIG_ROMFS_BACKED_BY_MTD is not set
+# CONFIG_ROMFS_BACKED_BY_BOTH is not set
+CONFIG_ROMFS_ON_BLOCK=y
+# CONFIG_PSTORE is not set
+CONFIG_SYSV_FS=m
+CONFIG_UFS_FS=m
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_UFS_DEBUG is not set
+CONFIG_EXOFS_FS=m
+# CONFIG_EXOFS_DEBUG is not set
+CONFIG_ORE=m
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_NFS_FSCACHE is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFS_USE_NEW_IDMAPPER is not set
+CONFIG_NFSD=m
+CONFIG_NFSD_V2_ACL=y
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_RPCSEC_GSS_KRB5=m
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+CONFIG_CIFS_WEAK_PW_HASH=y
+CONFIG_CIFS_UPCALL=y
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_DEBUG2 is not set
+CONFIG_CIFS_DFS_UPCALL=y
+# CONFIG_CIFS_FSCACHE is not set
+# CONFIG_CIFS_ACL is not set
+CONFIG_NCP_FS=m
+CONFIG_NCPFS_PACKET_SIGNING=y
+CONFIG_NCPFS_IOCTL_LOCKING=y
+CONFIG_NCPFS_STRONG=y
+CONFIG_NCPFS_NFS_NS=y
+CONFIG_NCPFS_OS2_NS=y
+# CONFIG_NCPFS_SMALLDOS is not set
+CONFIG_NCPFS_NLS=y
+CONFIG_NCPFS_EXTRAS=y
+CONFIG_CODA_FS=m
+CONFIG_AFS_FS=m
+# CONFIG_AFS_DEBUG is not set
+# CONFIG_AFS_FSCACHE is not set
+CONFIG_9P_FS=m
+# CONFIG_9P_FSCACHE is not set
+# CONFIG_9P_FS_POSIX_ACL is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ACORN_PARTITION=y
+# CONFIG_ACORN_PARTITION_CUMANA is not set
+# CONFIG_ACORN_PARTITION_EESOX is not set
+CONFIG_ACORN_PARTITION_ICS=y
+# CONFIG_ACORN_PARTITION_ADFS is not set
+# CONFIG_ACORN_PARTITION_POWERTEC is not set
+CONFIG_ACORN_PARTITION_RISCIX=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_ATARI_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_LDM_PARTITION=y
+# CONFIG_LDM_DEBUG is not set
+CONFIG_SGI_PARTITION=y
+CONFIG_ULTRIX_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_SYSV68_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+CONFIG_DLM=m
+# CONFIG_DLM_DEBUG is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+CONFIG_BOOT_PRINTK_DELAY=y
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_CPU_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_LATENCYTOP=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FTRACE_NMI_ENTER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_RING_BUFFER=y
+CONFIG_FTRACE_NMI_ENTER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_EVENT_POWER_TRACING_DEPRECATED=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_FUNCTION_PROFILER=y
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_FIREWIRE_OHCI_REMOTE_DMA is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+CONFIG_ASYNC_RAID6_TEST=m
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_KGDB=y
+CONFIG_KGDB_SERIAL_CONSOLE=y
+# CONFIG_KGDB_TESTS is not set
+# CONFIG_KGDB_LOW_LEVEL_TRAP is not set
+# CONFIG_KGDB_KDB is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_DEBUG_RODATA is not set
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_DEBUG_NX_TEST is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+# CONFIG_IO_DELAY_0X80 is not set
+CONFIG_IO_DELAY_0XED=y
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=1
+CONFIG_DEBUG_BOOT_PARAMS=y
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_TRUSTED_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+CONFIG_SECURITY_PATH=y
+CONFIG_LSM_MMAP_MIN_ADDR=0
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=0
+CONFIG_SECURITY_SELINUX_DISABLE=y
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
+CONFIG_SECURITY_SMACK=y
+CONFIG_SECURITY_TOMOYO=y
+CONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY=2048
+CONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG=1024
+# CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER is not set
+CONFIG_SECURITY_TOMOYO_POLICY_LOADER="/sbin/tomoyo-init"
+CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER="/sbin/init"
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE=1
+# CONFIG_IMA is not set
+# CONFIG_EVM is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_APPARMOR=y
+# CONFIG_DEFAULT_SECURITY_DAC is not set
+CONFIG_DEFAULT_SECURITY="apparmor"
+CONFIG_XOR_BLOCKS=m
+CONFIG_ASYNC_CORE=m
+CONFIG_ASYNC_MEMCPY=m
+CONFIG_ASYNC_XOR=m
+CONFIG_ASYNC_PQ=m
+CONFIG_ASYNC_RAID6_RECOV=m
+CONFIG_ASYNC_TX_DISABLE_PQ_VAL_DMA=y
+CONFIG_ASYNC_TX_DISABLE_XOR_VAL_DMA=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=m
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=m
+CONFIG_CRYPTO_NULL=m
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_CRYPTD=m
+CONFIG_CRYPTO_AUTHENC=m
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=m
+CONFIG_CRYPTO_GCM=m
+CONFIG_CRYPTO_SEQIV=m
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=m
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_LRW=m
+CONFIG_CRYPTO_PCBC=m
+CONFIG_CRYPTO_XTS=m
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=m
+CONFIG_CRYPTO_VMAC=m
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=m
+CONFIG_CRYPTO_CRC32C_INTEL=m
+CONFIG_CRYPTO_GHASH=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL=m
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_AES_X86_64=m
+CONFIG_CRYPTO_AES_NI_INTEL=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_BLOWFISH_COMMON=m
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SALSA20_X86_64=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+CONFIG_CRYPTO_TWOFISH_X86_64=m
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=m
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_REED_SOLOMON=m
+CONFIG_REED_SOLOMON_DEC16=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_NLATTR=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
diff --git a/drivers/acpi/processor_driver.c b/drivers/acpi/processor_driver.c
index 9d7bc9f..89a640b 100644
--- a/drivers/acpi/processor_driver.c
+++ b/drivers/acpi/processor_driver.c
@@ -469,7 +469,13 @@ static int __cpuinit acpi_processor_add(struct acpi_device *device)
 	}
 
 #ifdef CONFIG_SMP
-	if (pr->id >= setup_max_cpus && pr->id != 0)
+	printk(KERN_INFO
+			"pr->id %d setup_max_cpus %d nr_cpu_ids %d cpu_present %d boot %d prev_check %d curr_check %d\n",
+			pr->id, setup_max_cpus, nr_cpu_ids, cpu_present(pr->id), boot_cpu_physical_apicid,
+			(pr->id >= setup_max_cpus && pr->id != 0), ( !cpu_present(pr->id) && pr->id != first_cpu(cpu_present_map)));
+//	if (pr->id >= setup_max_cpus && pr->id != 0)
+	if (!cpu_present(pr->id) 
+           && (pr->id != first_cpu(cpu_present_map)))
 		return 0;
 #endif
 
diff --git a/drivers/gpu/vga/vgaarb.c b/drivers/gpu/vga/vgaarb.c
index 111d956..03822da 100644
--- a/drivers/gpu/vga/vgaarb.c
+++ b/drivers/gpu/vga/vgaarb.c
@@ -1304,6 +1304,11 @@ static int __init vga_arb_device_init(void)
 	struct pci_dev *pdev;
 	struct vga_device *vgadev;
 
+	/* POPCORN -- not sure
+	 * TODO -- check this! */
+	if ( !is_bsp_cluster )
+		return -1;
+
 	rc = misc_register(&vga_arb_device);
 	if (rc < 0)
 		pr_err("vgaarb: error %d registering device\n", rc);
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index dfee1b3..bfd2123 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1227,6 +1227,105 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	up_write(&pci_bus_sem);
 }
 
+struct pci_dev_blacklist_item {
+       unsigned short vendor;
+       unsigned short device;
+       unsigned int flags;
+};
+#define BL 16
+static struct pci_dev_blacklist_item
+pci_dev_blacklist[BL] = { {0,0,0},{0,0,0},{0,0,0},{0,0,0},
+                                               {0,0,0},{0,0,0},{0,0,0},{0,0,0},
+                                               {0,0,0},{0,0,0},{0,0,0},{0,0,0},
+                                               {0,0,0},{0,0,0},{0,0,0},{0,0,0} };
+static int pci_dev_blacklist_elements = 0;
+
+int pci_dev_list_add(int compatible, char *vendor, char *model,
+               char *strflags, int flags)
+{
+       int i;
+
+       // we statically allocated the blacklist array in order to avoid
+       // an early call to kmalloc that maybe cannot serve the request
+       if (!((i = pci_dev_blacklist_elements) < BL))
+               return -ENOMEM;
+
+       pci_dev_blacklist[i].vendor = (unsigned short)simple_strtoul(vendor, NULL, 0);
+       pci_dev_blacklist[i].device = (unsigned short)simple_strtoul(model, NULL, 0);
+       pci_dev_blacklist[i].flags = (unsigned int)simple_strtoul(strflags, NULL, 0);
+
+       printk(KERN_INFO "%s: [%x,%x] blacklisted with flags 0x%08x\n", __func__,
+                       pci_dev_blacklist[i].vendor, pci_dev_blacklist[i].device, pci_dev_blacklist[i].flags);
+       pci_dev_blacklist_elements++;
+       return i;
+}
+
+/*
+ * The list must be in the format
+ * pci_dev_flags=vendor:device:flags,[v,d,f]
+ * a simple example that blacklist the IDE device is
+ * pci_dev_flags=8086:7010:b
+ */
+static int pci_dev_add_str(char *dev_list)
+{
+	char *vendor, *device, *strflags;
+	char *next, *next_check;
+	int res = 0;
+
+	next = dev_list;
+	if (next && next[0] == '"') {
+		// Ignore both the leading and trailing quote.
+		next++;
+		next_check = ",\"";
+	} else {
+		next_check = ",";
+	}
+
+	/*
+	 * For the leading and trailing '"' case, the for loop comes
+	 * through the last time with vendor[0] == '\0'.
+	 */
+	for (vendor = strsep(&next, ":");
+			vendor && (vendor[0] != '\0') && (res == 0);
+			vendor = strsep(&next, ":")) {
+		strflags = NULL;
+		device = strsep(&next, ":");
+		if (device)
+			strflags = strsep(&next, next_check);
+		if (!device || !strflags) {
+			printk(KERN_ERR "%s: bad dev info string '%s' '%s'"
+					" '%s'\n", __func__, vendor, device,
+					strflags);
+			res = -EINVAL;
+		} else {
+			res = pci_dev_list_add(0 /* compatible */, vendor,
+					device, strflags, 0);
+			res = 0;
+		}
+	}
+
+	return res;
+}
+
+static int __init parse_pci_dev_flags(char *argv)
+{
+	return pci_dev_add_str(argv);
+}
+early_param("pci_dev_flags", parse_pci_dev_flags);
+/* POPCORN -- TODO -- Antonio needs to figure out what this is for */
+//__setup("pci_dev_flags", parse_pci_dev_flags);
+
+static int pci_device_blacklisted(struct pci_dev *dev)
+{
+	int i;
+
+	for (i=0; i<pci_dev_blacklist_elements; i++)
+		if (dev->vendor == pci_dev_blacklist[i].vendor &&
+				dev->device == pci_dev_blacklist[i].device)
+			return (i +1);
+	return 0;
+}
+
 struct pci_dev *__ref pci_scan_single_device(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
@@ -1241,6 +1340,12 @@ struct pci_dev *__ref pci_scan_single_device(struct pci_bus *bus, int devfn)
 	if (!dev)
 		return NULL;
 
+	if (pci_device_blacklisted(dev)) {
+		printk(KERN_INFO "%s: [%x,%x] device blacklisted\n", __func__,
+				dev->vendor, dev->device);
+		return NULL;
+	}
+
 	pci_device_add(dev, bus);
 
 	return dev;
diff --git a/drivers/tty/Kconfig b/drivers/tty/Kconfig
index 830cd62..3608cfe 100644
--- a/drivers/tty/Kconfig
+++ b/drivers/tty/Kconfig
@@ -108,6 +108,16 @@ config UNIX98_PTYS
 
 	  All modern Linux systems use the Unix98 ptys.  Say Y unless
 	  you're on an embedded system and want to conserve memory.
+	  
+	  
+config  VTY
+	bool "VTY Serial driver"
+	default y
+	---help---
+	This module will provide the serial driver support for the Multikernel Linux.
+	It helps the guest kernels to talk among themselves.
+	
+
 
 config DEVPTS_MULTIPLE_INSTANCES
 	bool "Support multiple instances of devpts"
diff --git a/drivers/tty/Makefile b/drivers/tty/Makefile
index 2953059..1c3532d 100644
--- a/drivers/tty/Makefile
+++ b/drivers/tty/Makefile
@@ -2,6 +2,7 @@ obj-y				+= tty_io.o n_tty.o tty_ioctl.o tty_ldisc.o \
 				   tty_buffer.o tty_port.o tty_mutex.o
 obj-$(CONFIG_LEGACY_PTYS)	+= pty.o
 obj-$(CONFIG_UNIX98_PTYS)	+= pty.o
+obj-$(CONFIG_VTY)		+= vty.o
 obj-$(CONFIG_AUDIT)		+= tty_audit.o
 obj-$(CONFIG_MAGIC_SYSRQ)	+= sysrq.o
 obj-$(CONFIG_N_HDLC)		+= n_hdlc.o
diff --git a/drivers/tty/serial/8250.c b/drivers/tty/serial/8250.c
index eeadf1b..b6295b1 100644
--- a/drivers/tty/serial/8250.c
+++ b/drivers/tty/serial/8250.c
@@ -3319,6 +3319,9 @@ static int __init serial8250_init(void)
 	if (ret)
 		goto put_dev;
 
+	if (!lapic_is_bsp())
+		return ret;
+
 	serial8250_register_ports(&serial8250_reg, &serial8250_isa_devs->dev);
 
 	ret = platform_driver_register(&serial8250_isa_driver);
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index 6c9b7cd..ae7b012 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -150,7 +150,7 @@ void tty_buffer_flush(struct tty_struct *tty)
 		__tty_buffer_flush(tty);
 	spin_unlock_irqrestore(&tty->buf.lock, flags);
 }
-
+EXPORT_SYMBOL(tty_buffer_flush);
 /**
  *	tty_buffer_find		-	find a free tty buffer
  *	@tty: tty owning the buffer
diff --git a/drivers/tty/vty.c b/drivers/tty/vty.c
new file mode 100644
index 0000000..cc62320
--- /dev/null
+++ b/drivers/tty/vty.c
@@ -0,0 +1,296 @@
+#include<linux/module.h>
+#include<linux/init.h>
+#include<linux/kernel.h>
+#include<linux/slab.h>
+#include<linux/string.h>
+#include<linux/spinlock.h>
+#include<linux/highmem.h>
+#include<linux/mm.h>
+#include<asm/io.h>
+#include<linux/sched.h>
+#include<linux/tty.h>
+#include<linux/tty_driver.h>
+#include<linux/tty_flip.h>
+#include<linux/device.h>
+#include<linux/major.h>
+#include<linux/timer.h>
+#include<linux/spinlock.h>
+#include<linux/types.h>
+
+MODULE_LICENSE("GPL");
+
+#define SUCCESS 0
+#define FAILURE -1
+#define BUF_SIZE 19200
+
+#define NO_OF_DEV 64
+
+/**************************************************/
+/*System Variables*/
+
+#define MINOR_START_NUMBER 121
+const char *tty_dev_name = "ttty";
+int order = 0;
+const int reading_interval = 200;
+const char tokenizer = '%';
+
+/***************************************************/
+
+unsigned long long global_poff = 0l;
+
+typedef struct vty_desc {
+	struct tty_struct * tty;
+	int id;
+	struct list_head list;
+} vty_desc_t;
+
+int index = 0;
+struct list_head current_tty;
+
+static int __init _setup_vty_offset(char *str)
+{
+	global_poff = simple_strtoull(str,0,16);
+	printk(KERN_ALERT "VTY offset %llx\n",global_poff);
+	return 0;
+}
+early_param("vty_offset", _setup_vty_offset);
+
+struct ring_buffer {
+	char buffer[BUF_SIZE];
+	int current_pos;
+	rwlock_t lock;
+};
+
+struct ring_buffer *ring_buffer_address[NO_OF_DEV][NO_OF_DEV];
+
+static int allocate_shared_memory() {
+
+	unsigned long *poff = 0l;
+	if (global_poff == 0) {
+		poff = 0xc0000000;
+	} else {
+		poff = (unsigned long *) global_poff;
+	}
+
+	size_t size = 0x200000;
+	void *virtual_address[64];
+
+	printk(KERN_ALERT "Poff %llx and %ld\n",poff,size);
+	unsigned long pfn = (long) poff >> PAGE_SHIFT;
+	unsigned long node = -1, nid = -1;
+	for_each_online_node(nid)
+	{
+		unsigned long start_pfn, end_pfn;
+		start_pfn = node_start_pfn(nid);
+		end_pfn = node_end_pfn(nid);
+		if ((start_pfn <= pfn) && (pfn < end_pfn)) {
+			node = nid;
+			break; // node found continue
+		}
+	}
+
+	int i;
+	for (i = 0; i < 64; ++i) {
+		if (node == -1) { // page never mapped (why?)
+			virtual_address[i] = ioremap_cache(
+					(resource_size_t)((void *) poff + (i * size)), size);
+		} else {
+			struct page *shared_page;
+			shared_page = pfn_to_page(pfn);
+			virtual_address[i] = page_address(shared_page);
+			void * kmap_addr = kmap(shared_page);
+
+		}
+	}
+
+	int j;
+	for (i = 0; i < 64; ++i) {
+		void *p = virtual_address[i];
+		for (j = 0; j < 64; ++j) {
+			ring_buffer_address[i][j] = (struct ring_buffer *) ((void *) p
+					+ (sizeof(struct ring_buffer) * j));
+				ring_buffer_address[i][j]->current_pos = 0;
+				rwlock_init(&(ring_buffer_address[i][j]->lock));
+		}
+	}
+
+	return 0;
+}
+
+struct tty_driver *master_tty_driver;
+struct timer_list read_function_timer;
+
+static void tty_dev_read(long unsigned int time);
+
+int tty_dev_open(struct tty_struct *tty, struct file *flip) {
+
+	vty_desc_t *tmp = (vty_desc_t *) kmalloc(sizeof(vty_desc_t), GFP_KERNEL);
+	tmp->tty = tty;
+	tmp->id = index++;
+	INIT_LIST_HEAD(&(tmp->list));
+	tty->driver_data = tmp->id;
+	list_add(&(tmp->list), &(current_tty));
+
+	mod_timer(&read_function_timer,	jiffies + msecs_to_jiffies(reading_interval));
+	return SUCCESS;
+}
+
+void tty_dev_close(struct tty_struct *tty, struct file *flip) {
+
+	struct list_head * cur, *n;
+	vty_desc_t * curt;
+
+	list_for_each_safe(cur, n, &current_tty)
+	{
+		curt = list_entry(cur, vty_desc_t, list);
+
+		if (curt->tty == tty && curt->id == (int) tty->driver_data) {
+			list_del(cur);
+			kfree(curt);
+			return 0;
+		}
+	}
+
+	del_timer(&read_function_timer);
+}
+
+int tty_dev_write(struct tty_struct * tty, const unsigned char *buf, int count) {
+	/**
+	 * When 0 wants to write to 2 it will write in 2,0
+	 * 2 wants to read what is written by 0, it will read 2,0
+	 * */
+	int xGrid = tty->index;
+	int yGrid = order;
+	if (count > 0 && (ring_buffer_address[xGrid][yGrid] != NULL)) {
+		write_lock(&(ring_buffer_address[xGrid][yGrid]->lock));
+		if (ring_buffer_address[xGrid][yGrid]->current_pos
+				< 0||
+				ring_buffer_address[xGrid][yGrid]->current_pos >= BUF_SIZE || count > BUF_SIZE) {ring_buffer_address[xGrid][yGrid]->current_pos = 0;
+		printk(KERN_ALERT "Memory Overflow...........\n Resetting the value.....\n");
+		if(count > BUF_SIZE) {
+			count = BUF_SIZE;
+		}
+	}
+		struct ring_buffer *current_buffer = ring_buffer_address[xGrid][yGrid];
+		memcpy(&(current_buffer->buffer[current_buffer->current_pos]), buf,
+				count);
+		current_buffer->current_pos += count;
+		current_buffer->buffer[current_buffer->current_pos] = '\0';
+		write_unlock(&(ring_buffer_address[xGrid][yGrid]->lock));
+	}
+	return count;
+}
+
+void tty_dev_read(long unsigned int time) {
+
+	struct list_head * cur, *n;
+	vty_desc_t * curt;
+
+	list_for_each_safe(cur, n, &current_tty)	
+	{
+		curt = list_entry(cur, vty_desc_t, list);
+
+		int xGrid = order;
+		int yGrid = curt->tty->index;
+		struct ring_buffer *my_ring_buf = ring_buffer_address[xGrid][yGrid];
+		if (my_ring_buf != NULL) {
+			read_lock(&(ring_buffer_address[xGrid][yGrid]->lock));
+			if (my_ring_buf->current_pos == 0) {
+				read_unlock(&(ring_buffer_address[xGrid][yGrid]->lock));
+				mod_timer(&read_function_timer,
+						jiffies + msecs_to_jiffies(reading_interval));
+				return;
+			}
+
+			tty_insert_flip_string(curt->tty, my_ring_buf->buffer,
+					my_ring_buf->current_pos);
+			tty_flip_buffer_push(curt->tty);
+			read_unlock(&(ring_buffer_address[xGrid][yGrid]->lock));
+			write_lock(&(ring_buffer_address[xGrid][yGrid]->lock));
+			memset(ring_buffer_address[xGrid][yGrid]->buffer, '\0',
+					ring_buffer_address[xGrid][yGrid]->current_pos);
+			ring_buffer_address[xGrid][yGrid]->current_pos = 0;
+			write_unlock(&(ring_buffer_address[xGrid][yGrid]->lock));
+
+		}
+
+	}
+	//unlock current_tty
+	mod_timer(&read_function_timer,
+			jiffies + msecs_to_jiffies(reading_interval));
+	return;
+
+}
+
+static int tty_dev_write_room(struct tty_struct *tty) {
+	int xGrid = tty->index;
+	int yGrid = order;
+	int retVal = BUF_SIZE;
+	if (ring_buffer_address[xGrid][yGrid] != NULL) {
+		read_lock(&(ring_buffer_address[xGrid][yGrid]->lock));
+		retVal = BUF_SIZE - ring_buffer_address[xGrid][yGrid]->current_pos;
+		read_unlock(&(ring_buffer_address[xGrid][yGrid]->lock));
+	}
+	return retVal;
+}
+
+static struct tty_operations tty_dev_operations = { .open = tty_dev_open,
+		.close = tty_dev_close, .write = tty_dev_write, .write_room =
+				tty_dev_write_room };
+
+static int __init vty_init(void)
+{
+	printk(KERN_ALERT "Loading MyTTy Driver memory %s\n",__func__);
+	order = smp_processor_id();
+	printk(KERN_ALERT "The order is %d\n",order);
+
+	allocate_shared_memory();
+	printk(KERN_ALERT "Memory Allocation is successful\n");
+
+	printk(KERN_ALERT "My TTY driver Module is loading\n");
+	master_tty_driver = alloc_tty_driver(NO_OF_DEV);
+	if(!master_tty_driver) {
+		printk(KERN_ALERT "Allocation of master is failed\n");
+		return FAILURE;
+	}
+
+	master_tty_driver->owner = THIS_MODULE;
+	master_tty_driver->driver_name="Myttydriver";
+	master_tty_driver->name = tty_dev_name;
+	master_tty_driver->major = TTY_MAJOR;
+	master_tty_driver->minor_start = MINOR_START_NUMBER;
+	master_tty_driver->num = NO_OF_DEV;
+	master_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	master_tty_driver->subtype = SERIAL_TYPE_NORMAL;
+	master_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_RESET_TERMIOS;
+	master_tty_driver->init_termios = tty_std_termios;
+	master_tty_driver->init_termios = tty_std_termios;
+
+	master_tty_driver->init_termios.c_iflag = 0;
+	master_tty_driver->init_termios.c_oflag = 0;
+	master_tty_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;
+	master_tty_driver->init_termios.c_lflag = 0;
+	master_tty_driver->init_termios.c_ispeed = 38400;
+	master_tty_driver->init_termios.c_ospeed = 38400;
+	tty_set_operations(master_tty_driver, &tty_dev_operations);
+
+	int retval = tty_register_driver(master_tty_driver);
+	if(retval != 0)
+	{
+		printk(KERN_ALERT "Unable to register the device\n");
+		return FAILURE;
+	}
+	setup_timer(&read_function_timer,tty_dev_read,0);
+
+	INIT_LIST_HEAD(&current_tty);
+
+	return SUCCESS;
+}
+
+static void __exit vty_exit(void)
+{
+	printk(KERN_ALERT "Unloading shared memory\n");
+}
+
+module_init( vty_init);
+module_exit( vty_exit);
diff --git a/drivers/tty/vty.h b/drivers/tty/vty.h
new file mode 100644
index 0000000..846cd00
--- /dev/null
+++ b/drivers/tty/vty.h
@@ -0,0 +1,15 @@
+#ifndef PACKET_H
+#define PACKET_H
+
+#define BUF_LEN 100
+
+
+struct packet
+{
+	char data[BUF_LEN];
+	int destination;
+	int source;
+	struct semaphore *sem;
+};
+
+#endif
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index 6ff96c6..58324b4 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -32,6 +32,7 @@
 #include <linux/elf.h>
 #include <linux/utsname.h>
 #include <linux/coredump.h>
+#include <linux/process_server.h>
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/page.h>
@@ -577,13 +578,14 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 		struct elfhdr elf_ex;
 		struct elfhdr interp_elf_ex;
 	} *loc;
+    unsigned long mk_sp, mk_ip;
 
 	loc = kmalloc(sizeof(*loc), GFP_KERNEL);
 	if (!loc) {
 		retval = -ENOMEM;
 		goto out_ret;
 	}
-	
+
 	/* Get the exec-header */
 	loc->elf_ex = *((struct elfhdr *)bprm->buf);
 
@@ -736,7 +738,7 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 		send_sig(SIGKILL, current, 0);
 		goto out_free_dentry;
 	}
-	
+
 	current->mm->start_stack = bprm->p;
 
 	/* Now we do a little grungy work by mmapping the ELF image into
@@ -935,12 +937,15 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 
 	install_exec_creds(bprm);
 	current->flags &= ~PF_FORKNOEXEC;
-	retval = create_elf_tables(bprm, &loc->elf_ex,
+	if(!current->executing_for_remote) {
+        retval = create_elf_tables(bprm, &loc->elf_ex,
 			  load_addr, interp_load_addr);
-	if (retval < 0) {
-		send_sig(SIGKILL, current, 0);
-		goto out;
-	}
+	    if (retval < 0) {
+		    send_sig(SIGKILL, current, 0);
+		    goto out;
+	    }
+    }
+
 	/* N.B. passed_fileno might not be initialized? */
 	current->mm->end_code = end_code;
 	current->mm->start_code = start_code;
@@ -982,8 +987,20 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 	 */
 	ELF_PLAT_INIT(regs, reloc_func_desc);
 #endif
-
-	start_thread(regs, elf_entry, bprm->p);
+   
+    /*
+     * Multikernel
+     */
+    if(current->executing_for_remote) {
+        process_server_import_address_space(&mk_ip, &mk_sp, regs);
+        /*printk("stack pointer = %lx\n",mk_sp);
+        for(i = 0; i <= 16; i++) {
+            printk("stack peak %lx at %lx\n",*(unsigned long*)(mk_sp + i*8), mk_sp + i*8);
+        }*/
+	    start_thread(regs, mk_ip, mk_sp);
+    } else {
+        start_thread(regs, elf_entry, bprm->p);
+    }
 	retval = 0;
 out:
 	kfree(loc);
diff --git a/fs/exec.c b/fs/exec.c
index 3625464..354f6f4 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -55,6 +55,7 @@
 #include <linux/pipe_fs_i.h>
 #include <linux/oom.h>
 #include <linux/compat.h>
+#include <linux/process_server.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -1523,14 +1524,16 @@ static int do_execve_common(const char *filename,
 	if (retval < 0)
 		goto out;
 
-	bprm->exec = bprm->p;
-	retval = copy_strings(bprm->envc, envp, bprm);
-	if (retval < 0)
-		goto out;
+    if(!current->executing_for_remote) {
+        bprm->exec = bprm->p;
+        retval = copy_strings(bprm->envc, envp, bprm);
+        if (retval < 0)
+            goto out;
 
-	retval = copy_strings(bprm->argc, argv, bprm);
-	if (retval < 0)
-		goto out;
+        retval = copy_strings(bprm->argc, argv, bprm);
+        if (retval < 0)
+            goto out;
+    }
 
 	retval = search_binary_handler(bprm,regs);
 	if (retval < 0)
diff --git a/fs/proc/kcore.c b/fs/proc/kcore.c
index d245cb2..99ab5e7 100644
--- a/fs/proc/kcore.c
+++ b/fs/proc/kcore.c
@@ -35,7 +35,8 @@
 
 static struct proc_dir_entry *proc_root_kcore;
 
-
+// #define PAGE_OFFSET             ((unsigned long)__PAGE_OFFSET)
+// #define __PAGE_OFFSET           _AC(0xffff880000000000, UL)
 #ifndef kc_vaddr_to_offset
 #define	kc_vaddr_to_offset(v) ((v) - PAGE_OFFSET)
 #endif
@@ -59,6 +60,9 @@ static int kcore_need_update = 1;
 void
 kclist_add(struct kcore_list *new, void *addr, size_t size, int type)
 {
+	if (type == 1)
+		return;
+
 	new->addr = (unsigned long)addr;
 	new->size = size;
 	new->type = type;
@@ -80,16 +84,21 @@ static size_t get_kcore_size(int *nphdr, size_t *elf_buflen)
 		try = kc_vaddr_to_offset((size_t)m->addr + m->size);
 		if (try > size)
 			size = try;
+
+		size += m->size; //antonio
+
 		*nphdr = *nphdr + 1;
-	}
-	*elf_buflen =	sizeof(struct elfhdr) + 
-			(*nphdr + 2)*sizeof(struct elf_phdr) + 
-			3 * ((sizeof(struct elf_note)) +
-			     roundup(sizeof(CORE_STR), 4)) +
-			roundup(sizeof(struct elf_prstatus), 4) +
-			roundup(sizeof(struct elf_prpsinfo), 4) +
-			roundup(sizeof(struct task_struct), 4);
-	*elf_buflen = PAGE_ALIGN(*elf_buflen);
+	}													// size is calculated here.. in a wird manner
+	*elf_buflen =	sizeof(struct elfhdr) + 			// elf header
+			(*nphdr + 2)*sizeof(struct elf_phdr) + 		// elf p header (nphdr +2) "program header"
+			3 * ((sizeof(struct elf_note)) +			// elf_note (headers?) * 3
+
+			     roundup(sizeof(CORE_STR), 4)) +		// CORE_STR
+			roundup(sizeof(struct elf_prstatus), 4) +   // elf_prstatus ?
+			roundup(sizeof(struct elf_prpsinfo), 4) +	// elf prpsinfo ?
+			roundup(sizeof(struct task_struct), 4);		// task_struct ?
+
+	*elf_buflen = PAGE_ALIGN(*elf_buflen);				// page align the content
 	return size + *elf_buflen;
 }
 
@@ -447,7 +456,7 @@ read_kcore(struct file *file, char __user *buffer, size_t buflen, loff_t *fpos)
 	if (*fpos < elf_buflen) {
 		char * elf_buf;
 
-		tsz = elf_buflen - *fpos;
+		tsz = elf_buflen - *fpos; // allocate memory space for the headers
 		if (buflen < tsz)
 			tsz = buflen;
 		elf_buf = kzalloc(elf_buflen, GFP_ATOMIC);
@@ -455,13 +464,16 @@ read_kcore(struct file *file, char __user *buffer, size_t buflen, loff_t *fpos)
 			read_unlock(&kclist_lock);
 			return -ENOMEM;
 		}
-		elf_kcore_store_hdr(elf_buf, nphdr, elf_buflen);
+
+		elf_kcore_store_hdr(elf_buf, nphdr, elf_buflen); // create the headers
 		read_unlock(&kclist_lock);
-		if (copy_to_user(buffer, elf_buf + *fpos, tsz)) {
+
+		if (copy_to_user(buffer, elf_buf + *fpos, tsz)) { // copy to user the headers
 			kfree(elf_buf);
 			return -EFAULT;
 		}
-		kfree(elf_buf);
+
+		kfree(elf_buf);		// release the allocated memory adjust the pointers
 		buflen -= tsz;
 		*fpos += tsz;
 		buffer += tsz;
@@ -484,30 +496,45 @@ read_kcore(struct file *file, char __user *buffer, size_t buflen, loff_t *fpos)
 	while (buflen) {
 		struct kcore_list *m;
 
-		read_lock(&kclist_lock);
+		read_lock(&kclist_lock); // it finds the right place from where to copy -------------------
 		list_for_each_entry(m, &kclist_head, list) {
 			if (start >= m->addr && start < (m->addr+m->size))
-				break;
+				break; // found!
 		}
+
+		//Antonio
+		//I have to search at which offset each segment begins in the file (can be saved in m->
+		//and then copy .. then I have to recreate a real offset and go throught the following ..
+		//because they are addressing real memory I am addressing the file
+
+
 		read_unlock(&kclist_lock);
 
-		if (&m->list == &kclist_head) {
+		if (&m->list == &kclist_head) { // erroneous situation ------------------------------------
 			if (clear_user(buffer, tsz))
 				return -EFAULT;
-		} else if (is_vmalloc_or_module_addr((void *)start)) {
+		} else if (is_vmalloc_or_module_addr((void *)start)) { // vmalloc or modules --------------
+			/* is_vmalloc_or_module_addr checks
+			 * return addr >= VMALLOC_START && addr < VMALLOC_END;
+			 * if (addr >= MODULES_VADDR && addr < MODULES_END)
+			 * they are type == KCORE_VMALLOC (both)
+			 */
 			char * elf_buf;
 
 			elf_buf = kzalloc(tsz, GFP_KERNEL);
 			if (!elf_buf)
 				return -ENOMEM;
-			vread(elf_buf, (char *)start, tsz);
+			vread(elf_buf, (char *)start, tsz); // mm/vmalloc.c#L2003 - read vmalloc area in a safe way.
 			/* we have to zero-fill user buffer even if no read */
 			if (copy_to_user(buffer, elf_buf, tsz)) {
 				kfree(elf_buf);
 				return -EFAULT;
 			}
 			kfree(elf_buf);
-		} else {
+		} else { // other areas -------------------------------------------------------------------
+			/* everything that is not KCORE_VMALLOC
+			 * i.e. KCORE_TEXT, KCORE_RAM, KCORE_VMEMMAP, KCORE_OTHER
+			 */
 			if (kern_addr_valid(start)) {
 				unsigned long n;
 
@@ -539,7 +566,7 @@ read_kcore(struct file *file, char __user *buffer, size_t buflen, loff_t *fpos)
 	return acc;
 }
 
-
+char * kcore_type[] = {"TEXT", "VMALLOC", "RAM", "VMEMMAP", "OTHER"};
 static int open_kcore(struct inode *inode, struct file *filp)
 {
 	if (!capable(CAP_SYS_RAWIO))
@@ -551,6 +578,17 @@ static int open_kcore(struct inode *inode, struct file *filp)
 		i_size_write(inode, proc_root_kcore->size);
 		mutex_unlock(&inode->i_mutex);
 	}
+	//printk("%s: size %ld\n", __func__, proc_root_kcore->size);
+
+	size_t try, size;
+	struct kcore_list *m;
+	list_for_each_entry(m, &kclist_head, list) {
+		try = kc_vaddr_to_offset((size_t)m->addr + m->size);
+		printk("%s: addr 0x%lx try 0x%lx size %ld type %d\n",
+				__func__, m->addr, try, m->size, m->type, kcore_type[m->type]
+				);
+	}
+
 	return 0;
 }
 
diff --git a/include/linux/bbuffer.h b/include/linux/bbuffer.h
new file mode 100644
index 0000000..4399c8c
--- /dev/null
+++ b/include/linux/bbuffer.h
@@ -0,0 +1,85 @@
+// bbuffer.h
+// Author: Antonio Barbalace, Virginia Tech 2012
+
+#ifndef _BBUFFER_H
+#define _BBUFFER_H
+
+//
+//#define WORLD_BYTES (sizeof(long))
+#ifndef WORLD_BYTES
+ #define WORLD_BYTES 4
+#endif
+
+//#if (WORLD_BYTES == 4)
+//typedef u16 __index_t;
+//typedef u32 __indexes_t;
+//#else
+typedef u32 __index_t;
+typedef u64 __indexes_t;
+//#endif
+
+// TODO cacheline length FROM topology
+
+#include <asm/cache.h>
+
+#ifndef CACHE_LINE
+ #define CACHE_LINE L1_CACHE_BYTES
+#endif
+
+typedef struct bbuffer {
+	union {
+		__indexes_t head_tail;
+		struct _raw_indexes {
+			__index_t head, tail;
+		} indexes;
+	};
+	int size; //buffer size (must be padded)
+	char pad[(CACHE_LINE - sizeof(struct _raw_indexes) - sizeof(int))];
+	char buffer[]; //actual buffer (cache aligned)
+} bbuffer_t;
+
+
+#ifdef CACHE_ALIGNED
+ /* the returned memory must be cache aligned */
+#define CHECK_CACHE_ALIGNED(addr) BUG_ON(((unsigned long)((void*)addr) & (CACHE_LINE -1)));
+ //#define CHECK_CACHE_ALIGNED(addr) assert(!((unsigned long)((void*)addr) & (CACHE_LINE -1)));
+//#define CHECK_CACHE_ALIGNED(addr) assert(((unsigned long)((void*)addr) & (CACHE_LINE -1)));
+#else /* !CACHE_ALIGNED */
+ #define CHECK_CACHE_ALIGNED(addr)
+#endif /* !CACHE_ALIGNED */
+
+/* every byte must be accessed using an __index_t index */
+#define BBUFFER_LIMIT (((unsigned long)0x01 << (sizeof(__index_t) * 8) ) -1)
+//#define BBUFFER_CHECK(pad_size) assert((pad_size > BBUFFER_LIMIT))
+#define BBUFFER_CHECK(pad_size) BUG_ON(((unsigned long)pad_size > (unsigned long)BBUFFER_LIMIT))
+
+#define BBUFFER_SPACE(pad_size) ((!(pad_size%CACHE_LINE)) ? \
+		(pad_size) : (pad_size + (CACHE_LINE - (pad_size%CACHE_LINE))))
+
+#define BBUFFER_SIZEOF(pad_size) (sizeof(bbuffer_t) + pad_size)
+
+#define BBUFFER_INIT(bbuf, pad_size) ({ \
+	CHECK_CACHE_ALIGNED(bbuf); \
+	memset(bbuf, 0, sizeof(bbuffer_t)); \
+	bbuf->size = pad_size; })
+
+/*
+ *
+ */
+bbuffer_t* bbuffer_init (int size, int node);
+/*
+ *
+ */
+void bbuffer_finalize (bbuffer_t* bb);
+/*
+ *
+ */
+int bbuffer_put (bbuffer_t* bb, char* src, int count);
+/*
+ *
+ */
+int bbuffer_get (bbuffer_t* bb, char* dst, int count);
+
+int bbuffer_count (bbuffer_t * buf);
+
+#endif //_BBUFFER_H
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a64b00e..448dbe0 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -426,6 +426,7 @@ enum
 {
 	HI_SOFTIRQ=0,
 	TIMER_SOFTIRQ,
+	PCN_KMSG_SOFTIRQ,
 	NET_TX_SOFTIRQ,
 	NET_RX_SOFTIRQ,
 	BLOCK_SOFTIRQ,
diff --git a/include/linux/kmod.h b/include/linux/kmod.h
index b16f653..8bcb4ec 100644
--- a/include/linux/kmod.h
+++ b/include/linux/kmod.h
@@ -65,6 +65,16 @@ struct subprocess_info {
 	int (*init)(struct subprocess_info *info, struct cred *new);
 	void (*cleanup)(struct subprocess_info *info);
 	void *data;
+
+    /**
+     * multikernel
+     */
+    int delegated; // Is this subprocess a delegated worker 
+                   // working on behalf of another cpu?
+    pid_t remote_pid;
+    int   remote_cpu;
+    int   clone_request_id;
+    struct pt_regs remote_regs;
 };
 
 /* Allocate a subprocess_info structure */
diff --git a/include/linux/mbuffer.h b/include/linux/mbuffer.h
new file mode 100644
index 0000000..ab22979
--- /dev/null
+++ b/include/linux/mbuffer.h
@@ -0,0 +1,37 @@
+// mbuffer.h
+// Author: Antonio Barbalace, Virginia Tech 2012
+#ifndef _MBUFFER_H
+#define _MBUFFER_H
+
+#include <linux/bbuffer.h>
+
+/*
+ *
+ */
+static inline bbuffer_t* mbuffer_init (int size, int node)
+{
+	return bbuffer_init(size, node);
+}
+
+/*
+ *
+ */
+static inline void mbuffer_finalize (bbuffer_t* bb)
+{
+	return bbuffer_finalize(bb);
+}
+/*
+ *
+ */
+int mbuffer_put (bbuffer_t* bb, char* src, int count);
+/*
+ *
+ */
+int mbuffer_get (bbuffer_t* bb, char* dst, int count);
+
+static inline int mbuffer_count (bbuffer_t * buf)
+{
+	return bbuffer_count(buf);
+}
+
+#endif //_MBUFFER_H
diff --git a/include/linux/mcomm.h b/include/linux/mcomm.h
new file mode 100644
index 0000000..494db35
--- /dev/null
+++ b/include/linux/mcomm.h
@@ -0,0 +1,146 @@
+
+#include <linux/kernel.h>
+#include <linux/mbuffer.h>
+#include <linux/bbuffer.h>
+#include <linux/threads.h>
+
+#ifndef _MCOMM_H
+#define _MCOMM_H
+
+#define MAX_CPUS NR_CPUS //64
+#define MAX_ARRAY MAX_CPUS
+#define MAX_BITMAP 4
+
+#define MAX_ELEMENTS MAX_CPUS //NR_CPUS
+#define COMM_BUFFS_SIZE 0x4000
+#define COMM_CPU_NUM (NR_CPUS>8?8:NR_CPUS)//8
+
+typedef unsigned int bitmask_t;
+
+#include <asm/cache.h>
+
+#ifndef USE_CACHE_ALIGN
+ #define USE_CACHE_ALIGN
+ #define CACHE_ALIGNED
+ #define CACHE_LINE L1_CACHE_BYTES
+#endif
+
+#define MAGIC_CHARS_ROW {'R','O','W',' '}
+
+typedef struct _row_comm {
+	char magic[8];		// magic
+	int elements;		// number of cpus
+	int id;				// cpu identifier
+	unsigned long lock;	// lock
+
+#ifdef USE_CACHE_ALIGN
+	char pad0[(CACHE_LINE -
+			( (sizeof(char) *8) +
+			(sizeof(int) *2) +
+			(sizeof(unsigned long) *1) ) %
+			CACHE_LINE)];
+#endif	/* USE_CACHE_ALIGN */
+
+	bitmask_t 	  status[MAX_BITMAP];   // receivers (cells) status
+	bitmask_t 	  active[MAX_BITMAP];	// currently allocated buffers or initialized
+	unsigned long offset[MAX_ARRAY];	// offset of the buffer from the beginning of the map
+	int 	 	  csize;				// allocated space per buffer
+	int 		  cnumber;				// number of buffers currently present
+
+#ifdef USE_CACHE_ALIGN
+	char pad1[(CACHE_LINE -
+			( (sizeof(bitmask_t) *2 *MAX_BITMAP) +
+			(sizeof(int) *2) +
+			(sizeof(unsigned long) *MAX_ARRAY) ) %
+			CACHE_LINE)];
+#endif	/* USE_CACHE_ALIGN */
+} row_comm;
+
+//NOTA ricordati la differenza tra massimo numero di elementi e quelli correntemente allocati
+
+// this is dependent by the type of memory allocator we are using
+// see what we learn from the MPICH/Nemesis guys so define it
+// simply void*
+typedef struct _shm_desc {
+	size_t	size;
+	key_t	key;
+	row_comm * addr; // used by the setup process
+} shm_desc;
+// TODO move in the allocator
+
+
+#define MAGIC_CHARS_MATR {'M','A','T','R'}
+//general communicator header
+typedef struct _matrix_comm {
+	char			magic[4];
+	unsigned long	lock; // we have to spinlock so must maybe be cache aligned (the problem is this does not to be critical)
+
+	int				elements; // the maximum number of elements, or the currently allocated elements
+	bitmask_t 		present[MAX_BITMAP]; // which elements are currently really allocated
+	void*			desc[MAX_ELEMENTS]; // available descriptors per element
+
+} matrix_comm;
+
+
+// NOTA the following two can be merged in one!!!
+// they are both allocated locally/privately
+// so no one cares
+// what will be readed concurrently and is in the same cache line?
+// does something like this exists? and if yes what?
+
+//structure CACHE_ALIGNED !!!
+typedef struct _comm_buffers {
+
+	// THIS IS MY BITMAP: the copy is inshared memory
+	bitmask_t * recv_bmp; //this first because must be cache aligned
+	// THIS ARE THE ptr to MY BUFFERS hopefully they will fit the same cache line of the pointer before
+	bbuffer_t * recv_buf[MAX_ARRAY];
+
+#ifdef USE_CACHE_ALIGN
+	char pad0[(CACHE_LINE -
+			( (sizeof(bitmask_t *) *1) +
+			(sizeof(bbuffer_t *) *MAX_ARRAY) ) %
+			CACHE_LINE)];
+#endif	/* USE_CACHE_ALIGN */
+
+	// the following data is packed per item  because it will be accessed together
+	struct {
+		// remote bitmap pointer
+		bitmask_t * bmp;
+		// remote recv buffer pointer
+		bbuffer_t * buf;
+	} send[MAX_ARRAY];
+
+	// the following is not aligned
+	int elements, id; //information must be replicated on each local copy
+
+} comm_buffers;
+
+// this is the private/local summary of each area
+typedef struct _comm_mapping {
+	matrix_comm * matrix;
+	row_comm    * row[MAX_ARRAY];
+
+	// remove the followings?!?!
+	// the following can be reconstructed from base
+	bitmask_t* bmp[MAX_ARRAY];
+	bbuffer_t* buf[MAX_ARRAY];
+} comm_mapping;
+
+// PROTOTYPES DECLARATION
+
+comm_mapping * matrix_init_mapping (int size, int elements);
+comm_buffers * matrix_init_buffers (comm_mapping * map, int id);
+
+comm_buffers* matrix_get_buffers(void);
+
+void matrix_finalize_buffers(comm_mapping * map);
+void matrix_finalize_mapping(comm_mapping * map);
+
+int matrix_send_to(comm_buffers * buffs, int dest, char* buff, int count);
+int matrix_send_self(comm_buffers * buffs, char *buff, int count);
+
+int matrix_recv_from(comm_buffers* buffs, int src, char* buff, int count);
+int matrix_recv_self(comm_buffers* buffs, char* buff, int count);
+
+#endif //_MCOMM_H
diff --git a/include/linux/multikernel.h b/include/linux/multikernel.h
new file mode 100644
index 0000000..24f7b07
--- /dev/null
+++ b/include/linux/multikernel.h
@@ -0,0 +1,14 @@
+#ifndef __LINUX_MULTIKERNEL_H
+#define __LINUX_MULTIKERNEL_H
+/*
+ * Boot parameters and other support stuff for MKLinux
+ *
+ * (C) Ben Shelton <beshelto@vt.edu> 2012
+ */
+
+#define POPCORN_MAX_CPUS 64
+
+extern int mklinux_boot;
+
+#endif /* __LINUX_MULTIKERNEL_H */
+
diff --git a/include/linux/pcn_kmsg.h b/include/linux/pcn_kmsg.h
new file mode 100644
index 0000000..e2e3656
--- /dev/null
+++ b/include/linux/pcn_kmsg.h
@@ -0,0 +1,216 @@
+#ifndef __LINUX_PCN_KMSG_H
+#define __LINUX_PCN_KMSG_H
+/*
+ * Header file for Popcorn inter-kernel messaging layer
+ *
+ * (C) Ben Shelton <beshelto@vt.edu> 2013
+ */
+
+#include <linux/list.h>
+#include <linux/multikernel.h>
+
+/* LOCKING / SYNCHRONIZATION */
+#define pcn_cpu_relax() __asm__ ("pause":::"memory")
+#define pcn_barrier() __asm__ __volatile__("":::"memory")
+
+/* BOOKKEEPING */
+
+#define POPCORN_MAX_MCAST_CHANNELS 32
+
+struct pcn_kmsg_mcast_wininfo {
+	unsigned char lock;
+	unsigned char owner_cpu;
+	unsigned long mask;
+	unsigned int num_members;
+	unsigned long phys_addr;
+};
+
+struct pcn_kmsg_rkinfo {
+	unsigned long phys_addr[POPCORN_MAX_CPUS];
+	struct pcn_kmsg_mcast_wininfo mcast_wininfo[POPCORN_MAX_MCAST_CHANNELS];
+};
+
+enum pcn_kmsg_wq_ops {
+	PCN_KMSG_WQ_OP_MAP_MSG_WIN,
+	PCN_KMSG_WQ_OP_UNMAP_MSG_WIN,
+	PCN_KMSG_WQ_OP_MAP_MCAST_WIN,
+	PCN_KMSG_WQ_OP_UNMAP_MCAST_WIN
+};
+
+typedef unsigned long pcn_kmsg_mcast_id;
+
+typedef struct {
+	struct work_struct work;
+	enum pcn_kmsg_wq_ops op;
+	int from_cpu;
+	int cpu_to_add;
+	pcn_kmsg_mcast_id id_to_join;
+} pcn_kmsg_work_t;
+
+/* MESSAGING */
+
+/* Enum for message types.  Modules should add types after
+   PCN_KMSG_END. */
+enum pcn_kmsg_type {
+	PCN_KMSG_TYPE_TEST,
+	PCN_KMSG_TYPE_CHECKIN,
+	PCN_KMSG_TYPE_MCAST,
+    PCN_KMSG_TYPE_PROC_SRV_CLONE_REQUEST,
+    PCN_KMSG_TYPE_PROC_SRV_CREATE_PROCESS_PAIRING,
+    PCN_KMSG_TYPE_PROC_SRV_EXIT_PROCESS,
+    PCN_KMSG_TYPE_PROC_SRV_VMA_TRANSFER,
+    PCN_KMSG_TYPE_PROC_SRV_PTE_TRANSFER,
+	PCN_KMSG_TYPE_MAX
+};
+
+/* Enum for message priority. */
+enum pcn_kmsg_prio {
+	PCN_KMSG_PRIO_HIGH,
+	PCN_KMSG_PRIO_NORMAL
+};
+
+/* Message header */
+struct pcn_kmsg_hdr {
+	unsigned int from_cpu	:8; // b0
+
+	enum pcn_kmsg_type type	:8; // b1
+
+	enum pcn_kmsg_prio prio	:5; // b2
+	unsigned int is_lg_msg  :1;
+	unsigned int lg_start   :1;
+	unsigned int lg_end     :1;
+
+	unsigned int lg_seqnum 	:7; // b3
+	unsigned int ready	:1; 
+}__attribute__((packed));
+
+#define PCN_KMSG_PAYLOAD_SIZE 60
+
+/* The actual messages.  The expectation is that developers will create their
+   own message structs with the payload replaced with their own fields, and then
+   cast them to a struct pcn_kmsg_message.  See the checkin message below for
+   an example of how to do this. */
+struct pcn_kmsg_message {
+	unsigned char payload[PCN_KMSG_PAYLOAD_SIZE];
+	struct pcn_kmsg_hdr hdr;
+}__attribute__((packed)) __attribute__((aligned(64)));
+
+/* List entry to copy message into and pass around in receiving kernel */
+struct pcn_kmsg_container {
+	struct pcn_kmsg_message msg;
+	struct list_head list;
+}__attribute__((packed));
+
+/* Message struct for guest kernels to check in with each other. */
+struct pcn_kmsg_checkin_message {
+	unsigned long window_phys_addr;
+	unsigned char cpu_to_add;
+	char pad[51];
+	struct pcn_kmsg_hdr hdr;
+}__attribute__((packed)) __attribute__((aligned(64)));
+
+/* Message struct for testing */
+struct pcn_kmsg_test_message {
+	unsigned long test_val;
+	char pad[52];
+	struct pcn_kmsg_hdr hdr;
+}__attribute__((packed)) __attribute__((aligned(64)));
+
+struct pcn_kmsg_long_message {
+	struct pcn_kmsg_hdr hdr;
+	unsigned char payload[512];
+};
+
+/* WINDOW / BUFFERING */
+
+#define PCN_KMSG_RBUF_SIZE 64
+
+struct pcn_kmsg_window {
+	volatile unsigned long head;
+	volatile unsigned long tail;
+	struct pcn_kmsg_message buffer[PCN_KMSG_RBUF_SIZE];
+}__attribute__((packed));
+
+/* Typedef for function pointer to callback functions */
+typedef int (*pcn_kmsg_cbftn)(struct pcn_kmsg_message *);
+
+/* FUNCTIONS */
+
+/* SETUP */
+
+/* Register a callback function to handle a new message type.  Intended to
+   be called when a kernel module is loaded. */
+int pcn_kmsg_register_callback(enum pcn_kmsg_type type, 
+			       pcn_kmsg_cbftn callback);
+
+/* Unregister a callback function for a message type.  Intended to
+   be called when a kernel module is unloaded. */
+int pcn_kmsg_unregister_callback(enum pcn_kmsg_type type);
+
+/* MESSAGING */
+
+/* Send a message to the specified destination CPU. */
+int pcn_kmsg_send(unsigned int dest_cpu, struct pcn_kmsg_message *msg);
+
+/* Send a long message to the specified destination CPU. */
+int pcn_kmsg_send_long(unsigned int dest_cpu, 
+		       struct pcn_kmsg_long_message *lmsg, 
+		       unsigned int payload_size);
+
+/* MULTICAST GROUPS */
+
+/* Enum for mcast message type. */
+enum pcn_kmsg_mcast_type {
+	PCN_KMSG_MCAST_OPEN,
+	PCN_KMSG_MCAST_ADD_MEMBERS,
+	PCN_KMSG_MCAST_DEL_MEMBERS,
+	PCN_KMSG_MCAST_CLOSE,
+	PCN_KMSG_MCAST_MAX
+};
+
+/* Message struct for guest kernels to check in with each other. */
+struct pcn_kmsg_mcast_message {
+	enum pcn_kmsg_mcast_type type :32; 
+	pcn_kmsg_mcast_id id;	
+	unsigned long mask;
+	unsigned int num_members;
+	unsigned long window_phys_addr;
+	char pad[28];
+	struct pcn_kmsg_hdr hdr;
+}__attribute__((packed)) __attribute__((aligned(64)));
+
+
+
+struct pcn_kmsg_mcast_window {
+	volatile unsigned long head;
+	volatile unsigned long tail;
+	int read_counter[PCN_KMSG_RBUF_SIZE];
+	struct pcn_kmsg_message buffer[PCN_KMSG_RBUF_SIZE];
+}__attribute__((packed));
+
+struct pcn_kmsg_mcast_local {
+	struct pcn_kmsg_mcast_window * mcastvirt;
+	unsigned long local_tail;
+};
+
+/* Open a multicast group containing the CPUs specified in the mask. */
+int pcn_kmsg_mcast_open(pcn_kmsg_mcast_id *id, unsigned long mask);
+
+/* Add new members to a multicast group. */
+int pcn_kmsg_mcast_add_members(pcn_kmsg_mcast_id id, unsigned long mask);
+
+/* Remove existing members from a multicast group. */
+int pcn_kmsg_mcast_delete_members(pcn_kmsg_mcast_id id, unsigned long mask);
+
+/* Close a multicast group. */
+int pcn_kmsg_mcast_close(pcn_kmsg_mcast_id id);
+
+/* Send a message to the specified multicast group. */
+int pcn_kmsg_mcast_send(pcn_kmsg_mcast_id id, struct pcn_kmsg_message *msg);
+
+/* Send a long message to the specified multicast group. */
+int pcn_kmsg_mcast_send_long(pcn_kmsg_mcast_id id, 
+			     struct pcn_kmsg_long_message *msg,
+			     unsigned int payload_size);
+
+#endif /* __LINUX_PCN_KMSG_H */
diff --git a/include/linux/process_server.h b/include/linux/process_server.h
new file mode 100644
index 0000000..204f1f2
--- /dev/null
+++ b/include/linux/process_server.h
@@ -0,0 +1,33 @@
+/*********************
+ * process server header
+ * dkatz
+ *********************/
+
+#include <linux/sched.h>
+#include <asm/ptrace.h>
+
+#ifndef _PROCESS_SERVER_H
+#define _PROCESS_SERVER_H
+
+#define PROCESS_SERVER_CLONE_SUCCESS 0
+#define PROCESS_SERVER_CLONE_FAIL 1
+
+
+/*
+ * Migration hook.
+ */
+int process_server_do_migration(struct task_struct* task, int cpu);
+
+/*
+ * Utilities for other modules to hook
+ * into the process server.
+ */
+int process_server_import_address_space(unsigned long* ip, unsigned long *sp, struct pt_regs* regs);
+int process_server_notify_delegated_subprocess_starting(pid_t pid, pid_t remote_pid, int remote_cpu);
+int process_server_task_exit_notification(pid_t pid);
+int process_server_notify_mmap(struct file *file, unsigned long addr,
+                               unsigned long len, unsigned long prot,
+                               unsigned long flags, unsigned long pgoff);
+int process_server_notify_munmap(struct mm_struct *mm, unsigned long start, size_t len);
+
+#endif // _PROCESS_SERVER_H
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 1c4f3e9..e8cfba5 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -300,7 +300,7 @@ extern void show_stack(struct task_struct *task, unsigned long *sp);
 void io_schedule(void);
 long io_schedule_timeout(long timeout);
 
-extern void cpu_init (void);
+extern void cpu_init (int);
 extern void trap_init(void);
 extern void update_process_times(int user);
 extern void scheduler_tick(void);
@@ -1572,6 +1572,18 @@ struct task_struct {
 #ifdef CONFIG_HAVE_HW_BREAKPOINT
 	atomic_t ptrace_bp_refcnt;
 #endif
+    /*
+     * Multikernel
+     */
+    int represents_remote;      /* Is this a placeholder process? */
+    int executing_for_remote;   /* Is this executing on behalf of another cpu? */
+    int remote_pid;             /* What is the pid on the remote cpu? */
+    int remote_cpu;             /* What is the remote cpu? */
+    int clone_request_id;       /* Number of the clone request id, to match up with
+                                 * address space and other information for this task.
+                                 */
+    struct pt_regs remote_regs; /* regs copied from placeholder process. */
+    unsigned long clone_flags;
 };
 
 /* Future-safe accessor for struct task_struct's cpus_allowed. */
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 86a24b1..a84dd8c 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -857,4 +857,13 @@ asmlinkage long sys_process_vm_writev(pid_t pid,
 				      unsigned long riovcnt,
 				      unsigned long flags);
 
+asmlinkage long sys_multikernel_boot(int cpu,
+				     unsigned long kernel_start_address);
+
+asmlinkage long sys_get_boot_params_addr(void);
+
+asmlinkage long sys_popcorn_test_kmsg(int cpu);
+
+asmlinkage long sys_popcorn_test_ipi_latency(int cpu);
+
 #endif
diff --git a/init/main.c b/init/main.c
index 217ed23..ed4a3ac 100644
--- a/init/main.c
+++ b/init/main.c
@@ -96,6 +96,10 @@ static inline void mark_rodata_ro(void) { }
 extern void tc_init(void);
 #endif
 
+#ifdef CONFIG_POPCORN_KMSG
+extern void pcn_kmsg_init(void);
+#endif
+
 /*
  * Debug helper: via this flag we know that we are in 'early bootup code'
  * where only the boot processor is running with IRQ disabled.  This means
@@ -500,7 +504,7 @@ asmlinkage void __init start_kernel(void)
 	mm_init_owner(&init_mm, &init_task);
 	mm_init_cpumask(&init_mm);
 	setup_command_line(command_line);
-	setup_nr_cpu_ids();
+	setup_nr_cpu_ids(); //requires cpu_possible_mask setted up (in setup_arch, acpi_boot_init)
 	setup_per_cpu_areas();
 	smp_prepare_boot_cpu();	/* arch-specific boot-cpu hooks */
 
@@ -639,6 +643,10 @@ asmlinkage void __init start_kernel(void)
 
 	ftrace_init();
 
+#ifdef CONFIG_POPCORN_KMSG
+	//pcn_kmsg_init();
+#endif
+
 	/* Do the rest non-__init'ed, we're now alive */
 	rest_init();
 }
diff --git a/ipc/Makefile b/ipc/Makefile
index 9075e17..6469ba6 100644
--- a/ipc/Makefile
+++ b/ipc/Makefile
@@ -6,7 +6,7 @@ obj-$(CONFIG_SYSVIPC_COMPAT) += compat.o
 obj-$(CONFIG_SYSVIPC) += util.o msgutil.o msg.o sem.o shm.o ipcns_notifier.o syscall.o
 obj-$(CONFIG_SYSVIPC_SYSCTL) += ipc_sysctl.o
 obj_mq-$(CONFIG_COMPAT) += compat_mq.o
-obj-$(CONFIG_POSIX_MQUEUE) += mqueue.o msgutil.o $(obj_mq-y)
+obj-$(CONFIG_POSIX_MQUEUE) += mqueue.o msgutil.o $(obj_mq-y) bbuffer.o mbuffer.o mcomm.o
 obj-$(CONFIG_IPC_NS) += namespace.o
 obj-$(CONFIG_POSIX_MQUEUE_SYSCTL) += mq_sysctl.o
 
diff --git a/ipc/bbuffer.c b/ipc/bbuffer.c
new file mode 100644
index 0000000..e472847
--- /dev/null
+++ b/ipc/bbuffer.c
@@ -0,0 +1,193 @@
+// bbuffer.c
+// Author: Antonio Barbalace, VirginiaTech 2012
+
+// maybe this file must be all contained in a h file...
+// basically is a cicular buffer BYTE ORIENTED
+// FUTURE support two usages: typed oriented and byte (memcpy style oriented)
+// NUMA AWARE - allocating memory on the right node (libnuma)
+// *numa_alloc_onnode(size_t size, int node);
+// in MKLINUX the mklinux_alloc_onnode will be used
+// for multiple writer 2 phase commit can be a solution
+// for zero copy memory get/dispose of buffers is fantastic solution
+
+//#include <stdint.h>
+
+// the following are defined in include/asm-generic/int-*.h
+//#include "types.h"
+//typedef unsigned short u16;
+//typedef unsigned int u32;
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+
+#include <linux/smp.h>
+
+#ifndef CACHE_ALIGNED
+ #define CACHE_ALIGNED
+#endif
+
+#include <linux/bbuffer.h>"
+
+
+//and maybe one cache line before and after the buffer must be a watermark
+// header and buffer must be allocate together in the same private/local area
+
+//#include <stdlib.h>
+//#include <stdio.h>
+//#include <assert.h>
+
+//#include "alloc.h"
+
+///////////////////////////////////////////////////////////////////////////////
+// bbuffer_init
+/*
+bbuffer_t * bbuffer_init (int size, int node)
+{
+	int padded_size = size;
+
+#ifdef CACHE_ALIGNED
+	padded_size = BBUFFER_SPACE(size);
+//#endif  CACHE_ALIGNED
+	BBUFFER_CHECK(padded_size);
+
+	bbuffer_t* bb = (bbuffer_t*) alloc_on_node(
+			BBUFFER_SIZEOF(padded_size), node);
+	// returns zero if malloc fails
+	if (!bb)
+		return bb;
+
+	BBUFFER_INIT(bb, padded_size);
+	return bb;
+}
+*/
+///////////////////////////////////////////////////////////////////////////////
+// bbuffer_finalize
+/*
+void bbuffer_finalize (bbuffer_t* bb)
+{
+	free_on_node(bb);
+}
+*/
+///////////////////////////////////////////////////////////////////////////////
+// bbuffer_put
+
+/* further improvements
+ * 1. each entry must be cache aligned (avoid false sharing)
+ * 2. waiting put (on buffer overrun)
+ */
+int bbuffer_put (bbuffer_t* buf, char* src, int count)
+{
+	register struct _raw_indexes ht;
+	register int size, avail_elements; // used_elements,
+
+	ht = buf->indexes;
+	size = buf->size;
+	//used_elements = ((size + ht.head) - ht.tail) % size;
+    avail_elements = size - ((size + ht.head) - ht.tail) % size; //used_elements;
+
+    /* if the elements does not fit in the buffer return error */
+    if (count > (avail_elements -1))
+    	return -1;
+
+    /* when tail is greater then head content is written across the end */
+    if ((ht.head + count) >= size) {
+    	memcpy(&(buf->buffer[ht.head]),
+    			src, (size - ht.head));
+    	memcpy(&(buf->buffer[0]),
+    			(src + (size - ht.head)), (ht.head + count) % size);
+    	ht.head = (ht.head + count) % size;
+	}
+	else {
+		memcpy(&(buf->buffer[ht.head]), src, count);
+		ht.head = (ht.head + count);
+	}
+
+    buf->indexes.head = ht.head;
+    return count;
+}
+
+// TODO
+//int bbuffer_puttofit (arch_header_t *buf, char *src, int count) {
+//	return 0;
+//}
+
+///////////////////////////////////////////////////////////////////////////////
+// bbuffer_get
+
+
+// considering that a message can be written on the bound and finish on the other side, this is maybe not the best for performance but..
+// an external buffer where to copy the data is not a bad idea we can study a message passing with linear address of the contents i
+//order to do not require further copies (like lists of buckets each bucket can contain a different message
+// RETURNS the number of characters copied
+
+// how many bytes? right now we have no clue on how many bytes -> we need a micro header in the buffer
+// otherwise we can create a circular buffer of fixed elements (every time you insert o pick up one or more elements)
+
+/* THINK ABOUT...
+CODE IS NOT RELIABLE RIGHT NOW, microheaders or object oriented buffer ?! I mean if the buffer is byte oriented is fantastic!
+		i.e. the object granularity is char the code is ready to go (it is ok for many apps, like the multi cache test)
+*/
+
+/* TODO
+two alternatives:
+
+the idea to avoid the count variable is to store a bit somewhere in the
+tail or head that indicate that head and tail are full but
+
+this is the alternative to lost one element when head and tail cannot be the same
+*/
+int bbuffer_get (bbuffer_t * buf, char * dst, int count)
+{
+	register struct _raw_indexes ht;
+	register int size;
+	register int used_elements; // avail_elements;
+
+	ht = buf->indexes;
+	size = buf->size;
+
+	used_elements = (((size + ht.head) - ht.tail) % size);
+ 	//avail_elements = size - used_elements;
+
+ 	/* nothing present in the buffer */
+	if (used_elements == 0 ) // tail == head
+		return -1;
+
+	/* amount to copy */
+	if (count > used_elements )
+		count = used_elements;
+
+	/* when tail is greater then head content is written across the end */
+	if (ht.tail + count >= size) {
+		memcpy(dst, &(buf->buffer[ht.tail]),
+				(size - ht.tail));
+		memcpy((dst + (size - ht.tail)), &(buf->buffer[0]),
+				(ht.tail + count) % size);
+		ht.tail = (ht.tail + count) % size;
+	}
+	else {
+		memcpy(dst, &(buf->buffer[ht.tail]), count);
+		ht.tail= (ht.tail + count);
+	}
+
+	buf->indexes.tail = ht.tail;
+	return count;
+}
+
+int bbuffer_count (bbuffer_t * buf)
+{
+	register struct _raw_indexes ht;
+	register int size;
+
+	ht = buf->indexes;
+	size = buf->size;
+
+	return (((size + ht.head) - ht.tail) % size);
+}
+
+static void bbuffer_dump(bbuffer_t * bb)
+{
+  printk("%s: head %d tail %d size %d count %d\n",
+		  __func__, bb->indexes.head, bb->indexes.tail, bb->size,
+		  (((bb->size + bb->indexes.head) - bb->indexes.tail) % bb->size));
+}
diff --git a/ipc/mbuffer.c b/ipc/mbuffer.c
new file mode 100644
index 0000000..dac1654
--- /dev/null
+++ b/ipc/mbuffer.c
@@ -0,0 +1,195 @@
+// mbufer.c
+// Author: Antonio Barbalace, Virginia Tech 2012
+// messagge buffer (based on byte buffer)
+
+
+//#include <stdint.h>
+
+//#include "types.h"
+//typedef unsigned short u16;
+//typedef unsigned int u32;
+
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+
+#include <linux/smp.h>
+
+#ifndef CACHE_ALIGNED
+ #define CACHE_ALIGNED
+#endif
+
+#include <linux/bbuffer.h>
+#include <linux/mbuffer.h>
+
+
+
+//and maybe one cache line before and after the buffer must be a watermark
+// header and buffer must be allocate together in the same private/local area
+//#include <stdlib.h>
+//#include <stdio.h>
+//#include <string.h>
+//#include <assert.h>
+
+
+
+typedef struct hheader {
+	union {
+		__indexes_t head_head;
+		struct _raw_heads {
+			__index_t part, total;
+		} header;
+	};
+} hheader_t;
+
+//#define MALIGNMENT CACHE_LINE
+#define MALIGNMENT sizeof(hheader_t)
+
+int mbuffer_put (bbuffer_t* buf, char* src, int count)
+{
+	register struct _raw_indexes ht;
+	struct _raw_heads hh;
+	register int acount, size, avail_elements; // used_elements,
+
+	ht = buf->indexes;
+	size = buf->size;
+
+	acount = sizeof(hheader_t) + count;
+	acount += MALIGNMENT - (acount % MALIGNMENT);
+
+	//used_elements = ((size + ht.head) - ht.tail) % size;
+    avail_elements = size - ((size + ht.head) - ht.tail) % size; //used_elements;
+
+    /* if the elements does not fit in the buffer return error */
+    if (acount > (avail_elements -1))
+    	return -1;
+
+    hh.part = count;
+    hh.total = acount;
+
+    /* head will cross the buffer */
+    if ((ht.head + sizeof(hheader_t)) >= size) {
+    	// copy the header
+    	memcpy(&(buf->buffer[ht.head]),
+    			&hh, (size - ht.head) );
+    	memcpy(&(buf->buffer[0]),
+    	    		 	(&hh + (size - ht.head)), (ht.head + sizeof(hheader_t)) % size);
+    	// copy the data
+    	memcpy(&(buf->buffer[((ht.head + sizeof(hheader_t)) % size)]),
+    	    			src, count);
+    	// mem set aligned data
+    	memset(&(buf->buffer[((ht.head + sizeof(hheader_t)) % size) + count]),
+    			-1, (acount - count - sizeof(hheader_t)) );
+    	// new head value
+    	ht.head = (ht.head + acount) % size;
+    }
+    /* data will cross the buffer */
+    else if ((ht.head + sizeof(hheader_t) + count) >= size) {
+    	// copy the header
+    	memcpy(&(buf->buffer[ht.head]),
+    			&hh, sizeof(hheader_t));
+    	// copy the data
+    	memcpy(&(buf->buffer[ht.head]) + sizeof(hheader_t),
+    			src, (size - sizeof(hheader_t) - ht.head));
+    	memcpy(&(buf->buffer[0]),
+    			(src + (size - sizeof(hheader_t) - ht.head)), (ht.head + sizeof(hheader_t) + count) % size);
+    	// memset aligned data
+    	memset(&(buf->buffer[((ht.head + sizeof(hheader_t) + count) % size)]),
+    			-1, (acount - count));
+    	// new head value
+    	ht.head = (ht.head + acount) % size;
+	}
+    /* aligned data will cross the buffer */
+    else if ((ht.head + acount) >= size) {
+		// copy the header
+		memcpy(&(buf->buffer[ht.head]), &hh, sizeof(hheader_t));
+		// copy the data
+		memcpy(&(buf->buffer[(ht.head + sizeof(hheader_t))]), src, count);
+		// memset the alignment
+		memset(&(buf->buffer[(ht.head + sizeof(hheader_t) + count)]),
+				-1, (size -ht.head -sizeof(hheader_t) -count));
+		memset(&(buf->buffer[0]),
+				-1, ((ht.head + acount) % size));
+		// new head value
+    	ht.head = (ht.head + acount) % size;
+    }
+    /* no data crossing */
+	else {
+		// copy the header
+		memcpy(&(buf->buffer[ht.head]), &hh, sizeof(hheader_t));
+		// copy the data
+		memcpy(&(buf->buffer[(ht.head + sizeof(hheader_t))]), src, count);
+		// memset the alignment
+		memset(&(buf->buffer[(ht.head + sizeof(hheader_t) + count)]), -1, (acount -count));
+		// new head value
+		ht.head = (ht.head + acount);
+	}
+
+    buf->indexes.head = ht.head;
+    return count;
+}
+
+int mbuffer_get (bbuffer_t * buf, char * dst, int count)
+{
+	register struct _raw_indexes ht;
+	struct _raw_heads hh;
+	register int size;
+	register int used_elements; // avail_elements;
+
+	ht = buf->indexes;
+	size = buf->size;
+
+	used_elements = (((size + ht.head) - ht.tail) % size);
+ 	//avail_elements = size - used_elements;
+
+ 	/* nothing present in the buffer */
+	if (used_elements == 0 ) // tail == head
+		return -1;
+
+	/* read the header, can cross the buffer */
+	if (ht.tail + sizeof(hheader_t) >= size) {
+		memcpy(&hh, &(buf->buffer[ht.tail]), size -ht.tail);
+		memcpy(&hh, &(buf->buffer[0]), (ht.tail + sizeof(hheader_t) % size) );
+	}
+	else {
+		memcpy(&hh, &(buf->buffer[ht.tail]), sizeof(hheader_t));
+	}
+	ht.tail = (ht.tail + sizeof(hheader_t) % size);
+
+	/* amount to copy */
+	if (count >= hh.part )
+		count = hh.part;
+	else
+		// exit if there is no enough space
+		return -1;
+
+	/* when tail is greater then head content is written across the end */
+	if (ht.tail + count >= size) {
+		memcpy(dst, &(buf->buffer[ht.tail]),
+				(size - ht.tail));
+		memcpy((dst + (size - ht.tail)), &(buf->buffer[0]),
+				(ht.tail + count) % size);
+	}
+	else {
+		memcpy(dst, &(buf->buffer[ht.tail]), count);
+	}
+	ht.tail = (ht.tail + count) % size;
+
+	/* check for the align space */
+	register int acount = hh.total - hh.part - sizeof(hheader_t);
+	if ( acount )
+		ht.tail = (ht.tail + acount) % size;
+
+	buf->indexes.tail = ht.tail;
+	return count;
+}
+
+/*
+static void mbuffer_dump(bbuffer_t * bb)
+{
+  printk("mbuffer_dump: head %d tail %d size %d count %d\n",
+		  bb->indexes.head, bb->indexes.tail, bb->size,
+		  (((bb->size + bb->indexes.head) - bb->indexes.tail) % bb->size));
+}
+*/
diff --git a/ipc/mcomm.c b/ipc/mcomm.c
new file mode 100644
index 0000000..883ac94
--- /dev/null
+++ b/ipc/mcomm.c
@@ -0,0 +1,526 @@
+
+// mcomm.c
+// Copyright Antonio Barbalace, Virginia Tech 2012
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/highmem.h>
+#include <linux/mm.h>
+
+#include <linux/smp.h>
+
+//#define MAX_CPUS 64
+//#define MAX_ARRAY MAX_CPUS
+//#define MAX_BITMAP 4
+
+//#if (WORLD_BYTES == 4)
+// #define BIT_PER_BITMASK 32
+//#else
+#define BIT_PER_BITMASK 64
+//#endif
+
+#include <linux/mcomm.h>
+#define USE_MBUFFER
+#include <linux/bbuffer.h>
+#ifdef USE_MBUFFER
+ #include <linux/mbuffer.h>
+#endif /* USE_MBUFFER */
+
+static comm_mapping* cmap;
+static comm_buffers* cbuf;
+
+/////////////////////////////////////////////////////////////////////
+// bitmask support
+/////////////////////////////////////////////////////////////////////
+
+//typedef unsigned int bitmask_t;
+
+static inline void clear_bit_bitmap(bitmask_t* pbitmap, int id)
+{
+	pbitmap[(id / BIT_PER_BITMASK)] &= ~(1 << (id % BIT_PER_BITMASK));
+}
+
+static inline void set_bit_bitmap(bitmask_t* pbitmap, int id)
+{
+	pbitmap[(id / BIT_PER_BITMASK)] |= (1 << (id % BIT_PER_BITMASK));
+}
+
+static inline int ffs_bit_bitmap(bitmask_t* pbitmap)
+{
+	register int i, pos;
+	for (i=0; i<MAX_BITMAP; i++)
+		if ((pos = ffs(pbitmap[i])) > 0)
+			return ((i*BIT_PER_BITMASK) + (pos -1));
+	return -1;
+}
+/////////////////////////////////////////////////////////////////////
+
+#include <linux/mcomm.h>
+
+static unsigned long mcomm_address = 0x0000;
+
+/////////////////////////////////////////////////////////////////////
+// allocator
+/////////////////////////////////////////////////////////////////////
+
+#define get_node_from_cpu(id) 0
+
+#define alloc_private(size, node) __alloc_private(size, node)
+#define alloc_global(size) __alloc_on_node(size, -1)
+#define alloc_on_node(size, node) __alloc_on_node(size, node)
+#define free_on_node(addr) __free_on_node(addr)
+
+// KRN SHM
+#define INIT_SIZE 0x1000000
+unsigned long alloc_size = INIT_SIZE;
+unsigned long alloc_addr = 0xbadabada;
+
+// KRN SHM
+static int alloc_init(void* poff, int size)
+{
+	void * virtual_address;
+
+    unsigned long pfn = (long) poff >> PAGE_SHIFT;
+    unsigned long psize = (size) ? size : alloc_size;
+    unsigned long node = -1, nid = -1; // TODO
+
+    if (alloc_size != psize)
+    	alloc_size = psize;
+
+/* check if the memory is mapped in any zone of the current
+ * kernel instance. In such a case the memory will not be mapped
+ * because mapped in the memory page table array.
+ */
+    for_each_online_node(nid) {
+            unsigned long start_pfn, end_pfn;
+            start_pfn = node_start_pfn(nid);
+            end_pfn = node_end_pfn(nid);
+            if ((start_pfn <= pfn) && (pfn < end_pfn)) {
+                    node = nid;
+                    break; // node found continue
+            }
+    }
+
+    if (node == -1) { // page never mapped (why?)
+    	 virtual_address = ioremap_cache(
+    			 (resource_size_t)((void *) poff), alloc_size);
+    } else {
+    	struct page *shared_page;
+    	shared_page = pfn_to_page(pfn);
+    	virtual_address = page_address(shared_page);
+    	void * kmap_addr = kmap(shared_page);
+    	printk(KERN_INFO "%s: pages were mapped! page_address %p kmap_addr %p",
+    			__func__, virtual_address, kmap_addr);
+    }
+
+    alloc_addr = (unsigned long)virtual_address; // set the allocated address to the virtual address
+
+    printk(KERN_ALERT "%s: poff %p vaddr 0x%lx size %lu (0x%lx)\n",
+    		__func__, poff, alloc_addr, alloc_size, alloc_size);
+
+    if (alloc_addr)
+    	return 0;
+    else
+    	return -1;
+}
+
+void* __alloc_on_node(size_t size, int node)
+{
+	int asize = 0x100000; // TODO check, improve and determine the size
+	int anode = node +1;
+	void* shmaddr = (void*)(alloc_addr +
+			(unsigned long)(anode * asize));
+
+	if (size > asize) {
+		printk(KERN_ERR "%s: size %ld node %d asize %d ERROR\n",
+				__func__, size, node, asize);
+		return 0;
+	}
+
+	return shmaddr;
+}
+
+// do not use shared memory (local copy on private memory
+void* __alloc_private(size_t size, int node) {
+        return kmalloc(size, GFP_KERNEL);
+}
+
+/////////////////////////////////////////////////////////////////////
+
+
+/// matrix memory
+
+static int matrix_init_matrix (matrix_comm ** pmatrix, int elements)
+{
+	char matrix_magic[]= MAGIC_CHARS_MATR;
+	int need_init =0;
+
+	// actual matrix that takes care about the mapping
+	//matrix_comm * matrix = (matrix_comm *)alloc_global(sizeof(matrix_comm));
+	matrix_comm * matrix = (matrix_comm *)alloc_global(sizeof(matrix_comm));
+	if (!matrix) {
+		printk(KERN_ERR "%s: error allocating matrix_comm\n",
+				__func__);
+ 		return -1;
+	}
+
+	// check if the area was allocated before
+	if ( memcmp(matrix, matrix_magic, 4) == 0) {
+		// it was initialized before, sanity checks
+		if (matrix->elements != elements) {
+			printk(KERN_ERR "%s: matrix elements not correspond %d %d\n",
+					__func__, matrix->elements, elements);
+			return -1;
+		}
+	}
+	else {
+        printk("mcomm: Initializing matrix\n");
+		// it was never initialized before,
+		need_init =1;
+
+		//Initialize the main matrix descriptor
+		memcpy(matrix, matrix_magic, 4);
+        matrix->lock = 0;
+		matrix->elements = elements;
+        printk("mcomm: Set matrix elements to %d\n",matrix->elements);
+		//matrix->lock = 0;
+        printk("mcomm: Verified(0) matrix elements to be %d\n",matrix->elements);
+		//memset (&(matrix->present), 0, sizeof(bitmask_t));
+        memset (matrix->present, 0, sizeof(matrix->present));
+        printk("mcomm: Verified(1) matrix elements to be %d\n",matrix->elements);
+		//memset (&(matrix->desc[0]), 0, sizeof(void*) * elements);
+        memset (matrix->desc, 0, sizeof(matrix->desc));
+        printk("mcomm: Verified(2) matrix elements to be %d\n",matrix->elements);
+	}
+
+	if (pmatrix) {
+        printk("mcomm: Setting pmatrix out\n");
+		*pmatrix = matrix;
+    }
+
+	return need_init;
+}
+
+static int matrix_init_row (row_comm ** prow, matrix_comm * matrix,
+		int size, int need_init, int id, int elements)
+{
+	char row_magic[]= MAGIC_CHARS_ROW;
+	int l;
+	int need_init_cell =0;
+
+	/* this code will not use bbuffer_init */
+	int bbuf_pad_size = size;
+#ifdef CACHE_ALIGNED
+	bbuf_pad_size = BBUFFER_SPACE(size);
+#endif /* CACHE_ALIGNED */
+	printk("%s: bbuf_pad_size 0x%x buffer_limit 0x%lx\n",
+			__func__, bbuf_pad_size, (unsigned long)BBUFFER_LIMIT);
+	BBUFFER_CHECK(bbuf_pad_size);
+
+	/* for each cpu there is a vector of recveirs buffers */
+	int bbuf_size = BBUFFER_SIZEOF(bbuf_pad_size);
+	int row_memory =
+			sizeof(row_comm) + (bbuf_size * elements);
+
+
+	// we need to pass the cpuid in order to get the right shm area
+	// is the alloc function that has to figure out the correct mem zone
+	row_comm * row = (row_comm * ) alloc_on_node(row_memory, id);
+	if ( !(row) ) {
+		printk(KERN_ERR"%s: error allocating row_comm\n",
+				__func__);
+		return 0;
+	}
+	printk("%s: row_memory %d (0x%x) id %d row %p\n",
+			__func__, row_memory, row_memory, id, row);
+	CHECK_CACHE_ALIGNED(row);
+	matrix->desc[id] = row; // TODO
+
+	// if init is not required check if the area was allocated before
+	if ( !need_init && (memcmp(row, row_magic, 4) == 0)) {
+		need_init_cell=0;
+
+		// it was initialized before, sanity checks
+		if (row->elements != elements) {
+			printk(KERN_ERR "%s: row elements not correspond %d %d\n",
+					__func__, row->elements, elements);
+			return 0;
+		}
+		if (row->csize != bbuf_size) {
+			printk(KERN_ERR "%s: size not correspond %d %d\n",
+					__func__, row->csize, bbuf_size);
+			return 0;
+		}
+	}
+	else {
+		// it was never initialized before
+		need_init_cell =1;
+
+		memcpy(row, row_magic, 4);
+		row->elements = elements;
+		row->id = id;
+		row->lock = 0;
+
+		memset(&(row->status), 0, sizeof(bitmask_t) * MAX_BITMAP);
+		memset(&(row->active), 0, sizeof(bitmask_t) * MAX_BITMAP);
+		memset(&(row->offset), 0, sizeof(unsigned long) * MAX_ELEMENTS);
+
+		row->csize = bbuf_size;
+		row->cnumber = 0;
+	}
+
+	// check the alignment
+	printk("%s: row_status %p row %p\n",
+			__func__, &(row->status), &(row[1]));
+	CHECK_CACHE_ALIGNED( (&(row->status)) );
+
+	bbuffer_t * pbbuf = (bbuffer_t*)&(row[1]);
+	CHECK_CACHE_ALIGNED( pbbuf );
+
+	// init local data structures if required
+	if (need_init_cell)
+		for (l=0; l<elements; l++) {
+			BBUFFER_INIT(pbbuf, bbuf_pad_size);
+
+			row->offset[l] =
+					(unsigned long)pbbuf - (unsigned long)((bbuffer_t*)&(row[1]));
+			pbbuf = (bbuffer_t*)((void*)pbbuf + bbuf_size);
+
+			set_bit_bitmap(&(row->active[0]), l);
+		}
+
+	if (prow)
+		*prow = row;
+
+	return need_init_cell;
+}
+
+/*
+ * size is the size of a single message cell buffer
+ * elements is the maximum number of rows or columns
+ *
+ * The returned value refer to a private local comm_mapping struct
+ * such data structure saves the mappings of the different memory areas
+ */
+comm_mapping * matrix_init_mapping (int size, int elements )
+{
+	int i;
+	int need_init =0;
+
+	matrix_comm * matrix;
+
+	/* arguments checks */
+	if ((elements < 1) || (elements > MAX_CPUS) || !(size))
+		return 0;
+
+	need_init = matrix_init_matrix( &matrix, elements);
+	if (need_init == -1)
+		return 0;
+
+    printk("mcomm: matrix_init_mapping - matrix->elements: %d\r\n", matrix->elements);
+
+	// create a comm_mapping descriptor
+	comm_mapping * map = (comm_mapping*)
+			alloc_private(sizeof(comm_mapping), -1);
+	if (!map) {
+		printk(KERN_ERR "%s: error allocating comm_mapping id %d\n",
+				__func__, -1);
+		return 0;
+	}
+	memset (map, 0, sizeof(comm_mapping));
+	map->matrix = matrix;
+
+
+	// allocate and init local data structures
+	for (i=0; i<elements; i++) {
+
+		row_comm * row = 0;
+		int need_init_cell = matrix_init_row (&row, matrix,
+						size, need_init, i, elements);
+		if ( need_init_cell == -1 )
+			return 0;
+
+		// save the private mapping
+		map->row[i] = row;
+		map->bmp[i] = &(row->status[0]);
+		map->buf[i] = (bbuffer_t *) &(row[1]);
+
+		// set the global descriptor
+		set_bit_bitmap(&(matrix->present[0]), i); // TODO move this to next function?
+	}
+
+	return map;
+}
+
+/*
+ * This function assumes that a previous call to matrix_init_mapping was issued
+ * and the shared data areas are mapped to memory (shared data areas corrensponds to
+ * MPICH segments
+ */
+comm_buffers * matrix_init_buffers(comm_mapping * map, int id)
+{
+	int i;
+	int elements =0, bbuf_size =0;
+
+
+	/* arguments checks */
+	if ( !(map) || (id < 0) || (id >= MAX_CPUS) )
+		return 0;
+	if ( !(map->matrix) || !(map->row[id]) )
+		return 0;
+
+
+	/* reload the arguments */
+	elements = map->matrix->elements;
+    printk("mcomm: matrix_init_buffers - map->matrix->elements: %d\r\n", map->matrix->elements);
+	bbuf_size = map->row[id]->csize;
+
+	/* create a comm_buffers descriptor */
+	comm_buffers * buffs = (comm_buffers*)
+			alloc_private(sizeof(comm_buffers), id);
+	if (!buffs) {
+		printk(KERN_ERR "%s: error allocating comm_buffers id %d\n",
+				__func__, id);
+		return 0;
+	}
+	memset(buffs, 0, sizeof(comm_buffers));
+
+	/* init the private data structure */
+	buffs->id = id;
+	buffs->elements = elements;
+	buffs->recv_bmp = map->bmp[id];
+
+	/* cells of this row */
+	for (i=0; i<elements; i++)
+		buffs->recv_buf[i] = (void*) map->buf[id] + (bbuf_size * i);
+
+	/* cross references */
+	for (i=0; i<elements; i++) {
+		buffs->send[i].bmp = map->bmp[i];
+		buffs->send[i].buf = (void*) map->buf[i] + (bbuf_size * id);
+	}
+
+	return buffs;
+}
+
+// point to point send
+int matrix_send_to(comm_buffers * buffs, int dest, char* buff, int count)
+{
+	register bbuffer_t * bb;
+
+	/* check if the vector is valid */
+	if (!buffs) {
+        printk("mcomm: matrix_send_to - buffs invalid\r\n");
+		return 0;
+    }
+	/* check if the cpu is in range */
+	if (!(dest < buffs->elements)) {
+        printk("mcomm: matrix_send_to - cpu out of range. Dst: %d, Elements: %d\r\n",dest,buffs->elements);
+		return 0;
+    }
+	/* check if the destination recv buffer is registered */
+	if (!(bb = buffs->send[dest].buf)) {
+        printk("mcomm: matrix_send_to - destination recv buffer not registered\r\n");
+		return 0;
+    }
+
+	register int a;
+#ifdef USE_MBUFFER
+	a = mbuffer_put(bb, buff, count);
+#else
+	a = bbuffer_put(bb, buff, count);
+#endif
+
+	if (a > 0)
+		set_bit_bitmap(buffs->send[dest].bmp, buffs->id);
+	return a;
+}
+
+int matrix_send_self(comm_buffers * buffs, char* buff, int count)
+{
+	if ( !buffs )
+		return 0;
+
+	return matrix_send_to(buffs, buffs->id, buff, count);
+}
+
+// point to point recv functions
+
+int matrix_recv_from(comm_buffers* buffs, int src, char* buff, int count)
+{
+	register bbuffer_t * bb;
+
+	/* check if the vector is valid */
+	if (!buffs)
+		return 0;
+	/* check if the cpu is in range */
+	if (!(src < buffs->elements))
+		return 0;
+	/* check if our recv buffer is registered */
+	if (!(bb = buffs->recv_buf[src]))
+		return 0;
+
+	// we choose to do not use the bitmap here but only as a best
+
+	register int a;
+#ifdef USE_MBUFFER
+	a = mbuffer_get(bb, buff, count);
+#else
+	a = bbuffer_get(bb, buff, count);
+#endif
+
+	if (a > 0)
+		if (!bbuffer_count(bb))
+			clear_bit_bitmap(buffs->recv_bmp, src);
+	return a;
+}
+
+int matrix_recv_self(comm_buffers* buffs, char* buff, int count)
+{
+	return matrix_recv_from(buffs, buffs->id, buff, count);
+}
+
+comm_buffers* matrix_get_buffers() {
+    return cbuf;
+}
+
+
+static int __init mcomm_init(void)
+{
+	if ( !mcomm_address ) {
+		printk(KERN_ERR"MATRIX Communicator @ 0x%lx. Cannot Initialize\n",
+				mcomm_address);
+		return -1;
+	}
+
+	printk("MATRIX Communicator @ 0x%lx cpuid %d. Initialization\n",
+			mcomm_address, smp_processor_id());
+
+	if(-1 == alloc_init((void*)mcomm_address, 0)) {
+        printk("MATRIX Communicator alloc_init error\n");
+    }
+
+	cmap = matrix_init_mapping(COMM_BUFFS_SIZE, COMM_CPU_NUM);
+	cbuf = matrix_init_buffers(cmap, smp_processor_id());
+
+	printk("MATRIX Communicator cmap %p cbuf %p\n", cmap, cbuf);
+	return 0;
+}
+__initcall(mcomm_init);
+
+
+static int __init _mcomm_param(char *str)
+{
+	if (!str)
+		return -EINVAL;
+
+	mcomm_address = simple_strtoull(str, 0, 16);
+	//mcomm_address = simple_strtoull(str, 0, 0); //automatically discover the base
+
+    return 0;
+}
+
+early_param("mcomm", _mcomm_param);
diff --git a/kernel/Kconfig.popcorn b/kernel/Kconfig.popcorn
new file mode 100644
index 0000000..a371e8f
--- /dev/null
+++ b/kernel/Kconfig.popcorn
@@ -0,0 +1,39 @@
+menu "Popcorn Multi-Kernel Support"
+
+# This is selected by all the architectures Popcorn supports
+config HAVE_POPCORN_ARCH_SUPPORT
+	bool
+
+config POPCORN
+	bool "Popcorn Multi-Kernel Support"
+	depends on HAVE_POPCORN_ARCH_SUPPORT
+	default y
+	help
+		Enable or disable the Popcorn multi-kernel Linux support.
+
+config DEBUG_POPCORN
+	bool "Popcorn debugging messages in kernel log"
+	depends on POPCORN
+	default n
+	help
+		Enable or disable kernel messages that can help debug Popcorn issues.
+
+config POPCORN_KMSG
+	bool "Popcorn Inter-Kernel Messaging Support"
+	depends on POPCORN
+	default y
+	help
+		Enable or disable support for inter-kernel messaging in Popcorn.
+
+config POPCORN_UMSG
+	bool "Popcorn Inter-Kernel Userspace Messaging Support"
+	depends on POPCORN_KMSG
+	default n
+	help
+		Enable or disable support for messaging between userspace processes
+		on different kernels in Popcorn.
+
+comment "Popcorn is not currently supported on your architecture"
+	depends on !HAVE_POPCORN_ARCH_SUPPORT
+
+endmenu
diff --git a/kernel/Makefile b/kernel/Makefile
index e898c5b..78efde4 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -10,7 +10,7 @@ obj-y     = sched.o fork.o exec_domain.o panic.o printk.o \
 	    kthread.o wait.o kfifo.o sys_ni.o posix-cpu-timers.o mutex.o \
 	    hrtimer.o rwsem.o nsproxy.o srcu.o semaphore.o \
 	    notifier.o ksysfs.o sched_clock.o cred.o \
-	    async.o range.o
+	    async.o range.o multikernel.o process_server.o 
 obj-y += groups.o
 
 ifdef CONFIG_FUNCTION_TRACER
@@ -24,6 +24,7 @@ CFLAGS_REMOVE_sched_clock.o = -pg
 CFLAGS_REMOVE_irq_work.o = -pg
 endif
 
+obj-$(CONFIG_POPCORN) += multikernel.o
 obj-$(CONFIG_FREEZER) += freezer.o
 obj-$(CONFIG_PROFILING) += profile.o
 obj-$(CONFIG_SYSCTL_SYSCALL_CHECK) += sysctl_check.o
diff --git a/kernel/cpuset.c b/kernel/cpuset.c
index 0b1712d..c43ca37 100644
--- a/kernel/cpuset.c
+++ b/kernel/cpuset.c
@@ -2177,9 +2177,7 @@ void __init cpuset_init_smp(void)
 {
 	cpumask_copy(top_cpuset.cpus_allowed, cpu_active_mask);
 	top_cpuset.mems_allowed = node_states[N_HIGH_MEMORY];
-
 	hotplug_memory_notifier(cpuset_track_online_nodes, 10);
-
 	cpuset_wq = create_singlethread_workqueue("cpuset");
 	BUG_ON(!cpuset_wq);
 }
diff --git a/kernel/exit.c b/kernel/exit.c
index e6e01b9..45a0e6a 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -52,6 +52,8 @@
 #include <linux/hw_breakpoint.h>
 #include <linux/oom.h>
 
+#include <linux/process_server.h>
+
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 #include <asm/pgtable.h>
@@ -893,6 +895,13 @@ NORET_TYPE void do_exit(long code)
 	struct task_struct *tsk = current;
 	int group_dead;
 
+    /*
+     * Multikernel
+     */
+    if(tsk->executing_for_remote) {
+        process_server_task_exit_notification(tsk->pid);
+    }
+
 	profile_task_exit(tsk);
 
 	WARN_ON(blk_needs_flush_plug(tsk));
diff --git a/kernel/fork.c b/kernel/fork.c
index 0acf42c..6bb837a 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -68,6 +68,12 @@
 #include <linux/khugepaged.h>
 #include <linux/signalfd.h>
 
+/**
+ * DK
+ */
+#include <linux/process_server.h>
+#include <linux/sched.h>
+
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -1535,19 +1541,24 @@ long do_fork(unsigned long clone_flags,
 		 * and set the child going.
 		 */
 		p->flags &= ~PF_STARTING;
-
+        
+        p->represents_remote = 0;
+        p->executing_for_remote = 0;
+        p->clone_flags = clone_flags;
 		wake_up_new_task(p);
 
-		/* forking complete and child started to run, tell ptracer */
-		if (unlikely(trace))
-			ptrace_event(trace, nr);
+        /* forking complete and child started to run, tell ptracer */
+        if (unlikely(trace))
+            ptrace_event(trace, nr);
+
+        if (clone_flags & CLONE_VFORK) {
+            freezer_do_not_count();
+            wait_for_completion(&vfork);
+            freezer_count();
+            ptrace_event(PTRACE_EVENT_VFORK_DONE, nr);
+        }
+
 
-		if (clone_flags & CLONE_VFORK) {
-			freezer_do_not_count();
-			wait_for_completion(&vfork);
-			freezer_count();
-			ptrace_event(PTRACE_EVENT_VFORK_DONE, nr);
-		}
 	} else {
 		nr = PTR_ERR(p);
 	}
diff --git a/kernel/kmod.c b/kernel/kmod.c
index a4bea97..7793a2d 100644
--- a/kernel/kmod.c
+++ b/kernel/kmod.c
@@ -40,6 +40,11 @@
 
 #include <trace/events/module.h>
 
+/*
+ * Multikernel
+ */
+#include <linux/process_server.h>
+
 extern int max_threads;
 
 static struct workqueue_struct *khelper_wq;
@@ -179,12 +184,34 @@ static int ____call_usermodehelper(void *data)
 
 	commit_creds(new);
 
+    /*
+     * Multikernel
+     * Handle delegation case
+     */
+    if (sub_info->delegated) {
+
+        // Copy identity information to current task.
+        current->clone_request_id = sub_info->clone_request_id;
+        current->remote_pid = sub_info->remote_pid;
+        current->remote_cpu = sub_info->remote_cpu;
+        current->executing_for_remote = 1;
+        current->represents_remote = 0;
+        memcpy(&current->remote_regs, &sub_info->remote_regs, sizeof(struct pt_regs) );
+
+        // Notify of PID/PID pairing.
+        process_server_notify_delegated_subprocess_starting(current->pid,sub_info->remote_pid,sub_info->remote_cpu);
+    } 
+
 	retval = kernel_execve(sub_info->path,
 			       (const char *const *)sub_info->argv,
 			       (const char *const *)sub_info->envp);
+    
 
 	/* Exec failed? */
 fail:
+
+    printk("kmod exec failed retval{%d}\n",retval);
+
 	sub_info->retval = retval;
 	do_exit(0);
 }
@@ -370,6 +397,7 @@ struct subprocess_info *call_usermodehelper_setup(char *path, char **argv,
 	sub_info->path = path;
 	sub_info->argv = argv;
 	sub_info->envp = envp;
+    sub_info->delegated = 0;  // multikernel
   out:
 	return sub_info;
 }
diff --git a/kernel/multikernel.c b/kernel/multikernel.c
new file mode 100644
index 0000000..19f9447
--- /dev/null
+++ b/kernel/multikernel.c
@@ -0,0 +1,58 @@
+/*
+ * Boot parameters and other support stuff for MKLinux
+ *
+ * (C) Ben Shelton <beshelto@vt.edu> 2012
+ */
+
+#include <linux/rcupdate.h>
+#include <linux/rculist.h>
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include <linux/percpu.h>
+#include <linux/init.h>
+#include <linux/gfp.h>
+#include <linux/smp.h>
+#include <linux/cpu.h>
+#include <linux/syscalls.h>
+
+extern unsigned long orig_boot_params;
+
+int mklinux_boot;
+EXPORT_SYMBOL(mklinux_boot);
+
+static int __init setup_mklinux(char *arg)
+{
+        mklinux_boot = 1;
+        return 0;
+}
+early_param("mklinux", setup_mklinux);
+
+
+/* We're going to put our syscall here, since we need to pass in
+   two arguments but the reboot syscall only takes one */
+
+SYSCALL_DEFINE2(multikernel_boot, int, cpu, unsigned long, kernel_start_address)
+{
+	int apicid, apicid_1;
+
+	printk("multikernel boot: got to multikernel_boot syscall, cpu %d, apicid %d (%x), kernel start address 0x%lx\n",
+			cpu, apic->cpu_present_to_apicid(cpu), BAD_APICID,kernel_start_address);
+
+	apicid_1 = per_cpu(x86_bios_cpu_apicid, cpu);
+
+	apicid = apic->cpu_present_to_apicid(cpu);
+	if (apicid == BAD_APICID)
+		printk(KERN_ERR"The CPU is not present in the current present_mask (OK to continue), apicid = %d, apicid_1 = %d\n", apicid, apicid_1);
+	else {
+		printk(KERN_ERR"The CPU is currently running with this kernel instance. First put it offline and then continue. apicid = %d, apicid_1 = %d\n", apicid, apicid_1);
+		return -1;
+	}
+	apicid = per_cpu(x86_bios_cpu_apicid, cpu);  
+	return mkbsp_boot_cpu(apicid, cpu, kernel_start_address);
+}
+
+SYSCALL_DEFINE0(get_boot_params_addr)
+{
+	printk("POPCORN: syscall to return phys addr of boot_params structure\n");
+	return orig_boot_params;
+}
diff --git a/kernel/process_server.c b/kernel/process_server.c
new file mode 100644
index 0000000..a2f712e
--- /dev/null
+++ b/kernel/process_server.c
@@ -0,0 +1,1745 @@
+/**
+ * Serve up processes to a remote client cpu
+ *
+ * DKatz
+ */
+
+#include <linux/mcomm.h> // IPC
+#include <linux/kthread.h>
+#include <linux/export.h>
+#include <linux/delay.h>
+#include <linux/smp.h>
+#include <linux/sched.h>
+#include <linux/threads.h> // NR_CPUS
+#include <linux/kmod.h>
+#include <linux/path.h>
+#include <linux/mount.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/process_server.h>
+#include <linux/mm.h>
+#include <linux/io.h> // ioremap
+#include <linux/mman.h> // MAP_ANONYMOUS
+#include <linux/pcn_kmsg.h> // Messaging
+
+#include <asm/tlbflush.h>
+#include <asm/cacheflush.h>
+#include <asm/uaccess.h> // USER_DS
+#include <asm/prctl.h> // prctl
+#include <asm/proto.h> // do_arch_prctl
+#include <asm/msr.h> // wrmsr_safe
+
+/**
+ * Use the preprocessor to turn off printk.
+ */
+#define PROCESS_SERVER_VERBOSE 0
+#if PROCESS_SERVER_VERBOSE
+#define PSPRINTK(...) printk(__VA_ARGS__)
+#else
+#define PSPRINTK(...) ;
+#endif
+
+/**
+ * Library data type definitions
+ */
+#define PROCESS_SERVER_DATA_TYPE_TEST 0
+#define PROCESS_SERVER_VMA_DATA_TYPE 1
+#define PROCESS_SERVER_PTE_DATA_TYPE 2
+#define PROCESS_SERVER_CLONE_DATA_TYPE 3
+
+/**
+ * Library
+ */
+
+/**
+ * Some piping for linking data entries
+ * and identifying data entry types.
+ */
+typedef struct _data_header {
+    struct _data_header* next;
+    struct _data_header* prev;
+    int data_type;
+} data_header_t;
+
+/**
+ * Hold data about a pte to vma mapping.
+ */
+typedef struct _pte_data {
+    data_header_t header;
+    int vma_id;
+    int clone_request_id;
+    int cpu;
+    unsigned long vaddr;
+    unsigned long paddr;
+    unsigned long pfn;
+} pte_data_t;
+
+/**
+ * Hold data about a vma to process
+ * mapping.
+ */
+typedef struct _vma_data {
+    data_header_t header;
+    spinlock_t lock;
+    unsigned long start;
+    unsigned long end;
+    int clone_request_id;
+    int cpu;
+    unsigned long flags;
+    int vma_id;
+    pgprot_t prot;
+    unsigned long pgoff;
+    pte_data_t* pte_list;
+    int mmapping_in_progress;
+    char path[256];
+} vma_data_t;
+
+/**
+ *
+ */
+typedef struct _clone_data {
+    data_header_t header;
+    spinlock_t lock;
+    int clone_request_id;
+    int requesting_cpu;
+    char exe_path[512];
+    unsigned long clone_flags;
+    unsigned long stack_start;
+    unsigned long stack_ptr;
+    unsigned long env_start;
+    unsigned long env_end;
+    unsigned long arg_start;
+    unsigned long arg_end;
+    unsigned long heap_start;
+    unsigned long heap_end;
+    struct pt_regs regs;
+    int placeholder_pid;
+    int placeholder_tgid;
+    int placeholder_cpu;
+    unsigned long thread_fs;
+    unsigned long thread_gs;
+    unsigned long thread_sp0;
+    unsigned long thread_sp;
+    unsigned long thread_usersp;
+    unsigned short thread_es;
+    unsigned short thread_ds;
+    unsigned short thread_fsindex;
+    unsigned short thread_gsindex;
+    vma_data_t* vma_list;
+    vma_data_t* pending_vma_list;
+} clone_data_t;
+
+/**
+ * This message is sent to a remote cpu in order to 
+ * ask it to spin up a process on behalf of the
+ * requesting cpu.  Some of these fields may go
+ * away in the near future.
+ */
+typedef struct _clone_request {
+    struct pcn_kmsg_hdr header;
+    int clone_request_id;
+    unsigned long clone_flags;
+    unsigned long stack_start;
+    unsigned long stack_ptr;
+    unsigned long env_start;
+    unsigned long env_end;
+    unsigned long arg_start;
+    unsigned long arg_end;
+    unsigned long heap_start;
+    unsigned long heap_end;
+    struct pt_regs regs;
+    char exe_path[512];
+    int placeholder_pid;
+    int placeholder_tgid;
+    unsigned long thread_fs;
+    unsigned long thread_gs;
+    unsigned long thread_sp0;
+    unsigned long thread_sp;
+    unsigned long thread_usersp;
+    unsigned short thread_es;
+    unsigned short thread_ds;
+    unsigned short thread_fsindex;
+    unsigned short thread_gsindex;
+} clone_request_t;
+
+/**
+ * This message is sent in response to a clone request.
+ * Its purpose is to notify the requesting cpu that
+ * the specified pid is executing on behalf of the
+ * requesting cpu.
+ */
+typedef struct _create_process_pairing {
+    struct pcn_kmsg_hdr header;
+    int your_pid; // PID of cpu receiving this pairing request
+    int my_pid;   // PID of cpu transmitting this pairing request
+} create_process_pairing_t;
+
+/**
+ * This message informs the remote cpu of delegated
+ * process death.  This occurs whether the process
+ * is a placeholder or a delegate locally.
+ */
+typedef struct _exiting_process {
+    struct pcn_kmsg_hdr header;
+    int my_pid; // PID of process on cpu transmitting this exit notification.
+} exiting_process_t;
+
+/**
+ * Inform remote cpu of a vma to process mapping.
+ */
+typedef struct _vma_transfer {
+    struct pcn_kmsg_hdr header;
+    int vma_id;
+    int clone_request_id;
+    unsigned long start;
+    unsigned long end;
+    pgprot_t prot;
+    unsigned long flags;
+    unsigned long pgoff;
+    char path[256];
+} vma_transfer_t;
+
+/**
+ * Inform remote cpu of a pte to vma mapping.
+ */
+typedef struct _pte_transfer {
+    struct pcn_kmsg_hdr header;
+    int vma_id;
+    int clone_request_id;
+    unsigned long vaddr;
+    unsigned long paddr;
+    unsigned long pfn;
+} pte_transfer_t;
+
+/**
+ *
+ */
+typedef struct _deconstruction_data {
+    int clone_request_id;
+    int vma_id;
+    int dst_cpu;
+} deconstruction_data_t;
+
+typedef struct {
+    struct work_struct work;
+    clone_data_t* clone_data;
+} clone_exec_work_t;
+
+typedef struct {
+    struct work_struct work;
+    pid_t pid;
+} exit_work_t;
+
+/**
+ * Prototypes
+ */
+static int handle_clone_request(struct pcn_kmsg_message* msg);
+long process_server_clone(unsigned long clone_flags,
+                          unsigned long stack_start,                                                                                                                   
+                          struct pt_regs *regs,
+                          unsigned long stack_size,
+                          struct task_struct* task);
+static vma_data_t* find_vma_data(clone_data_t* clone_data, unsigned long addr_start);
+static clone_data_t* find_clone_data(int cpu, int clone_request_id);
+static void dump_mm(struct mm_struct* mm);
+static void dump_task(struct task_struct* task,struct pt_regs* regs,unsigned long stack_ptr);
+static void dump_thread(struct thread_struct* thread);
+static void dump_regs(struct pt_regs* regs);
+static void dump_stk(struct thread_struct* thread, unsigned long stack_ptr); 
+
+/**
+ * Module variables
+ */
+static struct task_struct* process_server_task = NULL;     // Remember the kthread task_struct
+static int _vma_id = 0;
+static int _clone_request_id = 0;
+static int _cpu = -1;
+data_header_t* _data_head = NULL;        // General purpose data store
+DEFINE_SPINLOCK(_data_head_lock);        // Lock for _data_head
+DEFINE_SPINLOCK(_vma_id_lock);           // Lock for _vma_id
+DEFINE_SPINLOCK(_clone_request_id_lock); // Lock for _clone_request_id
+
+// Exec list
+static struct workqueue_struct *clone_wq;
+static struct workqueue_struct *exit_wq;
+
+
+
+/**
+ * General helper functions and debugging tools
+ */
+
+/**
+ *
+ */
+void dump_task(struct task_struct* task, struct pt_regs* regs, unsigned long stack_ptr) {
+#if PROCESS_SERVER_VERBOSE
+    if (!task) return;
+
+    PSPRINTK("DUMP TASK\n");
+    PSPRINTK("PID: %d\n",task->pid);
+    PSPRINTK("State: %lx\n",task->state);
+    PSPRINTK("Flags: %x\n",task->flags);
+    PSPRINTK("Prio{%d},Static_Prio{%d},Normal_Prio{%d}\n",
+            task->prio,task->static_prio,task->normal_prio);
+    PSPRINTK("Represents_remote{%d}\n",task->represents_remote);
+    PSPRINTK("Executing_for_remote{%d}\n",task->executing_for_remote);
+    PSPRINTK("Remote_pid{%d}\n",task->remote_pid);
+    PSPRINTK("Remote_cpu{%d}\n",task->remote_cpu);
+    PSPRINTK("Clone_request_id{%d}\n",task->clone_request_id);
+    dump_regs(regs);
+    dump_thread(&task->thread);
+    dump_mm(task->mm);
+    dump_stk(&task->thread,stack_ptr);
+    PSPRINTK("TASK DUMP COMPLETE\n");
+#endif
+}
+
+/**
+ *
+ */
+static void dump_stk(struct thread_struct* thread, unsigned long stack_ptr) {
+    int i;
+    if(!thread) return;
+    PSPRINTK("DUMP STACK\n");
+    if(thread->sp) {
+        PSPRINTK("sp = %lx\n",thread->sp);
+        for(i = 0; i <= 8; i++) {
+            PSPRINTK("stack peak %lx at %lx\n",*(unsigned long*)(thread->sp + i*8), thread->sp + i*8); 
+        }
+    }
+    if(thread->usersp) {
+        PSPRINTK("usersp = %lx\n",thread->usersp);
+        for(i = 0; i <= 8; i++) {
+            PSPRINTK("stack peak %lx at %lx\n",*(unsigned long*)(thread->usersp + i*8), thread->usersp + i*8);
+        }
+    }
+    if(stack_ptr) {
+        PSPRINTK("stack_ptr = %lx\n",stack_ptr);
+        for(i = 0; i <= 8; i++) {
+            PSPRINTK("stack peak %lx at %lx\n",*(unsigned long*)(stack_ptr + i*8), stack_ptr + i*8);
+        }
+    }
+    PSPRINTK("STACK DUMP COMPLETE\n");
+}
+
+/**
+ *
+ */
+static void dump_regs(struct pt_regs* regs) {
+    unsigned long fs, gs;
+    PSPRINTK("DUMP REGS\n");
+    if(NULL != regs) {
+        PSPRINTK("r15{%lx}\n",regs->r15);   
+        PSPRINTK("r14{%lx}\n",regs->r14);
+        PSPRINTK("r13{%lx}\n",regs->r13);
+        PSPRINTK("r12{%lx}\n",regs->r12);
+        PSPRINTK("r11{%lx}\n",regs->r11);
+        PSPRINTK("r10{%lx}\n",regs->r10);
+        PSPRINTK("r9{%lx}\n",regs->r9);
+        PSPRINTK("r8{%lx}\n",regs->r8);
+        PSPRINTK("bp{%lx}\n",regs->bp);
+        PSPRINTK("bx{%lx}\n",regs->bx);
+        PSPRINTK("ax{%lx}\n",regs->ax);
+        PSPRINTK("cx{%lx}\n",regs->cx);
+        PSPRINTK("dx{%lx}\n",regs->dx);
+        PSPRINTK("di{%lx}\n",regs->di);
+        PSPRINTK("orig_ax{%lx}\n",regs->orig_ax);
+        PSPRINTK("ip{%lx}\n",regs->ip);
+        PSPRINTK("cs{%lx}\n",regs->cs);
+        PSPRINTK("flags{%lx}\n",regs->flags);
+        PSPRINTK("sp{%lx}\n",regs->sp);
+        PSPRINTK("ss{%lx}\n",regs->ss);
+    }
+    rdmsrl(MSR_FS_BASE, fs);
+    rdmsrl(MSR_GS_BASE, gs);
+    PSPRINTK("fs{%lx}\n",fs);
+    PSPRINTK("gs{%lx}\n",gs);
+    PSPRINTK("REGS DUMP COMPLETE\n");
+}
+
+/**
+ *
+ */
+static void dump_thread(struct thread_struct* thread) {
+    PSPRINTK("DUMP THREAD\n");
+    PSPRINTK("sp0{%lx}, sp{%lx}\n",thread->sp0,thread->sp);
+    PSPRINTK("usersp{%lx}\n",thread->usersp);
+    PSPRINTK("es{%x}\n",thread->es);
+    PSPRINTK("ds{%x}\n",thread->ds);
+    PSPRINTK("fsindex{%x}\n",thread->fsindex);
+    PSPRINTK("gsindex{%x}\n",thread->gsindex);
+    if(thread->fs) PSPRINTK("fs{%lx} - %lx\n",thread->fs,*((unsigned long*)thread->fs));
+    PSPRINTK("gs{%lx}\n",thread->gs);
+    PSPRINTK("THREAD DUMP COMPLETE\n");
+}
+
+static void dump_pte_data(pte_data_t* p) {
+    PSPRINTK("PTE_DATA\n");
+    PSPRINTK("vma_id{%x}\n",p->vma_id);
+    PSPRINTK("clone_request_id{%x}\n",p->clone_request_id);
+    PSPRINTK("cpu{%x}\n",p->cpu);
+    PSPRINTK("vaddr{%lx}\n",p->vaddr);
+    PSPRINTK("paddr{%lx}\n",p->paddr);
+    PSPRINTK("pfn{%lx}\n",p->pfn);
+}
+
+static void dump_vma_data(vma_data_t* v) {
+    pte_data_t* p;
+    PSPRINTK("VMA_DATA\n");
+    PSPRINTK("start{%lx}\n",v->start);
+    PSPRINTK("end{%lx}\n",v->end);
+    PSPRINTK("clone_request_id{%x}\n",v->clone_request_id);
+    PSPRINTK("cpu{%x}\n",v->cpu);
+    PSPRINTK("flags{%lx}\n",v->flags);
+    PSPRINTK("vma_id{%x}\n",v->vma_id);
+    PSPRINTK("path{%s}\n",v->path);
+
+    p = v->pte_list;
+    while(p) {
+        dump_pte_data(p);
+        p = (pte_data_t*)p->header.next;
+    }
+}
+
+static void dump_clone_data(clone_data_t* r) {
+    vma_data_t* v;
+    PSPRINTK("CLONE REQUEST\n");
+    PSPRINTK("clone_request_id{%x}\n",r->clone_request_id);
+    PSPRINTK("clone_flags{%lx}\n",r->clone_flags);
+    PSPRINTK("stack_start{%lx}\n",r->stack_start);
+    PSPRINTK("stack_ptr{%lx}\n",r->stack_ptr);
+    PSPRINTK("env_start{%lx}\n",r->env_start);
+    PSPRINTK("env_end{%lx}\n",r->env_end);
+    PSPRINTK("arg_start{%lx}\n",r->arg_start);
+    PSPRINTK("arg_end{%lx}\n",r->arg_end);
+    PSPRINTK("heap_start{%lx}\n",r->heap_start);
+    PSPRINTK("heap_end{%lx}\n",r->heap_end);
+    dump_regs(&r->regs);
+    PSPRINTK("placeholder_pid{%x}\n",r->placeholder_pid);
+    PSPRINTK("placeholder_tgid{%x}\n",r->placeholder_tgid);
+    PSPRINTK("thread_fs{%lx}\n",r->thread_fs);
+    PSPRINTK("thread_gs{%lx}\n",r->thread_gs);
+    PSPRINTK("thread_sp0{%lx}\n",r->thread_sp0);
+    PSPRINTK("thread_sp{%lx}\n",r->thread_sp);
+    PSPRINTK("thread_usersp{%lx}\n",r->thread_usersp);
+
+    v = r->vma_list;
+    while(v) {
+        dump_vma_data(v);
+        v = (vma_data_t*)v->header.next;
+    }
+}
+
+/**
+ *
+ */
+static clone_data_t* find_clone_data(int cpu, int clone_request_id) {
+    data_header_t* curr = NULL;
+    clone_data_t* clone = NULL;
+    clone_data_t* ret = NULL;
+    spin_lock(&_data_head_lock);
+    
+    curr = _data_head;
+    while(curr) {
+        if(curr->data_type == PROCESS_SERVER_CLONE_DATA_TYPE) {
+            clone = (clone_data_t*)curr;
+            if(clone->placeholder_cpu == cpu && clone->clone_request_id == clone_request_id) {
+                ret = clone;
+                break;
+            }
+        }
+        curr = curr->next;
+    }
+
+    spin_unlock(&_data_head_lock);
+
+    return ret;
+}
+
+static void destroy_clone_data(clone_data_t* data) {
+    vma_data_t* vma_data;
+    pte_data_t* pte_data;
+    vma_data = data->vma_list;
+    while(vma_data) {
+        
+        // Destroy this VMA's PTE's
+        pte_data = vma_data->pte_list;
+        while(pte_data) {
+
+            // Remove pte from list
+            vma_data->pte_list = (pte_data_t*)pte_data->header.next;
+            if(vma_data->pte_list) {
+                vma_data->pte_list->header.prev = NULL;
+            }
+
+            // Destroy pte
+            kfree(pte_data);
+
+            // Next is the new list head
+            pte_data = vma_data->pte_list;
+        }
+        
+        // Remove vma from list
+        data->vma_list = (vma_data_t*)vma_data->header.next;
+        if(data->vma_list) {
+            data->vma_list->header.prev = NULL;
+        }
+
+        // Destroy vma
+        kfree(vma_data);
+
+        // Next is the new list head
+        vma_data = data->vma_list;
+    }
+
+    // Destroy clone data
+    kfree(data);
+}
+
+/**
+ *
+ */
+static vma_data_t* find_vma_data(clone_data_t* clone_data, unsigned long addr_start) {
+
+    vma_data_t* curr = clone_data->vma_list;
+    vma_data_t* ret = NULL;
+
+    while(curr) {
+        
+        if(curr->start == addr_start) {
+            ret = curr;
+            break;
+        }
+
+        curr = (vma_data_t*)curr->header.next;
+    }
+
+    return ret;
+}
+
+/**
+ *
+ */
+static int dump_page_walk_pte_entry_callback(pte_t *pte, unsigned long start, unsigned long end, struct mm_walk *walk) {
+
+    if(NULL == pte || !pte_present(*pte)) {                                                                                                                             
+        return 0;
+    }
+
+    PSPRINTK("pte_entry start{%lx}, end{%lx}, phy{%lx}\n",
+            start,
+            end,
+            (unsigned long)(pte_val(*pte) & PHYSICAL_PAGE_MASK) | (start & (PAGE_SIZE-1)));
+    return 0;
+}
+
+/**
+ * Print mm
+ */
+static void dump_mm(struct mm_struct* mm) {
+
+    struct vm_area_struct * curr;
+    struct mm_walk walk = {
+        .pte_entry = dump_page_walk_pte_entry_callback,
+        .mm = mm,
+        .private = NULL
+        };
+    char buf[256];
+
+    if(NULL == mm) {
+        PSPRINTK("MM IS NULL!\n");
+        return;
+    }
+
+    down_read(&mm->mmap_sem);
+
+    curr = mm->mmap;
+
+    PSPRINTK("MM DUMP\n");
+    PSPRINTK("Stack Growth{%lx}\n",mm->stack_vm);
+    PSPRINTK("Code{%lx - %lx}\n",mm->start_code,mm->end_code);
+    PSPRINTK("Brk{%lx - %lx}\n",mm->start_brk,mm->brk);
+    PSPRINTK("Stack{%lx}\n",mm->start_stack);
+    PSPRINTK("Arg{%lx - %lx}\n",mm->arg_start,mm->arg_end);
+    PSPRINTK("Env{%lx - %lx}\n",mm->env_start,mm->env_end);
+
+    while(curr) {
+        if(!curr->vm_file) {
+            PSPRINTK("Anonymous VM Entry: start{%lx}, end{%lx}, pgoff{%lx}, flags{%lx}\n",
+                    curr->vm_start, 
+                    curr->vm_end,
+                    curr->vm_pgoff,
+                    curr->vm_flags);
+            // walk    
+            walk_page_range(curr->vm_start,curr->vm_end,&walk);
+        } else {
+            PSPRINTK("Page VM Entry: start{%lx}, end{%lx}, pgoff{%lx}, path{%s}, flags{%lx}\n",
+                    curr->vm_start,
+                    curr->vm_end,
+                    curr->vm_pgoff,
+                    d_path(&curr->vm_file->f_path,buf, 256),
+                    curr->vm_flags);
+            walk_page_range(curr->vm_start,curr->vm_end,&walk);
+        }
+        curr = curr->vm_next;
+    }
+
+    up_read(&mm->mmap_sem);
+}
+
+/**
+ * Data library
+ */
+
+
+/**
+ * Add data entry
+ */
+static void add_data_entry(void* entry) {
+    data_header_t* hdr = (data_header_t*)entry;
+    data_header_t* curr = NULL;
+
+    if(!entry) {
+        return;
+    }
+
+    spin_lock(&_data_head_lock);
+    
+    if (!_data_head) {
+        _data_head = hdr;
+        hdr->next = NULL;
+        hdr->prev = NULL;
+    } else {
+        curr = _data_head;
+        while(curr->next != NULL) {
+            if(curr == entry) {
+                return;// It's already in the list!
+            }
+            curr = curr->next;
+        }
+        // Now curr should be the last entry.
+        // Append the new entry to curr.
+        curr->next = hdr;
+        hdr->next = NULL;
+        hdr->prev = curr;
+    }
+
+    spin_unlock(&_data_head_lock);
+}
+
+/**
+ * Remove a data entry
+ * Requires user to hold _data_head_lock
+ */
+static void remove_data_entry(void* entry) {
+    data_header_t* hdr = entry;
+
+    if(!entry) {
+        return;
+    }
+
+    if(_data_head == hdr) {
+        _data_head = hdr->next;
+    }
+
+    if(hdr->next) {
+        hdr->next->prev = hdr->prev;
+    }
+
+    if(hdr->prev) {
+        hdr->prev->next = hdr->next;
+    }
+
+    hdr->prev = NULL;
+    hdr->next = NULL;
+
+}
+
+/**
+ * Print information about the list.
+ */
+static void dump_data_list() {
+    data_header_t* curr = NULL;
+    pte_data_t* pte_data = NULL;
+    vma_data_t* vma_data = NULL;
+    clone_data_t* clone_data = NULL;
+
+    spin_lock(&_data_head_lock);
+
+    curr = _data_head;
+
+    PSPRINTK("DATA LIST:\n");
+    while(curr) {
+        switch(curr->data_type) {
+        case PROCESS_SERVER_VMA_DATA_TYPE:
+            vma_data = (vma_data_t*)curr;
+            PSPRINTK("VMA DATA: start{%lx}, end{%lx}, crid{%d}, vmaid{%d}, cpu{%d}, pgoff{%lx}\n",
+                    vma_data->start,
+                    vma_data->end,
+                    vma_data->clone_request_id,
+                    vma_data->vma_id, 
+                    vma_data->cpu, 
+                    vma_data->pgoff);
+            break;
+        case PROCESS_SERVER_PTE_DATA_TYPE:
+            pte_data = (pte_data_t*)curr;
+            PSPRINTK("PTE DATA: vaddr{%lx}, paddr{%lx}, vmaid{%d}, cpu{%d}\n",
+                    pte_data->vaddr,
+                    pte_data->paddr,
+                    pte_data->vma_id,
+                    pte_data->cpu);
+            break;
+        case PROCESS_SERVER_CLONE_DATA_TYPE:
+            clone_data = (clone_data_t*)curr;
+            PSPRINTK("CLONE DATA: flags{%lx}, stack_start{%lx}, heap_start{%lx}, heap_end{%lx}, ip{%lx}, crid{%d}\n",
+                    clone_data->clone_flags,
+                    clone_data->stack_start,
+                    clone_data->heap_start,
+                    clone_data->heap_end,
+                    clone_data->regs.ip,
+                    clone_data->clone_request_id);
+            break;
+        default:
+            break;
+        }
+        curr = curr->next;
+    }
+
+    spin_unlock(&_data_head_lock);
+}
+
+
+/*
+ * Work exec
+ */
+
+/**
+ *
+ */
+void process_exit_item(struct work_struct* work) {
+    exit_work_t* w = (exit_work_t*) work;
+    pid_t pid = w->pid;
+    struct pid* spid;
+    struct task_struct* task;
+    
+    PSPRINTK("%s: process to kill %ld SEARCHING\n", __func__, (long)pid);
+    
+    for_each_process(task) {
+        if(task->pid == pid) {
+            PSPRINTK("%s: for_each_process Found task to kill, killing\n", __func__);
+            spid = task_pid(task);
+            __set_task_state(task,TASK_INTERRUPTIBLE);
+            kill_pid(spid,SIGKILL,1);
+            goto happy_end;
+        }
+    }
+  
+    task = (pid) ? find_task_by_vpid(pid) : current;
+    if (task) {
+            PSPRINTK("%s: find_process_by_pid Found task to kill, killing\n", __func__);
+            spid = task_pid(task);
+            __set_task_state(task,TASK_INTERRUPTIBLE);
+            kill_pid(spid,SIGKILL,1);
+    }
+    else
+	    PSPRINTK("%s: process to kill %ld NOT FOUND\n", __func__, pid);
+
+happy_end:
+    kfree(work);
+}
+
+unsigned long long perf_aa, perf_bb, perf_cc, perf_dd, perf_ee;
+/**
+ *
+ */
+void process_exec_item(struct work_struct* work) {
+    clone_exec_work_t* w = (clone_exec_work_t*)work;
+    clone_data_t* c = w->clone_data;
+    struct subprocess_info* sub_info;
+    char* argv[] = {c->exe_path,NULL};
+    static char *envp[] = { 
+        "HOME=/",
+        "TERM=linux",
+        "PATH=/sbin:/bin:/usr/sbin:/usr/bin", NULL
+    };
+perf_aa = native_read_tsc();
+    sub_info = call_usermodehelper_setup( c->exe_path /*argv[0]*/, 
+            argv, envp, 
+            GFP_KERNEL );
+
+    PSPRINTK("process_exec_item: %s\n",c->exe_path);
+
+    if (sub_info == NULL) return;
+
+    PSPRINTK("sub_info guard passed\n");
+
+    /*
+     * This information is passed into kmod in order to
+     * act as closure information for when the process
+     * is spun up.  Once that occurs, this cpu must
+     * notify the requesting cpu of the local pid of the
+     * delegate process so that it can maintain its records.
+     * That information will be used to maintain the link
+     * between the placeholder process on the requesting cpu
+     * and the delegate process on the executing cpu.
+     */
+    sub_info->delegated = 1;
+    sub_info->remote_pid = c->placeholder_pid;
+    sub_info->remote_cpu = c->requesting_cpu;
+    sub_info->clone_request_id = c->clone_request_id;
+    memcpy(&sub_info->remote_regs, &c->regs, sizeof(struct pt_regs) );
+    
+    dump_regs(&sub_info->remote_regs);
+
+    /*
+     * Spin up the new process.
+     */
+    call_usermodehelper_exec(sub_info, UMH_NO_WAIT);
+perf_bb = native_read_tsc();
+    kfree(work);
+}
+
+/**
+ * Request implementations
+ */
+
+/**
+ *
+ */
+static int handle_pte_transfer(struct pcn_kmsg_message* inc_msg) {
+    pte_transfer_t* msg = (pte_transfer_t*)inc_msg;
+    unsigned int source_cpu = msg->header.from_cpu;
+    data_header_t* curr = NULL;
+    vma_data_t* vma = NULL;
+    pte_data_t* pte_data = kmalloc(sizeof(pte_data_t),GFP_ATOMIC);
+    if(!pte_data) {
+        PSPRINTK("Failed to allocate pte_data_t\n");
+        return 0;
+    }
+
+    PSPRINTK("pte transfer: src{%d}, vaddr{%lx}, paddr{%lx}, vma_id{%d}, pfn{%lx}\n",
+            source_cpu,
+            msg->vaddr, msg->paddr, msg->vma_id, msg->pfn);
+
+    pte_data->header.data_type = PROCESS_SERVER_PTE_DATA_TYPE;
+    pte_data->header.next = NULL;
+    pte_data->header.prev = NULL;
+
+    // Copy data into new data item.
+    pte_data->cpu = source_cpu;
+    pte_data->vma_id = msg->vma_id;
+    pte_data->vaddr = msg->vaddr;
+    pte_data->paddr = msg->paddr;
+    pte_data->pfn = msg->pfn;
+    pte_data->clone_request_id = msg->clone_request_id;
+
+    //add_data_entry(pte_data);
+    // Look through data store for matching vma_data_t entries.
+    spin_lock(&_data_head_lock);
+
+    curr = _data_head;
+    while(curr) {
+        if(curr->data_type == PROCESS_SERVER_VMA_DATA_TYPE) {
+            vma = (vma_data_t*)curr;
+            if(vma->cpu == pte_data->cpu &&
+               vma->vma_id == pte_data->vma_id &&
+               vma->clone_request_id == pte_data->clone_request_id) {
+                // Add to vma data
+                spin_lock(&vma->lock);
+                if(vma->pte_list) {
+                    pte_data->header.next = (data_header_t*)vma->pte_list;
+                    vma->pte_list->header.prev = (data_header_t*)pte_data;
+                    vma->pte_list = pte_data;
+                } else {
+                    vma->pte_list = pte_data;
+                }
+                spin_unlock(&vma->lock);
+                break;
+            }
+        }
+        curr = curr->next;
+    }
+
+    spin_unlock(&_data_head_lock);
+
+    kfree(inc_msg);
+    
+    return 0;
+}
+
+/**
+ *
+ */
+static int handle_vma_transfer(struct pcn_kmsg_message* inc_msg) {
+    vma_transfer_t* msg = (vma_transfer_t*)inc_msg;
+    unsigned int source_cpu = msg->header.from_cpu;
+    vma_data_t* vma_data = kmalloc(sizeof(vma_data_t),GFP_ATOMIC);
+
+    
+    if(!vma_data) {
+        PSPRINTK("Failed to allocate vma_data_t\n");
+        return 0;
+    }
+
+    vma_data->header.data_type = PROCESS_SERVER_VMA_DATA_TYPE;
+    vma_data->header.next = NULL;
+    vma_data->header.prev = NULL;
+
+    // Copy data into new data item.
+    vma_data->cpu = source_cpu;
+    vma_data->start = msg->start;
+    vma_data->end = msg->end;
+    vma_data->clone_request_id = msg->clone_request_id;
+    vma_data->flags = msg->flags;
+    vma_data->prot = msg->prot;
+    vma_data->vma_id = msg->vma_id;
+    vma_data->pgoff = msg->pgoff;
+    vma_data->pte_list = NULL;
+    vma_data->lock = __SPIN_LOCK_UNLOCKED(&vma_data->lock);
+    strcpy(vma_data->path,msg->path);
+
+    add_data_entry(vma_data); 
+   
+    kfree(inc_msg);
+
+    return 0;
+}
+
+/**
+ * Handler function for when either a remote placeholder or a remote delegate process dies,
+ * and its local counterpart must be killed to reflect that.
+ */
+static int handle_exiting_process_notification(struct pcn_kmsg_message* inc_msg) {
+    exiting_process_t* msg = (exiting_process_t*)inc_msg;
+    unsigned int source_cpu = msg->header.from_cpu;
+    struct task_struct* task;
+    exit_work_t* exit_work;
+
+    PSPRINTK("%s: cpu: %d msg: (pid: %d from_cpu: %d [%d])\n", 
+	   __func__, smp_processor_id(), msg->my_pid,  inc_msg->hdr.from_cpu, source_cpu);
+    
+    for_each_process(task) {
+        if(task->remote_pid == msg->my_pid &&
+           task->remote_cpu == source_cpu) {
+
+            PSPRINTK("kmkprocsrv: killing local task pid{%d}\n",task->pid);
+            
+            exit_work = kmalloc(sizeof(exit_work_t),GFP_ATOMIC);
+            if(exit_work) {
+                INIT_WORK( (struct work_struct*)exit_work, process_exit_item);
+                exit_work->pid = task->pid;
+                queue_work(exit_wq, (struct work_struct*)exit_work);
+            }
+
+            break; // No need to continue;
+        }
+    }
+
+    kfree(inc_msg);
+
+    return 0;
+}
+
+/**
+ * Handler function for when another processor informs the current cpu
+ * of a pid pairing.
+ */
+static int handle_process_pairing_request(struct pcn_kmsg_message* inc_msg) {
+    create_process_pairing_t* msg = (create_process_pairing_t*)inc_msg;
+    unsigned int source_cpu = msg->header.from_cpu;
+    struct task_struct* task;
+    if(msg == NULL) {
+        return 0;
+    }
+
+    /*
+     * Go through all the processes looking for the one with the right pid.
+     * Once that task is found, do the bookkeeping necessary to remember
+     * the remote cpu and pid information.
+     */
+    for_each_process(task) {
+        if(task->pid == msg->your_pid && task->represents_remote) {
+            task->remote_cpu = source_cpu;
+            task->remote_pid = msg->my_pid;
+            task->executing_for_remote = 0;
+ 
+            PSPRINTK("kmkprocsrv: Added paring at request remote_pid{%d}, local_pid{%d}, remote_cpu{%d}",
+                    task->remote_pid,
+                    task->pid,
+                    task->remote_cpu);
+
+            break; // No need to continue;
+        }
+    }
+
+    kfree(inc_msg);
+
+    return 0;
+}
+
+/**
+ * Handle clone requests. 
+ */
+static int handle_clone_request(struct pcn_kmsg_message* inc_msg) {
+    clone_request_t* request = (clone_request_t*)inc_msg;
+    clone_exec_work_t* clone_work = NULL;
+    unsigned int source_cpu = request->header.from_cpu;
+    clone_data_t* clone_data;
+    data_header_t* curr;
+    data_header_t* next;
+    vma_data_t* vma;
+perf_cc = native_read_tsc();
+    /*
+     * Remember this request
+     */
+    clone_data = kmalloc(sizeof(clone_data_t),GFP_ATOMIC);
+    clone_data->header.data_type = PROCESS_SERVER_CLONE_DATA_TYPE;
+    clone_data->header.next = NULL;
+    clone_data->header.prev = NULL;
+
+    clone_data->clone_request_id = request->clone_request_id;
+    clone_data->requesting_cpu = source_cpu;
+    clone_data->clone_flags = request->clone_flags;
+    clone_data->stack_start = request->stack_start;
+    clone_data->stack_ptr = request->stack_ptr;
+    clone_data->arg_start = request->arg_start;
+    clone_data->arg_end = request->arg_end;
+    clone_data->env_start = request->env_start;
+    clone_data->env_end = request->env_end;
+    clone_data->heap_start = request->heap_start;
+    clone_data->heap_end = request->heap_end;
+    memcpy(&clone_data->regs, &request->regs, sizeof(struct pt_regs) );
+    memcpy(&clone_data->exe_path, &request->exe_path, sizeof(request->exe_path));
+    clone_data->placeholder_pid = request->placeholder_pid;
+    clone_data->placeholder_tgid = request->placeholder_tgid;
+    clone_data->placeholder_cpu = source_cpu;
+    clone_data->thread_fs = request->thread_fs;
+    clone_data->thread_gs = request->thread_gs;
+    clone_data->thread_sp0 = request->thread_sp0;
+    clone_data->thread_sp = request->thread_sp;
+    clone_data->thread_usersp = request->thread_usersp;
+    clone_data->thread_es = request->thread_es;
+    clone_data->thread_ds = request->thread_ds;
+    clone_data->thread_fsindex = request->thread_fsindex;
+    clone_data->thread_gsindex = request->thread_gsindex;
+    clone_data->vma_list = NULL;
+    clone_data->lock = __SPIN_LOCK_UNLOCKED(&clone_data->lock);
+
+    /*
+     * Pull in vma data
+     */
+    spin_lock(&_data_head_lock);
+
+    curr = _data_head;
+    while(curr) {
+        next = curr->next;
+
+        if(curr->data_type == PROCESS_SERVER_VMA_DATA_TYPE) {
+            vma = (vma_data_t*)curr;
+            if(vma->clone_request_id == clone_data->clone_request_id &&
+               vma->cpu == source_cpu ) {
+
+                // Remove the data entry from the general data store
+                remove_data_entry(vma);
+
+                // Place data entry in this clone request's vma list
+                spin_lock(&clone_data->lock);
+                if(clone_data->vma_list) {
+                    clone_data->vma_list->header.prev = (data_header_t*)vma;
+                    vma->header.next = (data_header_t*)clone_data->vma_list;
+                } 
+                clone_data->vma_list = vma;
+                spin_unlock(&clone_data->lock);
+            }
+        }
+
+        curr = next;
+    }
+
+    spin_unlock(&_data_head_lock);
+
+    add_data_entry(clone_data);
+
+perf_dd = native_read_tsc();
+    clone_work = kmalloc(sizeof(clone_exec_work_t),GFP_ATOMIC);
+    if(clone_work) {
+        INIT_WORK( (struct work_struct*)clone_work, process_exec_item);
+        clone_work->clone_data = clone_data;
+        queue_work(clone_wq, (struct work_struct*)clone_work);
+    }
+
+    kfree(inc_msg);
+perf_ee = native_read_tsc();
+    return 0;
+}
+
+/**
+ * Message passing helper functions
+ */
+
+// TODO
+static bool __user_addr (unsigned long x ) 
+{
+    return (x < PAGE_OFFSET);   
+}
+
+
+/**
+ *
+ * Public API
+ */
+
+
+//statistics
+static unsigned long long perf_a, perf_b, perf_c, perf_d, perf_e;
+
+
+/**
+ * If this is a delegated process, look up any records that may
+ * exist of the remote placeholder processes page information,
+ * and map those pages.
+ *
+ * Assumes current->mm->mmap_sem is already held.
+ */
+int process_server_import_address_space(unsigned long* ip, 
+        unsigned long* sp, 
+        struct pt_regs* regs) {
+    pte_data_t* pte_curr = NULL;
+    vma_data_t* vma_curr = NULL;
+    clone_data_t* clone_data = NULL;
+    unsigned long err = 0;
+    struct file* f;
+    struct vm_area_struct* vma;
+    int munmap_ret = 0;
+    int mmap_flags = 0;
+perf_a = native_read_tsc();
+    PSPRINTK("import address space\n");
+    
+    // Verify that we're a delegated task.
+    if (!current->executing_for_remote) {
+        PSPRINTK("ERROR - not executing for remote\n");
+        return -1;
+    }
+
+    clone_data = find_clone_data(current->remote_cpu,current->clone_request_id);
+    if(!clone_data) {
+        return -1;
+    }
+perf_b = native_read_tsc();
+    // Gut existing mappings
+    
+    down_write(&current->mm->mmap_sem);
+    
+    vma = current->mm->mmap;
+    while(vma) {
+        munmap_ret = do_munmap(current->mm, vma->vm_start, vma->vm_end - vma->vm_start);
+        vma = current->mm->mmap;
+    }
+
+    // Clean out cache and tlb
+    flush_tlb_mm(current->mm);
+    flush_cache_mm(current->mm);
+
+    up_write(&current->mm->mmap_sem);
+perf_c = native_read_tsc();    
+    // Import address space
+    vma_curr = clone_data->vma_list;
+
+    while(vma_curr) {
+        PSPRINTK("do_mmap()\n");
+        if(vma_curr->path[0] != '\0') {
+            mmap_flags = /*MAP_UNINITIALIZED|*/MAP_FIXED|MAP_PRIVATE;
+            f = filp_open(vma_curr->path,
+                            O_RDONLY | O_LARGEFILE,
+                            0);
+            if(f) {
+                down_write(&current->mm->mmap_sem);
+                vma_curr->mmapping_in_progress = 1;
+                err = do_mmap(f, 
+                        vma_curr->start, 
+                        vma_curr->end - vma_curr->start,
+                        PROT_READ|PROT_WRITE|PROT_EXEC, 
+                        mmap_flags, 
+                        0);
+                vma_curr->mmapping_in_progress = 0;
+                up_write(&current->mm->mmap_sem);
+                filp_close(f,NULL);
+                if(err != vma_curr->start) {
+                    PSPRINTK("Fault - do_mmap failed to map %lx with error %lx\n",
+                            vma_curr->start,err);
+                }
+            }
+        } else {
+            mmap_flags = MAP_UNINITIALIZED|MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE;
+            down_write(&current->mm->mmap_sem);
+            err = do_mmap(NULL, 
+                vma_curr->start, 
+                vma_curr->end - vma_curr->start,
+                PROT_READ|PROT_WRITE|PROT_EXEC, 
+                mmap_flags, 
+                0);
+            //PSPRINTK("mmap error for %lx = %lx\n",vma_curr->start,err);
+            up_write(&current->mm->mmap_sem);
+            if(err != vma_curr->start) {
+                PSPRINTK("Fault - do_mmap failed to map %lx with error %lx\n",
+                        vma_curr->start,err);
+            }
+        }
+       
+        if(err > 0) {
+            // mmap_region succeeded
+            vma = find_vma(current->mm, vma_curr->start);
+            PSPRINTK("vma mmapped, pulling in pte's\n");
+            if(vma) {
+                pte_curr = vma_curr->pte_list;
+                while(pte_curr) {
+                    // MAP it
+                    err = remap_pfn_range(vma,
+                            pte_curr->vaddr,
+                            pte_curr->paddr >> PAGE_SHIFT,
+                            PAGE_SIZE,
+                            vma->vm_page_prot);
+                    pte_curr = (pte_data_t*)pte_curr->header.next;
+                    if(err) {
+                        PSPRINTK("Fault - remap_pfn_range failed to map %lx to %lx with error %lx\n",
+                                pte_curr->paddr,pte_curr->vaddr,err);
+                    }
+                }
+            }
+        }
+        vma_curr = (vma_data_t*)vma_curr->header.next;
+    }
+perf_d = native_read_tsc();
+    // install memory information
+    current->mm->start_stack = clone_data->stack_start;
+    current->mm->start_brk = clone_data->heap_start;
+    current->mm->brk = clone_data->heap_end;
+    current->mm->env_start = clone_data->env_start;
+    current->mm->env_end = clone_data->env_end;
+    current->mm->arg_start = clone_data->arg_start;
+    current->mm->arg_end = clone_data->arg_end;
+
+    // install thread information
+    // TODO: Move to arch
+    current->thread.es = clone_data->thread_es;
+    current->thread.ds = clone_data->thread_ds;
+    current->thread.usersp = clone_data->thread_usersp;//clone_data->stack_ptr;
+    
+
+    // Set output variables.
+    *sp = clone_data->thread_usersp;//clone_data->thread_sp;//clone_data->stack_ptr;
+    *ip = clone_data->regs.ip;
+    
+    // adjust registers as necessary
+    memcpy(regs,&clone_data->regs,sizeof(struct pt_regs)); 
+    regs->ax = 0; // Fake success for the "sched_setaffinity" syscall
+                  // that this process just "returned from"
+
+    // We assume that an exec is going on
+    // and the current process is the one is executing
+    // (a switch will occur if it is not the one that must execute)
+    {
+    unsigned long fs, gs;
+    unsigned int fsindex, gsindex;
+    savesegment(fs, fsindex);
+    savesegment(gs, gsindex);
+   
+    rdmsrl(MSR_GS_BASE, gs);
+    rdmsrl(MSR_FS_BASE, fs);
+    
+    PSPRINTK("%s: curr:(fs:0x%lx fsid:0x%x) clone:(fs:0x%lx fsid:0x%x) saved:(fs:0x%lx fsid:0x%x) valid: %d\n",
+	   __func__, current->thread.fs, current->thread.fsindex,
+	   clone_data->thread_fs, clone_data->thread_fsindex, fs, fsindex,
+	   __user_addr(clone_data->thread_fs) );
+    if (clone_data->thread_fs && __user_addr(clone_data->thread_fs)) { // we update only if the 
+                                                                       // address of the base fs is different 
+                                                                       // from 0 and not represent a kernel address 
+                                                                       // (we are migrating only the virtual address 
+                                                                       // space of the process)
+        current->thread.fs = clone_data->thread_fs;
+        current->thread.fsindex = clone_data->thread_fsindex;
+
+        if (unlikely(fsindex | current->thread.fsindex)) {
+	        loadsegment(fs, current->thread.fsindex);
+        }
+        else { 
+	        loadsegment(fs, 0);
+        }
+
+        if (fs != current->thread.fs) {
+	        PSPRINTK("%s: fs %lx thread %lx (idx %d thread %d)\n",
+	            __func__, fs, current->thread.fs, fsindex, current->thread.fsindex);      
+        }
+
+        if (current->thread.fs) {
+	        wrmsrl(MSR_FS_BASE, current->thread.fs);  
+        }
+    }
+    else { 
+        loadsegment(fs, 0);
+    }
+       
+    PSPRINTK("%s: curr:(gs:0x%lx gsid:0x%x) clone:(gs:0x%lx gsid:0x%x) saved:(gs:0x%lx gsid:0x%x) valid: %d\n",
+	    __func__, current->thread.gs, current->thread.gsindex,
+	    clone_data->thread_gs, clone_data->thread_gsindex, gs, gsindex,
+	    __user_addr(clone_data->thread_gs) );
+
+    if (clone_data->thread_gs && __user_addr(clone_data->thread_gs)) {
+        current->thread.gs = clone_data->thread_gs;    
+        current->thread.gsindex = clone_data->thread_gsindex;
+      
+        if (unlikely(gsindex | current->thread.gsindex)) {
+	        loadsegment(gs, current->thread.gsindex);
+        }
+        else {
+	        load_gs_index(0);
+        }
+
+        if (gs != current->thread.gs) {
+	        PSPRINTK("%s: gs %lx thread %lx (idx %d thread %d)\n",
+	            __func__, gs, current->thread.gs, gsindex, current->thread.gsindex);    
+        }
+        if (current->thread.gs) {
+	        wrmsrl(MSR_FS_BASE, current->thread.gs);
+        }
+    }
+    else {
+        load_gs_index(0);
+    }
+    
+    }
+    
+    dump_clone_data(clone_data);
+    dump_task(current,regs, clone_data->stack_ptr);
+perf_e = native_read_tsc();
+printk("%s %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu\n",
+       __func__,
+       perf_aa, perf_bb, perf_cc, perf_dd, perf_ee,
+       perf_a, perf_b, perf_c, perf_d, perf_e);
+    return 0;
+}
+
+/**
+ * Notify of the fact that either a delegate or placeholder has died locally.  
+ * In this case, the remote cpu housing its counterpart must be notified, so
+ * that it can kill that counterpart.
+ */
+int process_server_task_exit_notification(pid_t pid) {
+
+    exiting_process_t msg;
+    int tx_ret = -1;
+    struct task_struct* task;
+    clone_data_t* clone_data = find_clone_data(current->remote_cpu, current->clone_request_id);
+
+    PSPRINTK("kmksrv: process_server_task_exit_notification - pid{%d}\n",pid);
+    msg.header.type = PCN_KMSG_TYPE_PROC_SRV_EXIT_PROCESS;
+    msg.header.prio = PCN_KMSG_PRIO_NORMAL;
+    msg.my_pid = pid;
+
+    if(current->pid == pid) {
+        tx_ret = pcn_kmsg_send_long(current->remote_cpu, 
+                    (struct pcn_kmsg_long_message*)&msg, 
+                    sizeof(msg) - sizeof(msg.header));
+    } else {
+        for_each_process(task) {
+            if(task->pid == pid) {
+                tx_ret = pcn_kmsg_send_long(task->remote_cpu, 
+                            (struct pcn_kmsg_long_message*)&msg, 
+                            sizeof(msg) - sizeof(msg.header));
+            }
+        }
+    }
+
+    //dump_task(current,NULL,0);
+
+    if(clone_data) {
+        spin_lock(&_data_head_lock);
+        remove_data_entry(clone_data);
+        spin_unlock(&_data_head_lock);
+        destroy_clone_data(clone_data);
+    }
+
+    return tx_ret;
+}
+
+/**
+ * Create a pairing between a newly created delegate process and the
+ * remote placeholder process.  This function creates the local
+ * pairing first, then sends a message to the originating cpu
+ * so that it can do the same.
+ */
+int process_server_notify_delegated_subprocess_starting(pid_t pid, pid_t remote_pid, int remote_cpu) {
+
+    create_process_pairing_t msg;
+    int tx_ret = -1;
+
+    PSPRINTK("kmkprocsrv: notify_subprocess_starting: pid{%d}, remote_pid{%d}, remote_cpu{%d}\n",pid,remote_pid,remote_cpu);
+    
+    // Notify remote cpu of pairing between current task and remote
+    // representative task.
+    msg.header.type = PCN_KMSG_TYPE_PROC_SRV_CREATE_PROCESS_PAIRING;
+    msg.header.prio = PCN_KMSG_PRIO_NORMAL;
+    msg.your_pid = remote_pid; 
+    msg.my_pid = pid;
+    
+    tx_ret = pcn_kmsg_send_long(remote_cpu, 
+                (struct pcn_kmsg_long_message*)&msg, 
+                sizeof(msg) - sizeof(msg.header));
+
+    return tx_ret;
+
+}
+
+/**
+ * mmap is being called, check to see if we need to notify remote cpus to keep others
+ * in the current thread group up to date.
+ */
+int process_server_notify_mmap(struct file *file, unsigned long addr,                                                                                                  
+                               unsigned long len, unsigned long prot,
+                               unsigned long flags, unsigned long pgoff) {
+    clone_data_t* clone_data = NULL;
+    vma_data_t* vma_data = NULL;
+    if((!current->executing_for_remote) && (!current->represents_remote)) {
+        return 0; // Don't care
+    }
+
+    clone_data = find_clone_data(current->remote_cpu,
+                                 current->clone_request_id);
+    if(!clone_data) return 0;
+
+    // Check to see if we are possibly sharing VM with anybody.
+    // If not, exit.
+    if(!(clone_data->clone_flags & CLONE_VM)) {
+        return 0;
+    }
+
+    // Check to see if we're mmapping something that is in the vma collection.
+    // If that is the case, and it's mmapping_in_progress flag is set, then 
+    // this mmap call is mmapping a remotely initiated memory mapping.  
+    // In that case, we don't want to act.
+    vma_data = find_vma_data(clone_data,addr);
+    if(vma_data && vma_data->mmapping_in_progress) {
+        return 0; // Don't care
+    }
+
+    // Notify the remote thread group members
+
+    PSPRINTK("process_server_notify_mmap\n");
+    return 1;
+
+}
+
+/**
+ *
+ */
+int process_server_notify_munmap(struct mm_struct *mm, unsigned long start, size_t len) {
+    clone_data_t* clone_data = NULL;
+    if(!current->executing_for_remote && !current->represents_remote) {
+        return 0; // Don't care
+    }
+
+    clone_data = find_clone_data(current->remote_cpu,
+                                 current->clone_request_id);
+    if(!clone_data) return 0;
+
+    // Check to see if we are possibly sharing VM with anybody.
+    // If not, exit.
+    if((clone_data->clone_flags & CLONE_VM) == 0) {
+        return 0;
+    }
+
+    // Notify the remote thread group members
+
+    PSPRINTK("process_server_notify_munmap\n");
+    return 1;
+}
+
+/**
+ * Page walk has encountered a pte while deconstructing
+ * the client side processes address space.  Transfer it.
+ */
+static int deconstruction_page_walk_pte_entry_callback(pte_t *pte, unsigned long start, unsigned long end, struct mm_walk *walk) {
+    deconstruction_data_t* decon_data = (deconstruction_data_t*)walk->private;
+    int vma_id = decon_data->vma_id;
+    int dst_cpu = decon_data->dst_cpu;
+    int clone_request_id = decon_data->clone_request_id;
+    pte_transfer_t* pte_xfer = NULL;
+
+    if(NULL == pte || !pte_present(*pte)) {
+        return 0;
+    }
+
+    pte_xfer = kmalloc(sizeof(pte_transfer_t),GFP_ATOMIC);
+
+    pte_xfer->header.type = PCN_KMSG_TYPE_PROC_SRV_PTE_TRANSFER;
+    pte_xfer->header.prio = PCN_KMSG_PRIO_NORMAL;
+    pte_xfer->paddr = (pte_val(*pte) & PHYSICAL_PAGE_MASK) | (start & (PAGE_SIZE-1));
+    // NOTE: Found the above pte to paddr conversion here -
+    // http://wbsun.blogspot.com/2010/12/convert-userspace-virtual-address-to.html
+    pte_xfer->vaddr = start;
+    pte_xfer->vma_id = vma_id;
+    pte_xfer->clone_request_id = clone_request_id;
+    pte_xfer->pfn = pte_pfn(*pte);
+    pcn_kmsg_send_long(dst_cpu, 
+            (struct pcn_kmsg_long_message*)pte_xfer, 
+            sizeof(pte_transfer_t) - sizeof(pte_xfer->header));
+
+    kfree(pte_xfer);
+
+    return 0;
+}
+
+/**
+ * Migrate the specified task <task> to cpu <cpu>
+ * Currently, this function will put the specified task to 
+ * sleep, and push its info over to the remote cpu.  The
+ * remote cpu will then create a new process and import that
+ * info into its new context.  
+ *
+ * TODO: Use a multicast channel for communicating data relevant
+ *       to shadow processes.
+ */
+int process_server_do_migration(struct task_struct* task, int cpu) {
+    struct pt_regs *regs = task_pt_regs(task);
+    // TODO: THIS IS WRONG, task flags is not what I want here.
+    unsigned long clone_flags = task->clone_flags;
+    unsigned long stack_start = task->mm->start_stack;
+    clone_request_t* request = kmalloc(sizeof(clone_request_t),GFP_KERNEL);
+    int tx_ret = -1;
+    int dst_cpu = cpu;
+    char path[256] = {0};
+    char* rpath = d_path(&task->active_mm->exe_file->f_path,
+           path,256);
+    char lpath[256];
+    char *plpath;
+    struct vm_area_struct* curr = NULL;
+    struct mm_walk walk = {
+        .pte_entry = deconstruction_page_walk_pte_entry_callback,
+        .mm = task->mm,
+        .private = NULL
+        };
+    vma_transfer_t* vma_xfer = kmalloc(sizeof(vma_transfer_t),GFP_KERNEL);
+    int lclone_request_id;
+    deconstruction_data_t decon_data;
+
+    PSPRINTK("process_server_do_migration\n");
+    dump_regs(regs);
+
+    // Execute locally if the scheduler decides to do so.
+    if(dst_cpu == _cpu) {
+        return PROCESS_SERVER_CLONE_FAIL;
+    }
+
+    // This will be a placeholder process for the remote
+    // process that is subsequently going to be started.
+    //  Block its execution.
+    sigaddset(&task->pending.signal,SIGSTOP); 
+    set_tsk_thread_flag(task,TIF_SIGPENDING); 
+    __set_task_state(task,TASK_UNINTERRUPTIBLE);
+
+    // Book keeping for placeholder process.
+    task->represents_remote = 1;
+    task->executing_for_remote = 0;
+
+    // Pick an id for this remote process request
+    spin_lock(&_clone_request_id_lock);
+    lclone_request_id = _clone_request_id++;
+    spin_unlock(&_clone_request_id_lock);
+
+    down_read(&task->mm->mmap_sem);
+
+    // VM Entries
+    curr = task->mm->mmap;
+
+    vma_xfer->header.type = PCN_KMSG_TYPE_PROC_SRV_VMA_TRANSFER;
+    vma_xfer->header.prio = PCN_KMSG_PRIO_NORMAL;
+    while(curr) {
+
+        /*
+         * re-initialize path.
+         */
+        if(curr->vm_file == NULL) {
+            vma_xfer->path[0] = '\0';
+        } else {
+            plpath = d_path(&curr->vm_file->f_path,
+                        lpath,256);
+            strcpy(vma_xfer->path,plpath);
+        }
+
+        /*
+         * Transfer the vma
+         */
+        spin_lock(&_vma_id_lock);
+        vma_xfer->vma_id = _vma_id++;
+        spin_unlock(&_vma_id_lock);
+        vma_xfer->start = curr->vm_start;
+        vma_xfer->end = curr->vm_end;
+        vma_xfer->prot = curr->vm_page_prot;
+        vma_xfer->clone_request_id = lclone_request_id;
+        vma_xfer->flags = curr->vm_flags;
+        vma_xfer->pgoff = curr->vm_pgoff;
+        tx_ret = pcn_kmsg_send_long(dst_cpu, 
+                    (struct pcn_kmsg_long_message*)vma_xfer, 
+                    sizeof(vma_transfer_t) - sizeof(vma_xfer->header));
+        if (tx_ret) {
+            PSPRINTK("Unable to send vma transfer message, rc = %d\n", tx_ret);
+        }
+
+        PSPRINTK("Anonymous VM Entry: start{%lx}, end{%lx}, pgoff{%lx}\n",
+                curr->vm_start, 
+                curr->vm_end,
+                curr->vm_pgoff);
+
+        decon_data.clone_request_id = lclone_request_id;
+        decon_data.vma_id = vma_xfer->vma_id;
+        decon_data.dst_cpu = dst_cpu;
+
+        walk.private = &decon_data;
+        walk_page_range(curr->vm_start,curr->vm_end,&walk);
+    
+        curr = curr->vm_next;
+    }
+
+    up_read(&task->mm->mmap_sem);
+
+    // Build request
+    request->header.type = PCN_KMSG_TYPE_PROC_SRV_CLONE_REQUEST;
+    request->header.prio = PCN_KMSG_PRIO_NORMAL;
+    request->clone_flags = clone_flags;
+    request->clone_request_id = lclone_request_id;
+    memcpy( &request->regs, regs, sizeof(struct pt_regs) );
+    strncpy( request->exe_path, rpath, 512 );
+// struct mm_struct -----------------------------------------------------------
+    request->stack_start = task->mm->start_stack;
+    request->heap_start = task->mm->start_brk;
+    request->heap_end = task->mm->brk;
+    request->env_start = task->mm->env_start;
+    request->env_end = task->mm->env_end;
+    request->arg_start = task->mm->arg_start;
+    request->arg_end = task->mm->arg_end;
+// struct task_struct ---------------------------------------------------------    
+    request->stack_ptr = stack_start;
+    request->placeholder_pid = task->pid;
+    request->placeholder_tgid = task->tgid;
+// struct thread_struct -------------------------------------------------------
+    // have a look at: copy_thread() arch/x86/kernel/process_64.c 
+    // have a look at: struct thread_struct arch/x86/include/asm/processor.h
+    {
+      	unsigned long fs, gs, shadowgs;
+	unsigned int fsindex, gsindex;
+	unsigned int ds, cs, es;
+	
+	    if (current != task)
+	      PSPRINTK("DAVEK current is different from task!\n");
+
+    request->thread_sp0 = task->thread.sp0;
+    request->thread_sp = task->thread.sp;
+    
+    //printk("%s: usersp percpu %lx thread %lx\n", __func__, percpu_read(old_rsp), task->thread.usersp);
+    // if (percpu_read(old_rsp), task->thread.usersp) set to 0 otherwise copy
+    request->thread_usersp = task->thread.usersp;
+    
+    request->thread_es = task->thread.es;
+    savesegment(es, es);          
+    if ((current == task) && (es != request->thread_es))
+      PSPRINTK("%s: DAVEK: es %x thread %x\n", __func__, es, request->thread_es);
+      
+    request->thread_ds = task->thread.ds;
+    savesegment(ds, ds);
+    if (ds != request->thread_ds)
+      PSPRINTK("%s: DAVEK: ds %x thread %x\n", __func__, ds, request->thread_ds);
+      
+    request->thread_fsindex = task->thread.fsindex;
+    savesegment(fs, fsindex);
+    if (fsindex != request->thread_fsindex)
+      PSPRINTK("%s: DAVEK: fsindex %x thread %x\n", __func__, fsindex, request->thread_fsindex);
+      
+    request->thread_gsindex = task->thread.gsindex;
+    savesegment(gs, gsindex);
+    if (gsindex != request->thread_gsindex)
+      PSPRINTK("%s: DAVEK: gsindex %x thread %x\n", __func__, gsindex, request->thread_gsindex);
+    
+    request->thread_fs = task->thread.fs;
+    rdmsrl(MSR_FS_BASE, fs);
+    if (fs != request->thread_fs) {
+      request->thread_fs = fs;
+      PSPRINTK("%s: DAVEK: fs %lx thread %lx\n", __func__, fs, request->thread_fs);
+    }
+
+    request->thread_gs = task->thread.gs;
+    rdmsrl(MSR_GS_BASE, gs);
+    if (gs != request->thread_gs) {
+      request->thread_gs = gs;
+      PSPRINTK("%s: DAVEK: gs %lx thread %lx\n", __func__, fs, request->thread_gs);
+    }
+    // ptrace, debug, dr7: struct perf_event *ptrace_bps[HBP_NUM]; unsigned long debugreg6; unsigned long ptrace_dr7;
+    // Fault info: unsigned long cr2; unsigned long trap_no; unsigned long error_code;
+    // floating point: struct fpu fpu; THIS IS NEEDED
+    // IO permissions: unsigned long *io_bitmap_ptr; unsigned long iopl; unsigned io_bitmap_max;
+    }
+
+    // Send request
+    tx_ret = pcn_kmsg_send_long(dst_cpu, 
+                (struct pcn_kmsg_long_message*)request, 
+                sizeof(clone_request_t) - sizeof(request->header));
+
+    PSPRINTK("kmkprocsrv: transmitted %d\n",tx_ret);
+
+    kfree(request);
+    kfree(vma_xfer);
+
+    dump_task(task,regs,request->stack_ptr);
+
+    return PROCESS_SERVER_CLONE_SUCCESS;
+
+}
+
+/**
+ * process_server_init
+ * Start the process loop in a new kthread.
+ */
+static int __init process_server_init(void) {
+
+    /*
+     * Cache some local information.
+     */
+    _cpu = smp_processor_id();
+
+    /*
+     * Create a work queue so that we can do bottom side
+     * processing on data that was brought in by the
+     * communications module interrupt handlers.
+     */
+    clone_wq = create_workqueue("clone_wq");
+    exit_wq  = create_workqueue("exit_wq");
+
+    /*
+     * Register to receive relevant incomming messages.
+     */
+
+    PSPRINTK("BEN: Registering process server callbacks!\n");
+
+    pcn_kmsg_register_callback(PCN_KMSG_TYPE_PROC_SRV_PTE_TRANSFER, 
+            handle_pte_transfer);
+    pcn_kmsg_register_callback(PCN_KMSG_TYPE_PROC_SRV_VMA_TRANSFER, 
+            handle_vma_transfer);
+    pcn_kmsg_register_callback(PCN_KMSG_TYPE_PROC_SRV_EXIT_PROCESS, 
+            handle_exiting_process_notification);
+    pcn_kmsg_register_callback(PCN_KMSG_TYPE_PROC_SRV_CREATE_PROCESS_PAIRING, 
+            handle_process_pairing_request);
+    pcn_kmsg_register_callback(PCN_KMSG_TYPE_PROC_SRV_CLONE_REQUEST, 
+            handle_clone_request);
+
+    return 0;
+}
+
+/**
+ * Register process server init function as
+ * module initialization function.
+ */
+late_initcall(process_server_init);
+
+
+
+
diff --git a/kernel/sched.c b/kernel/sched.c
index d6b149c..d7a29af 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -72,6 +72,7 @@
 #include <linux/ftrace.h>
 #include <linux/slab.h>
 #include <linux/init_task.h>
+#include <linux/process_server.h>
 
 #include <asm/tlb.h>
 #include <asm/irq_regs.h>
@@ -3261,6 +3262,8 @@ static inline void post_schedule(struct rq *rq)
 asmlinkage void schedule_tail(struct task_struct *prev)
 	__releases(rq->lock)
 {
+
+
 	struct rq *rq = this_rq();
 
 	finish_task_switch(rq, prev);
@@ -3277,6 +3280,13 @@ asmlinkage void schedule_tail(struct task_struct *prev)
 #endif
 	if (current->set_child_tid)
 		put_user(task_pid_vnr(current), current->set_child_tid);
+
+	// Multikernel
+    if(current->represents_remote) {
+        printk("Sleeping %d\n",current->pid);
+        set_current_state( TASK_INTERRUPTIBLE);
+        schedule();
+    }
 }
 
 /*
@@ -5546,6 +5556,8 @@ long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
 	cpumask_var_t cpus_allowed, new_mask;
 	struct task_struct *p;
 	int retval;
+    int current_cpu = smp_processor_id();
+    int i;
 
 	get_online_cpus();
 	rcu_read_lock();
@@ -5556,6 +5568,30 @@ long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
 		put_online_cpus();
 		return -ESRCH;
 	}
+	pid = current->pid;
+
+// TODO migration must be removed from here
+    /*
+     * Multikernel
+     */
+    // For now, migrate to the first cpu in the mask that
+    // is not the current cpu
+    for(i = 0; i < NR_CPUS; i++) {
+        if( (cpu_isset(i,*in_mask) ) && (current_cpu != i) ) {
+            // do the migration
+	    get_task_struct(p);
+	    rcu_read_unlock();
+            process_server_do_migration(p,i);
+	    put_task_struct(p);
+	    put_online_cpus();
+
+	    //while (1) {
+	      schedule(); // this will save us from death
+	    //}
+	    
+            return 0;
+        }
+    }
 
 	/* Prevent p going away */
 	get_task_struct(p);
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index bb425b1..54c4576 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -3021,11 +3021,9 @@ struct workqueue_struct *__alloc_workqueue_key(const char *name,
 		wq->rescuer = rescuer = alloc_worker();
 		if (!rescuer)
 			goto err;
-
 		rescuer->task = kthread_create(rescuer_thread, wq, "%s", name);
 		if (IS_ERR(rescuer->task))
 			goto err;
-
 		rescuer->task->flags |= PF_THREAD_BOUND;
 		wake_up_process(rescuer->task);
 	}
@@ -3036,7 +3034,6 @@ struct workqueue_struct *__alloc_workqueue_key(const char *name,
 	 * workqueue to workqueues list.
 	 */
 	spin_lock(&workqueue_lock);
-
 	if (workqueue_freezing && wq->flags & WQ_FREEZABLE)
 		for_each_cwq_cpu(cpu, wq)
 			get_cwq(cpu, wq)->max_active = 0;
diff --git a/kinst.sh b/kinst.sh
new file mode 100755
index 0000000..c48a9a6
--- /dev/null
+++ b/kinst.sh
@@ -0,0 +1,84 @@
+#!/bin/bash
+#first, get the kernel version
+make include/config/kernel.release
+VER=`cat include/config/kernel.release`
+CC=gcc
+THREADS=`cat /proc/cpuinfo | grep processor | wc -l`
+
+echo "Building kernel ${VER} with ${CC} on ${THREADS} threads"
+
+if [ $(/usr/bin/id -u) -ne 0 ]; then
+	echo "Please run this script as root."
+	exit 2
+fi
+
+# Determine OS platform (and, if applicable, Linux distribution)
+# Courtesy of http://legroom.net/2010/05/05/generic-method-determine-linux-or-unix-distribution-name
+detect_os() {
+	UNAME=$(uname | tr "[:upper:]" "[:lower:]")
+	# If Linux, try to determine specific distribution
+	if [ "$UNAME" == "linux" ]; then
+	    # If available, use LSB to identify distribution
+	    if [ -f /etc/lsb-release -o -d /etc/lsb-release.d ]; then
+		DISTRO=$(lsb_release -i | cut -d: -f2 | sed s/'^\t'//)
+	    # Otherwise, use release info file
+	    else
+		DISTRO=$(ls -d /etc/[A-Za-z]*[_-][rv]e[lr]* | grep -v "lsb" | cut -d'/' -f3 | cut -d'-' -f1 | cut -d'_' -f1)
+	    fi
+	fi
+	# For everything else (or if above failed), just use generic identifier
+	[ "$DISTRO" == "" ] && DISTRO=$UNAME
+
+	# Convert to lowercase before echoing result
+	echo $DISTRO | tr "[:upper:]" "[:lower:]"
+}
+
+check_errors() {
+	# Function. Parameter 1 is the return code
+	# Para. 2 is text to display on failure.
+	if [ "${1}" -ne "0" ]; then
+		echo "ERROR # ${1} : ${2}"
+		# as a bonus, make our script exit with the right error code.
+		exit ${1}
+	fi
+}
+
+if [ ! -f .config ]
+then
+	echo "No config found... running make menuconfig"
+	make menuconfig
+fi
+
+make -j$THREADS bzImage CC=$CC
+check_errors $? "make bzImage failed"
+make -j$THREADS modules CC=$CC
+check_errors $? "make modules failed"
+sudo make modules_install
+check_errors $? "make modules_install failed"
+sudo make headers_install INSTALL_HDR_PATH=/usr/src/linux-headers-"$VER"
+check_errors $? "make headers_install failed"
+
+#If all the above were successful, we doubt the rest will fail
+echo "Copying vmlinuz, config, and .map to /boot..."
+sudo cp arch/x86/boot/bzImage /boot/vmlinuz-"$VER"
+sudo cp .config /boot/config-"$VER"
+sudo cp System.map /boot/System.map-"$VER"
+
+# Determine Linux distribution
+DISTRO=`detect_os`
+
+# Generate ramfs and update bootloader as needed by different distributions
+if [ "$DISTRO" == "ubuntu" ]; then
+	echo "Running update-initramfs and update-grub for Ubuntu..."
+	sudo update-initramfs -c -k "$VER"
+	sudo update-grub
+
+elif [ "$DISTRO" == "arch" ]; then
+	echo "Running mkinitcpio for Arch Linux..."
+	mkinitcpio -k $VER -g /boot/kernel-$VER.img
+
+else
+	echo "Error: Could not figure out how to generate ramfs or update bootloader on your distribution: $DISTRO"  
+	echo "Please do this manually"
+
+fi
diff --git a/mm/memblock.c b/mm/memblock.c
index 84bec49..593c052 100644
--- a/mm/memblock.c
+++ b/mm/memblock.c
@@ -138,8 +138,13 @@ static phys_addr_t __init_memblock memblock_find_base(phys_addr_t size,
 		if (bottom >= top)
 			continue;
 		found = memblock_find_region(bottom, top, size, align);
-		if (found != MEMBLOCK_ERROR)
+		if (found != MEMBLOCK_ERROR) {
+			if (found < 0x1000000) {
+				printk("memblock_find_base: BELOW 16 MB, reserved block of size 0x%lx at phys addr 0x%lx\n",
+					size, found);
+			}
 			return found;
+		}
 	}
 	return MEMBLOCK_ERROR;
 }
diff --git a/mm/memory.c b/mm/memory.c
index 1b1ca17..d9e339e 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2266,8 +2266,9 @@ int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,
 	if (addr == vma->vm_start && end == vma->vm_end) {
 		vma->vm_pgoff = pfn;
 		vma->vm_flags |= VM_PFN_AT_MMAP;
-	} else if (is_cow_mapping(vma->vm_flags))
+	} else if (is_cow_mapping(vma->vm_flags) && !current->executing_for_remote) 
 		return -EINVAL;
+    
 
 	vma->vm_flags |= VM_IO | VM_RESERVED | VM_PFNMAP;
 
@@ -2290,8 +2291,9 @@ int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,
 		next = pgd_addr_end(addr, end);
 		err = remap_pud_range(mm, pgd, addr, next,
 				pfn + (addr >> PAGE_SHIFT), prot);
-		if (err)
+		if (err) 
 			break;
+        
 	} while (pgd++, addr = next, addr != end);
 
 	if (err)
diff --git a/mm/mmap.c b/mm/mmap.c
index eae90af..0d42b86 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -30,6 +30,7 @@
 #include <linux/perf_event.h>
 #include <linux/audit.h>
 #include <linux/khugepaged.h>
+#include <linux/process_server.h>
 
 #include <asm/uaccess.h>
 #include <asm/cacheflush.h>
@@ -1329,6 +1330,10 @@ out:
 			mm->locked_vm += (len >> PAGE_SHIFT);
 	} else if ((flags & MAP_POPULATE) && !(flags & MAP_NONBLOCK))
 		make_pages_present(addr, addr + len);
+
+    // Success - notify other cpus if necessary
+    process_server_notify_mmap(file, addr, len, flags, vm_flags, pgoff);
+
 	return addr;
 
 unmap_and_free_vma:
@@ -2096,6 +2101,8 @@ int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)
 	/* Fix up all other VM information */
 	remove_vma_list(mm, vma);
 
+    process_server_notify_munmap(mm, start, len);
+
 	return 0;
 }
 
diff --git a/mm/nobootmem.c b/mm/nobootmem.c
index 7fa41b4..e94421e 100644
--- a/mm/nobootmem.c
+++ b/mm/nobootmem.c
@@ -23,6 +23,8 @@
 
 #include "internal.h"
 
+#include <linux/multikernel.h>
+
 #ifndef CONFIG_NEED_MULTIPLE_NODES
 struct pglist_data __refdata contig_page_data;
 EXPORT_SYMBOL(contig_page_data);
@@ -43,6 +45,10 @@ static void * __init __alloc_memory_core_early(int nid, u64 size, u64 align,
 
 	addr = find_memory_core_early(nid, size, align, goal, limit);
 
+	if (addr < 0x1000000) {
+		printk("Allocated bootmem below 16 MB, address 0x%lx\n", addr);
+	}
+
 	if (addr == MEMBLOCK_ERROR)
 		return NULL;
 
@@ -241,8 +247,9 @@ static void * __init ___alloc_bootmem(unsigned long size, unsigned long align,
 {
 	void *mem = ___alloc_bootmem_nopanic(size, align, goal, limit);
 
-	if (mem)
+	if (mem) 
 		return mem;
+
 	/*
 	 * Whoops, we cannot satisfy the allocation request.
 	 */
@@ -352,6 +359,8 @@ void * __init __alloc_bootmem_node_nopanic(pg_data_t *pgdat, unsigned long size,
 #define ARCH_LOW_ADDRESS_LIMIT	0xffffffffUL
 #endif
 
+#define ARCH_LOW_ADDRESS_LIMIT_64 0xffffffffffffffffULL
+
 /**
  * __alloc_bootmem_low - allocate low boot memory
  * @size: size of the request in bytes
@@ -368,7 +377,11 @@ void * __init __alloc_bootmem_node_nopanic(pg_data_t *pgdat, unsigned long size,
 void * __init __alloc_bootmem_low(unsigned long size, unsigned long align,
 				  unsigned long goal)
 {
-	return ___alloc_bootmem(size, align, goal, ARCH_LOW_ADDRESS_LIMIT);
+	if (mklinux_boot) {
+		return ___alloc_bootmem(size, align, goal, ARCH_LOW_ADDRESS_LIMIT_64);
+	} else {
+		return ___alloc_bootmem(size, align, goal, ARCH_LOW_ADDRESS_LIMIT);
+	}
 }
 
 /**
diff --git a/mm/percpu.c b/mm/percpu.c
index 716eb4a..c49182b 100644
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@ -1129,12 +1129,12 @@ static void pcpu_dump_alloc_info(const char *lvl,
 				printk("\n");
 				printk("%spcpu-alloc: ", lvl);
 			}
-			printk("[%0*d] ", group_width, group);
+			printk("[%0*d] ", group_width, group); // print group id
 
 			for (unit_end += upa; unit < unit_end; unit++)
 				if (gi->cpu_map[unit] != NR_CPUS)
 					printk("%0*d ", cpu_width,
-					       gi->cpu_map[unit]);
+					       gi->cpu_map[unit]); // print cpuid of each element in the group
 				else
 					printk("%s ", empty_str);
 		}
@@ -1471,7 +1471,8 @@ static struct pcpu_alloc_info * __init pcpu_build_alloc_info(
 	/* group cpus according to their proximity */
 	for_each_possible_cpu(cpu) {
 		group = 0;
-	next_group:
+	/* POPCORN -- this should be commented out */
+/*	next_group:
 		for_each_possible_cpu(tcpu) {
 			if (cpu == tcpu)
 				break;
@@ -1483,7 +1484,7 @@ static struct pcpu_alloc_info * __init pcpu_build_alloc_info(
 				goto next_group;
 			}
 		}
-		group_map[cpu] = group;
+*/		group_map[cpu] = group;
 		group_cnt[group]++;
 	}
 
diff --git a/pcnmsg/Makefile b/pcnmsg/Makefile
new file mode 100644
index 0000000..7dcef8d
--- /dev/null
+++ b/pcnmsg/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for Popcorn messaging.
+#
+
+obj-$(CONFIG_POPCORN_KMSG) += pcn_kmsg.o
+obj-$(CONFIG_POPCORN_KMSG) += pcn_ipi_test.o
diff --git a/pcnmsg/pcn_ipi_test.c b/pcnmsg/pcn_ipi_test.c
new file mode 100644
index 0000000..039edcc
--- /dev/null
+++ b/pcnmsg/pcn_ipi_test.c
@@ -0,0 +1,121 @@
+/*
+ * IPI latency measurement for Popcorn
+ *
+ * (C) Ben Shelton <beshelto@vt.edu> 2013
+ */
+
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/smp.h>
+#include <linux/syscalls.h>
+#include <linux/kernel.h>
+#include <linux/multikernel.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+
+#include <asm/system.h>
+#include <asm/apic.h>
+#include <asm/hardirq.h>
+#include <asm/setup.h>
+#include <asm/bootparam.h>
+#include <asm/errno.h>
+
+volatile unsigned long tsc;
+volatile int done;
+
+extern int my_cpu;
+
+#define NUM_TRIALS 1000
+
+/* Ping-pong interrupt handler */
+void smp_popcorn_ipi_latency_interrupt(struct pt_regs *regs)
+{
+	ack_APIC_irq();
+
+	//printk("Ping-pong IPI received!\n");
+#if 0
+	if (my_cpu) {
+		//printk("Sending IPI back to CPU 0...\n");
+		// send IPI back to sender
+		apic->send_IPI_mask(cpumask_of(0), POPCORN_IPI_LATENCY_VECTOR);
+	} else {
+		//printk("Received ping-pong; reading end timestamp...\n");
+		rdtscll(tsc);
+		done = 1;
+	}
+#endif
+
+	return;
+}
+
+static unsigned long calculate_tsc_overhead(void)
+{
+	unsigned long t0, t1, overhead = ~0UL;
+	int i;
+
+	for (i = 0; i < 1000; i++) {
+		rdtscll(t0);
+		asm volatile("");
+		rdtscll(t1);
+		if (t1 - t0 < overhead)
+			overhead = t1 - t0;
+	}
+
+	printk("tsc overhead is %ld\n", overhead);
+
+	return overhead;
+}
+
+unsigned long test_ipi_pingpong(int cpu)
+{
+	unsigned long tsc_init, tsc_final;
+
+	done = 0;
+	rdtscll(tsc_init);
+	apic->send_IPI_mask(cpumask_of(cpu), POPCORN_IPI_LATENCY_VECTOR);
+	while (!done) {}
+	rdtscll(tsc_final);
+
+	return tsc_final - tsc_init;
+}
+
+unsigned long test_ipi_send_time(int cpu)
+{
+	unsigned long tsc_init, tsc_final;
+
+	rdtscll(tsc_init);
+	apic->send_IPI_mask(cpumask_of(cpu), POPCORN_IPI_LATENCY_VECTOR);
+	rdtscll(tsc_final);
+
+	return tsc_final - tsc_init;
+
+}
+
+/* Syscall for testing all this stuff */
+SYSCALL_DEFINE1(popcorn_test_ipi_latency, int, cpu)
+{
+	int rc = 0, i;
+	unsigned long result, result_min = ~0UL, result_max = 0;
+	unsigned long overhead = calculate_tsc_overhead();
+
+	printk("Reached IPI latency syscall, sending to CPU %d\n", cpu);
+
+	done = 0;
+
+	for (i = 0; i < NUM_TRIALS; i++) {
+		result = test_ipi_send_time(cpu) - overhead;
+
+		if (result < result_min) {
+			result_min = result;
+		}
+
+		if (result > result_max) {
+			result_max = result;
+		}
+	}
+
+	printk("Performed %d trials, min time %ld, max time %ld\n",
+			NUM_TRIALS, result_min, result_max);
+
+	return rc;
+}
diff --git a/pcnmsg/pcn_kmsg.c b/pcnmsg/pcn_kmsg.c
new file mode 100644
index 0000000..4cd77bd
--- /dev/null
+++ b/pcnmsg/pcn_kmsg.c
@@ -0,0 +1,1255 @@
+/*
+ * Inter-kernel messaging support for Popcorn
+ *
+ * (C) Ben Shelton <beshelto@vt.edu> 2013
+ */
+
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/smp.h>
+#include <linux/syscalls.h>
+#include <linux/kernel.h>
+#include <linux/multikernel.h>
+#include <linux/pcn_kmsg.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+
+#include <asm/system.h>
+#include <asm/apic.h>
+#include <asm/hardirq.h>
+#include <asm/setup.h>
+#include <asm/bootparam.h>
+#include <asm/errno.h>
+#include <asm/atomic.h>
+
+/* COMMON STATE */
+
+/* table of callback functions for handling each message type */
+pcn_kmsg_cbftn callback_table[PCN_KMSG_TYPE_MAX];
+
+/* number of current kernel */
+int my_cpu = 0;
+
+/* pointer to table with phys addresses for remote kernels' windows,
+ * owned by kernel 0 */
+struct pcn_kmsg_rkinfo *rkinfo;
+
+/* table with virtual (mapped) addresses for remote kernels' windows,
+   one per kernel */
+struct pcn_kmsg_window * rkvirt[POPCORN_MAX_CPUS];
+
+/* Same thing, but for mcast windows */
+struct pcn_kmsg_mcast_local mcastlocal[POPCORN_MAX_MCAST_CHANNELS];
+
+/* lists of messages to be processed for each prio */
+struct list_head msglist_hiprio, msglist_normprio;
+
+/* array to hold pointers to large messages received */
+struct pcn_kmsg_long_message * lg_buf[POPCORN_MAX_CPUS];
+
+/* action for bottom half */
+static void pcn_kmsg_action(struct softirq_action *h);
+
+/* workqueue for operations that can sleep */
+static struct workqueue_struct *kmsg_wq;
+
+/* RING BUFFER */
+
+#define RB_SHIFT 6
+#define RB_SIZE (1 << RB_SHIFT)
+#define RB_MASK ((1 << RB_SHIFT) - 1)
+
+#define PCN_DEBUG(...) ;
+//#define PCN_WARN(...) printk(__VA_ARGS__)
+#define PCN_WARN(...) ;
+#define PCN_ERROR(...) printk(__VA_ARGS__)
+
+/* From Wikipedia page "Fetch and add", modified to work for u64 */
+static inline unsigned long fetch_and_add(volatile unsigned long * variable, 
+				   unsigned long value)
+{
+	asm volatile( 
+		     "lock; xaddq %%rax, %2;"
+		     :"=a" (value)                   //Output
+		     : "a" (value), "m" (*variable)  //Input
+		     :"memory" );
+	return value;
+}
+
+static inline unsigned long win_inuse(struct pcn_kmsg_window *win) 
+{
+	return win->head - win->tail;
+}
+
+static inline int win_put(struct pcn_kmsg_window *win, 
+			  struct pcn_kmsg_message *msg) 
+{
+	unsigned long ticket;
+
+	/* if the queue is already really long, return EAGAIN */
+	if (win_inuse(win) >= RB_SIZE) {
+		printk("Window full, caller should try again...\n");
+		return -EAGAIN;
+	}
+
+	/* grab ticket */
+	ticket = fetch_and_add(&win->head, 1);
+	PCN_DEBUG(KERN_ERR "%s: ticket = %lu, head = %lu, tail = %lu\n", 
+		 __func__, ticket, win->head, win->tail);
+
+	/* spin until there's a spot free for me */
+	while (win_inuse(win) >= RB_SIZE) {}
+
+	/* insert item */
+	memcpy(&win->buffer[ticket & RB_MASK], msg, 
+	       sizeof(struct pcn_kmsg_message));
+
+	pcn_barrier();
+
+	/* set completed flag */
+	win->buffer[ticket & RB_MASK].hdr.ready = 1;
+
+	return 0;
+}
+
+static inline int win_get(struct pcn_kmsg_window *win, 
+			  struct pcn_kmsg_message **msg) 
+{
+	struct pcn_kmsg_message *rcvd;
+
+	if (!win_inuse(win)) {
+		PCN_WARN(KERN_ERR "%s: Nothing in buffer, returning...\n", __func__);
+		return -1;
+	}
+
+	PCN_DEBUG(KERN_ERR "%s: reached win_get, head %lu, tail %lu\n", 
+	       __func__, win->head, win->tail);
+
+	/* spin until entry.ready at end of cache line is set */
+	rcvd = &(win->buffer[win->tail & RB_MASK]);
+	//printk(KERN_ERR "Ready bit: %u\n", rcvd->hdr.ready);
+	while (!rcvd->hdr.ready) {
+		pcn_cpu_relax();
+	}
+
+	// barrier here?
+	pcn_barrier();
+
+	rcvd->hdr.ready = 0;
+
+	*msg = rcvd;	
+
+	return 0;
+}
+
+static inline void win_advance_tail(struct pcn_kmsg_window *win) 
+{
+	win->tail++;
+}
+
+#define MCASTWIN(_id_) (mcastlocal[(_id_)].mcastvirt)
+#define LOCAL_TAIL(_id_) (mcastlocal[(_id_)].local_tail)
+
+/* MULTICAST RING BUFFER */
+static inline unsigned long mcastwin_inuse(pcn_kmsg_mcast_id id)
+{
+	        return MCASTWIN(id)->head - MCASTWIN(id)->tail;
+}
+
+static inline int mcastwin_put(pcn_kmsg_mcast_id id,
+			  struct pcn_kmsg_message *msg)
+{
+	unsigned long ticket;
+
+	/* if the queue is already really long, return EAGAIN */
+	if (mcastwin_inuse(id) >= RB_SIZE) {
+		PCN_WARN(KERN_ERR"%s: Window full, caller should try again...\n", __func__);
+		return -EAGAIN;
+	}
+
+	/* grab ticket */
+	ticket = fetch_and_add(&MCASTWIN(id)->head, 1);
+	PCN_DEBUG(KERN_ERR "%s: ticket = %lu, head = %lu, tail = %lu\n", __func__,
+	       ticket, MCASTWIN(id)->head, MCASTWIN(id)->tail);
+
+	/* spin until there's a spot free for me */
+	while (mcastwin_inuse(id) >= RB_SIZE) {}
+
+	/* insert item */
+	memcpy(&MCASTWIN(id)->buffer[ticket & RB_MASK], msg,
+	       sizeof(struct pcn_kmsg_message));
+
+	/* set counter to (# in group - self) */
+	MCASTWIN(id)->read_counter[ticket & RB_MASK] = 
+		rkinfo->mcast_wininfo[id].num_members - 1;
+
+	pcn_barrier();
+
+	/* set completed flag */
+	MCASTWIN(id)->buffer[ticket & RB_MASK].hdr.ready = 1;
+
+	return 0;
+}
+
+static inline int mcastwin_get(pcn_kmsg_mcast_id id,
+			  struct pcn_kmsg_message **msg)
+{
+	struct pcn_kmsg_message *rcvd;
+
+	if (!mcastwin_inuse(id)) {
+		PCN_WARN(KERN_ERR"%s: Nothing in buffer, returning...\n", __func__);
+		return -1;
+	}
+
+	PCN_DEBUG(KERN_ERR "%s: reached mcastwin_get, head %lu, tail %lu\n", __func__,
+	       MCASTWIN(id)->head, MCASTWIN(id)->tail);
+
+	/* spin until entry.ready at end of cache line is set */
+	rcvd = &(MCASTWIN(id)->buffer[MCASTWIN(id)->tail & RB_MASK]);
+	//printk(KERN_ERR "Ready bit: %u\n", rcvd->hdr.ready);
+	while (!rcvd->hdr.ready) {
+		pcn_cpu_relax();
+	}
+
+	// barrier here?
+	pcn_barrier();
+
+	rcvd->hdr.ready = 0;
+
+	*msg = rcvd;
+
+	return 0;
+}
+
+static inline void mcastwin_advance_tail(pcn_kmsg_mcast_id id)
+{
+	unsigned long slot = LOCAL_TAIL(id) & RB_MASK;
+
+	PCN_DEBUG(KERN_ERR "%s: Advancing tail; local tail currently on slot %lu\n", __func__, LOCAL_TAIL(id));
+
+	if (atomic_dec_and_test((atomic_t *) &MCASTWIN(id)->read_counter[slot])) {
+		PCN_DEBUG(KERN_ERR"%s: We're the last reader to go; advancing global tail\n", __func__);
+		atomic64_inc((atomic64_t *) &MCASTWIN(id)->tail);
+	}
+
+	LOCAL_TAIL(id)++;
+}
+
+/* INITIALIZATION */
+
+static int pcn_kmsg_mcast_callback(struct pcn_kmsg_message *message);
+
+/* bottom half for workqueue */
+static void process_kmsg_wq_item(struct work_struct * work)
+{
+	int cpu;
+	pcn_kmsg_mcast_id id;
+	pcn_kmsg_work_t *w = (pcn_kmsg_work_t *) work;
+
+	PCN_DEBUG(KERN_ERR "%s: Processing kmsg wq item, op %d\n", __func__, w->op);
+
+	switch (w->op) {
+		case PCN_KMSG_WQ_OP_MAP_MSG_WIN:
+			cpu = w->cpu_to_add;
+
+			if (cpu < 0 || cpu >= POPCORN_MAX_CPUS) {
+				PCN_ERROR(KERN_ERR"%s: Invalid CPU %d specified!\n", __func__, cpu);
+				return;
+			}
+
+			rkvirt[cpu] = ioremap_cache(rkinfo->phys_addr[cpu],
+						    ((sizeof(struct pcn_kmsg_window) >> PAGE_SHIFT) +1)<< PAGE_SHIFT);
+PCN_DEBUG("%s: ioremap %lx [%d] %ld\n", 
+	  __func__, rkinfo->phys_addr[cpu], cpu, ((sizeof(struct pcn_kmsg_window) >> PAGE_SHIFT) +1) << PAGE_SHIFT);
+
+			if (rkvirt[cpu]) {
+				PCN_DEBUG("%s: ioremapped window, virt addr 0x%p\n", __func__,
+				       rkvirt[cpu]);
+			} else {
+				PCN_DEBUG("%s: Failed to ioremap CPU %d's window at phys addr 0x%lx\n",
+				       __func__, cpu, rkinfo->phys_addr[cpu]);
+			}
+			break;
+
+		case PCN_KMSG_WQ_OP_UNMAP_MSG_WIN:
+			PCN_DEBUG("%s: UNMAP_MSG_WIN not yet implemented!\n", __func__);
+			break;
+
+		case PCN_KMSG_WQ_OP_MAP_MCAST_WIN:
+			id = w->id_to_join;
+
+			/* map window */
+			if (id < 0 || id > POPCORN_MAX_MCAST_CHANNELS) {
+				PCN_ERROR("%s: Invalid mcast channel id %lu specified!\n", __func__, id);
+				return;
+			}
+
+			MCASTWIN(id) = ioremap_cache(rkinfo->mcast_wininfo[id].phys_addr,
+						    sizeof(struct pcn_kmsg_mcast_window));
+			if (MCASTWIN(id)) {
+				PCN_WARN("%s: ioremapped mcast window, virt addr 0x%p\n", __func__,
+				       MCASTWIN(id));
+			} else {
+				PCN_ERROR("%s: Failed to ioremap mcast window %lu at phys addr 0x%lx\n", __func__,
+				       id, rkinfo->mcast_wininfo[id].phys_addr);
+			}
+
+
+			break;
+
+		case PCN_KMSG_WQ_OP_UNMAP_MCAST_WIN:
+			PCN_ERROR("%s: UNMAP_MCAST_WIN not yet implemented!\n", __func__);
+			break;
+
+		default:
+			PCN_ERROR("%s: Invalid work queue operation %d\n", __func__, w->op);
+
+	}
+
+	kfree(work);
+}
+
+static int pcn_kmsg_checkin_callback(struct pcn_kmsg_message *message) 
+{
+	struct pcn_kmsg_checkin_message *msg = 
+		(struct pcn_kmsg_checkin_message *) message;
+	int from_cpu = msg->hdr.from_cpu;
+	pcn_kmsg_work_t *kmsg_work = NULL;
+
+	PCN_DEBUG("%s: Called Popcorn callback for processing check-in messages\n", __func__);
+
+	PCN_DEBUG("%s: From CPU %d, type %d, window phys addr 0x%lx\n", __func__,
+	       msg->hdr.from_cpu, msg->hdr.type, 
+	       msg->window_phys_addr);
+
+	if (from_cpu >= POPCORN_MAX_CPUS) {
+		PCN_ERROR("%s: Invalid source CPU %d\n", __func__, msg->hdr.from_cpu);
+		return -1;
+	}
+
+	if (!msg->window_phys_addr) {
+		PCN_ERROR("%s: Window physical address from CPU %d is NULL!\n", __func__,
+		       from_cpu);
+		return -1;
+	}
+
+	/* Note that we're not allowed to ioremap anything from a bottom half,
+	   so we'll add it to a workqueue and do it in a kernel thread. */
+	kmsg_work = kmalloc(sizeof(pcn_kmsg_work_t), GFP_ATOMIC);
+	if (kmsg_work) {
+		INIT_WORK((struct work_struct *) kmsg_work, 
+			  process_kmsg_wq_item);
+		kmsg_work->op = PCN_KMSG_WQ_OP_MAP_MSG_WIN;
+		kmsg_work->from_cpu = msg->hdr.from_cpu;
+		kmsg_work->cpu_to_add = msg->cpu_to_add;
+		queue_work(kmsg_wq, (struct work_struct *) kmsg_work);
+	} else {
+		PCN_ERROR("%s: Failed to malloc work structure; this is VERY BAD!\n", __func__);
+	}
+
+	kfree(message);
+
+	return 0;
+}
+
+static int pcn_kmsg_test_callback(struct pcn_kmsg_message *message)
+{
+	struct pcn_kmsg_long_message *lmsg = 
+		(struct pcn_kmsg_long_message *) message;
+
+	PCN_DEBUG("%s: Received test long message, payload: %s\n", __func__,
+	       (char *) &lmsg->payload);
+
+	return 0;
+}
+
+static inline int pcn_kmsg_window_init(struct pcn_kmsg_window *window)
+{
+	window->head = 0;
+	window->tail = 0;
+	memset(&window->buffer, 0, 
+	       PCN_KMSG_RBUF_SIZE * sizeof(struct pcn_kmsg_message));
+	return 0;
+}
+
+static inline int pcn_kmsg_mcast_window_init(struct pcn_kmsg_mcast_window *window)
+{
+	window->head = 0;
+	window->tail = 0;
+	memset(&window->read_counter, 0, 
+	       PCN_KMSG_RBUF_SIZE * sizeof(int));
+	memset(&window->buffer, 0,
+	       PCN_KMSG_RBUF_SIZE * sizeof(struct pcn_kmsg_message));
+	return 0;
+}
+
+extern unsigned long orig_boot_params;
+
+static int send_checkin_msg(unsigned int cpu_to_add, unsigned int to_cpu)
+{
+	int rc;
+	struct pcn_kmsg_checkin_message msg;
+
+	msg.hdr.type = PCN_KMSG_TYPE_CHECKIN;
+	msg.hdr.prio = PCN_KMSG_PRIO_HIGH;
+	msg.window_phys_addr = rkinfo->phys_addr[my_cpu];
+	msg.cpu_to_add = cpu_to_add;
+
+	rc = pcn_kmsg_send(to_cpu, (struct pcn_kmsg_message *) &msg);
+
+	if (rc) {
+		PCN_WARN("%s: Failed to send checkin message, rc = %d\n", __func__, rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int do_checkin(void)
+{
+	int rc = 0;
+	int i;
+
+	for (i = 0; i < POPCORN_MAX_CPUS; i++) {
+		if (i == my_cpu) {
+			continue;
+		}
+
+		if (rkinfo->phys_addr[i]) {
+			rkvirt[i] = ioremap_cache(rkinfo->phys_addr[i],
+						  ((sizeof(struct pcn_kmsg_window) >> PAGE_SHIFT ) +1) << PAGE_SHIFT);
+			if (rkvirt[i]) {
+				PCN_WARN("%s: ioremapped CPU %d's window, virt addr 0x%p size %ld(%ld)\n", __func__,
+				       i, rkvirt[i], ((sizeof(struct pcn_kmsg_window) >> PAGE_SHIFT) +1) << PAGE_SHIFT , sizeof(struct pcn_kmsg_window));
+			} else {
+				PCN_ERROR("%s: Failed to ioremap CPU %d's window at phys addr 0x%lx\n", __func__,
+				       i, rkinfo->phys_addr[i]);
+				return -1;
+			}
+
+			PCN_DEBUG("%s: Sending checkin message to kernel %d\n", __func__, i);			
+			rc = send_checkin_msg(my_cpu, i);
+			if (rc) {
+				PCN_ERROR("%s: POPCORN: Checkin failed for CPU %d!\n", __func__, i);
+				return rc;
+			}
+		}
+	}
+
+	return rc;
+}
+
+static int __init pcn_kmsg_init(void)
+{
+	int rc;
+	unsigned long win_virt_addr, win_phys_addr, rkinfo_phys_addr;
+	struct boot_params * boot_params_va;
+
+	my_cpu = raw_smp_processor_id();
+	
+	printk("%s: Entered pcn_kmsg_init raw: %d id: %d\n", __func__, my_cpu, smp_processor_id());
+
+	/* Initialize list heads */
+	INIT_LIST_HEAD(&msglist_hiprio);
+	INIT_LIST_HEAD(&msglist_normprio);
+
+	/* Clear out large-message receive buffers */
+	memset(&lg_buf, 0, POPCORN_MAX_CPUS * sizeof(unsigned char *));
+
+	/* Clear callback table and register default callback functions */
+	PCN_DEBUG("%s: Registering initial callbacks...\n", __func__);
+	memset(&callback_table, 0, PCN_KMSG_TYPE_MAX * sizeof(pcn_kmsg_cbftn));
+	rc = pcn_kmsg_register_callback(PCN_KMSG_TYPE_CHECKIN, 
+					&pcn_kmsg_checkin_callback);
+	if (rc) {
+		printk("POPCORN: Failed to register initial kmsg checkin callback!\n");
+	}
+
+	rc = pcn_kmsg_register_callback(PCN_KMSG_TYPE_MCAST, 
+					&pcn_kmsg_mcast_callback);
+	if (rc) {
+		printk("POPCORN: Failed to register initial kmsg multicast callback!\n");
+	}
+
+	rc = pcn_kmsg_register_callback(PCN_KMSG_TYPE_TEST, 
+					&pcn_kmsg_test_callback);
+	if (rc) {
+		printk("POPCORN: Failed to register initial kmsg test callback!\n");
+	}
+
+	/* Register softirq handler */
+	PCN_DEBUG("%s: Registering softirq handler...\n", __func__);
+	open_softirq(PCN_KMSG_SOFTIRQ, pcn_kmsg_action);
+
+	/* Initialize work queue */
+	PCN_DEBUG("%s: Initializing workqueue...\n", __func__);
+	kmsg_wq = create_singlethread_workqueue("kmsg_wq");
+
+	/* If we're the master kernel, malloc and map the rkinfo structure and 
+	   put its physical address in boot_params; otherwise, get it from the 
+	   boot_params and map it */
+	if (!mklinux_boot) {
+		PCN_DEBUG("%s: We're the master; mallocing rkinfo...\n", __func__);
+		rkinfo = kmalloc(sizeof(struct pcn_kmsg_rkinfo), GFP_KERNEL);
+
+		if (!rkinfo) {
+			PCN_ERROR("%s: Failed to malloc rkinfo structure -- this is very bad!\n", __func__);
+			return -1;
+		}
+
+		rkinfo_phys_addr = virt_to_phys(rkinfo);
+
+		PCN_DEBUG("%s: rkinfo virt addr 0x%p, phys addr 0x%lx\n", __func__,
+		       rkinfo, rkinfo_phys_addr);
+
+		memset(rkinfo, 0x0, sizeof(struct pcn_kmsg_rkinfo));
+
+		PCN_DEBUG("%s: Setting boot_params...\n", __func__);
+		/* Otherwise, we need to set the boot_params to show the rest
+		   of the kernels where the master kernel's messaging window is. */
+		boot_params_va = (struct boot_params *) 
+			(0xffffffff80000000 + orig_boot_params);
+		PCN_DEBUG("%s: Boot params virtual address: 0x%p\n", __func__, boot_params_va);
+		boot_params_va->pcn_kmsg_master_window = rkinfo_phys_addr;
+	} else {
+		PCN_DEBUG("%s: Master kernel rkinfo phys addr: 0x%lx\n", __func__, 
+		       (unsigned long) boot_params.pcn_kmsg_master_window);
+
+		rkinfo_phys_addr = boot_params.pcn_kmsg_master_window;
+		rkinfo = ioremap_cache(rkinfo_phys_addr, 
+				       sizeof(struct pcn_kmsg_rkinfo));
+
+		if (!rkinfo) {
+			PCN_ERROR("%s: Failed to ioremap rkinfo struct from master kernel! Continuing..\n", __func__);
+		}
+
+		PCN_DEBUG("%s: rkinfo virt addr: 0x%p\n", __func__, rkinfo);
+	}
+
+	/* Malloc our own receive buffer and set it up */
+	win_virt_addr = kmalloc(sizeof(struct pcn_kmsg_window), GFP_KERNEL);
+	PCN_DEBUG("%s: Allocated %ld bytes for my window, virt addr 0x%lx\n", __func__, 
+	       sizeof(struct pcn_kmsg_window), win_virt_addr);
+	rkvirt[my_cpu] = (struct pcn_kmsg_window *) win_virt_addr;
+	win_phys_addr = virt_to_phys((void *) win_virt_addr);
+	PCN_DEBUG("%s: Physical address: 0x%lx\n", __func__, win_phys_addr);
+	rkinfo->phys_addr[my_cpu] = win_phys_addr;
+
+	rc = pcn_kmsg_window_init(rkvirt[my_cpu]);
+	if (rc) {
+		printk("POPCORN: Failed to initialize kmsg recv window! Continuing..\n");
+	}
+
+	/* If we're not the master kernel, we need to check in */
+	if (mklinux_boot) {
+		rc = do_checkin();
+
+		if (rc) { 
+			printk("POPCORN: Failed to check in!\n");
+			return -1;
+		}
+	} 
+
+	return 0;
+}
+
+subsys_initcall(pcn_kmsg_init);
+
+/* Register a callback function when a kernel module is loaded */
+int pcn_kmsg_register_callback(enum pcn_kmsg_type type, pcn_kmsg_cbftn callback)
+{
+	PCN_WARN("%s: registering callback for type %d, ptr 0x%p\n", __func__, type, callback);
+
+	if (type >= PCN_KMSG_TYPE_MAX) {
+		PCN_ERROR("%s: Attempted to register callback with bad type %d\n", __func__, type);
+		return -1;
+	}
+
+	callback_table[type] = callback;
+
+	return 0;
+}
+
+/* Unregister a callback function when a kernel module is unloaded */
+int pcn_kmsg_unregister_callback(enum pcn_kmsg_type type)
+{
+	if (type >= PCN_KMSG_TYPE_MAX) {
+		PCN_ERROR("%s: Attempted to register callback with bad type %d\n", __func__, type);
+		return -1;
+	}
+
+	callback_table[type] = NULL;
+
+	return 0;
+}
+
+/* SENDING / MARSHALING */
+
+static int __pcn_kmsg_send(unsigned int dest_cpu, struct pcn_kmsg_message *msg)
+{
+	int rc;
+	struct pcn_kmsg_window *dest_window;
+
+	if (dest_cpu >= POPCORN_MAX_CPUS) {
+		PCN_ERROR("%s: Invalid destination CPU %d\n", __func__, dest_cpu);
+		return -1;
+	}
+
+	dest_window = rkvirt[dest_cpu];
+
+	if (!rkvirt[dest_cpu]) {
+		PCN_ERROR("%s: Destination window for CPU %d not mapped -- this is VERY BAD!\n", __func__, dest_cpu);
+		/* check if phys addr exists, and if so, map it */
+		return -1;
+	}
+
+	if (!msg) {
+		PCN_ERROR("%s: Passed in a null pointer to msg!\n", __func__);
+		return -1;
+	}
+
+	/* set source CPU */
+	msg->hdr.from_cpu = my_cpu;
+
+	/* place message in rbuf */
+	rc = win_put(dest_window, msg);		
+
+	if (rc) {
+		PCN_WARN("%s: Failed to place message in destination window -- maybe it's full?\n", __func__);
+		return -1;
+	}
+
+	/* send IPI */
+	apic->send_IPI_mask(cpumask_of(dest_cpu), POPCORN_KMSG_VECTOR);
+
+	return 0;
+}
+
+int pcn_kmsg_send(unsigned int dest_cpu, struct pcn_kmsg_message *msg)
+{
+	msg->hdr.is_lg_msg = 0;
+	msg->hdr.lg_start = 0;
+	msg->hdr.lg_end = 0;
+	msg->hdr.lg_seqnum = 0;
+
+	return __pcn_kmsg_send(dest_cpu, msg);
+}
+
+int pcn_kmsg_send_long(unsigned int dest_cpu, 
+		       struct pcn_kmsg_long_message *lmsg, 
+		       unsigned int payload_size)
+{
+	int i;
+	int num_chunks = payload_size / PCN_KMSG_PAYLOAD_SIZE;
+	struct pcn_kmsg_message this_chunk;
+	//char test_buf[15];
+
+	if (payload_size % PCN_KMSG_PAYLOAD_SIZE) {
+		num_chunks++;
+	}
+
+	PCN_DEBUG("%s: Sending large message to CPU %d, type %d, payload size %d bytes, %d chunks\n", __func__, dest_cpu, lmsg->hdr.type, payload_size, num_chunks);
+
+	this_chunk.hdr.type = lmsg->hdr.type;
+	this_chunk.hdr.prio = lmsg->hdr.prio;
+	this_chunk.hdr.is_lg_msg = 1;
+
+	for (i = 0; i < num_chunks; i++) {
+		PCN_DEBUG("%s: Sending chunk %d\n", __func__, i);
+
+		this_chunk.hdr.lg_start = (i == 0) ? 1 : 0;
+		this_chunk.hdr.lg_end = (i == num_chunks - 1) ? 1 : 0;
+		this_chunk.hdr.lg_seqnum = (i == 0) ? num_chunks : i;
+
+		memcpy(&this_chunk.payload, 
+		       ((unsigned char *) &lmsg->payload) + 
+		       i * PCN_KMSG_PAYLOAD_SIZE, 
+		       PCN_KMSG_PAYLOAD_SIZE);
+
+		//memcpy(test_buf, &this_chunk.payload, 10);
+		//test_buf[11] = '\0';
+
+		//printk("First 10 characters: %s\n", test_buf);
+
+		__pcn_kmsg_send(dest_cpu, &this_chunk);
+	}
+
+	return 0;
+}
+
+/* RECEIVING / UNMARSHALING */
+
+static int process_message_list(struct list_head *head) 
+{
+	int rc, rc_overall = 0;
+	struct pcn_kmsg_container *pos = NULL, *n = NULL;
+	struct pcn_kmsg_message *msg;
+
+	list_for_each_entry_safe(pos, n, head, list) {
+		msg = &pos->msg;
+
+		PCN_DEBUG("%s: Item in list, type %d,  processing it...\n", __func__,
+		       msg->hdr.type);
+
+		list_del(&pos->list);
+
+		if (msg->hdr.type >= PCN_KMSG_TYPE_MAX || 
+		    !callback_table[msg->hdr.type]) {
+			PCN_WARN("%s: Invalid type %d; continuing!\n", __func__, msg->hdr.type);
+			continue;
+		}
+
+		rc = callback_table[msg->hdr.type](msg);
+		if (!rc_overall) {
+			rc_overall = rc;
+		}
+
+		/* NOTE: callback function is responsible for freeing memory
+		   that was kmalloced! */
+	}
+
+	return rc_overall;
+}
+
+//void pcn_kmsg_do_tasklet(unsigned long);
+//DECLARE_TASKLET(pcn_kmsg_tasklet, pcn_kmsg_do_tasklet, 0);
+
+/* top half */
+void smp_popcorn_kmsg_interrupt(struct pt_regs *regs)
+{
+	ack_APIC_irq();
+
+	PCN_DEBUG("%s: Reached Popcorn KMSG interrupt handler!\n", __func__);
+
+	inc_irq_stat(irq_popcorn_kmsg_count);
+	irq_enter();
+
+	/* We do as little work as possible in here (decoupling notification 
+	   from messaging) */
+
+	/* schedule bottom half */
+	__raise_softirq_irqoff(PCN_KMSG_SOFTIRQ);
+	//tasklet_schedule(&pcn_kmsg_tasklet);
+
+	irq_exit();
+	return;
+}
+
+static int process_large_message(struct pcn_kmsg_message *msg)
+{
+	int rc = 0;
+	int recv_buf_size;
+
+	
+	// THERE IS NO CHECK FOR AN EXISTENT MESSAGE IN THE BUFFER!!! :-(
+	
+	
+	PCN_DEBUG( "%s: Got a large message fragment, type %u, from_cpu %u, start %u, end %u, seqnum %u!\n", __func__,
+	       msg->hdr.type, msg->hdr.from_cpu,
+	       msg->hdr.lg_start, msg->hdr.lg_end,
+	       msg->hdr.lg_seqnum);
+
+	if (msg->hdr.lg_start) {
+		PCN_DEBUG("%s: Processing initial message fragment...\n", __func__);
+
+		recv_buf_size = sizeof(struct pcn_kmsg_hdr) + 
+			msg->hdr.lg_seqnum * PCN_KMSG_PAYLOAD_SIZE;
+
+		lg_buf[msg->hdr.from_cpu] = kmalloc(recv_buf_size, GFP_ATOMIC);
+
+		if (!lg_buf[msg->hdr.from_cpu]) {
+			PCN_ERROR("%s: Unable to kmalloc buffer for incoming message!  THIS IS BAD!\n", __func__);
+			goto out;
+		}
+
+		/* copy header first */
+		memcpy((unsigned char *)lg_buf[msg->hdr.from_cpu], 
+		       &msg->hdr, sizeof(struct pcn_kmsg_hdr));
+
+		/* copy first chunk of message */
+		memcpy((unsigned char *)lg_buf[msg->hdr.from_cpu] + 
+		       sizeof(struct pcn_kmsg_hdr),
+		       &msg->payload, PCN_KMSG_PAYLOAD_SIZE);
+
+		if (msg->hdr.lg_end) {
+			PCN_WARN("%s: NOTE: Long message of length 1 received; this isn't efficient!\n", __func__);
+			
+			if (unlikely(!callback_table[msg->hdr.type])) {
+				PCN_WARN("%s: Callback function for message type %d not registered!\n", __func__,
+						msg->hdr.type);
+				goto out;
+			}
+			
+			rc = callback_table[msg->hdr.type]((struct pcn_kmsg_message *)lg_buf[msg->hdr.from_cpu]);
+
+			if (rc) {
+				PCN_ERROR("%s: Large message callback failed!\n", __func__);
+			}
+		}
+	} else {
+		
+		PCN_DEBUG("%s: Processing subsequent message fragment...\n", __func__);
+
+		memcpy((unsigned char *)lg_buf[msg->hdr.from_cpu] + 
+		       sizeof(struct pcn_kmsg_hdr) + 
+		       PCN_KMSG_PAYLOAD_SIZE * msg->hdr.lg_seqnum,
+		       &msg->payload, PCN_KMSG_PAYLOAD_SIZE);
+
+		if (msg->hdr.lg_end) {
+			PCN_DEBUG("%s: Last fragment in series...\n", __func__);
+
+			PCN_DEBUG("%s: from_cpu %d, type %d, prio %d\n", __func__,
+			       lg_buf[msg->hdr.from_cpu]->hdr.from_cpu,
+			       lg_buf[msg->hdr.from_cpu]->hdr.type,
+			       lg_buf[msg->hdr.from_cpu]->hdr.prio);
+
+			if (unlikely(!callback_table[msg->hdr.type])) {
+				PCN_WARN("%s: Callback function for message type %d not registered!\n",
+						__func__, msg->hdr.type);
+				goto out;
+			}
+
+			rc = callback_table[msg->hdr.type]((struct pcn_kmsg_message *)lg_buf[msg->hdr.from_cpu]);
+
+			if (rc) {
+				PCN_ERROR("%s: Large message callback failed!\n", __func__);
+			}
+		}
+	}
+
+out:
+
+	win_advance_tail(rkvirt[my_cpu]);
+
+	return rc;
+}
+
+static int process_small_message(struct pcn_kmsg_message *msg)
+{
+	int rc;
+	struct pcn_kmsg_container *incoming;
+
+	/* malloc some memory (don't sleep!) */
+	incoming = kmalloc(sizeof(struct pcn_kmsg_container), GFP_ATOMIC);
+	if (!incoming) {
+		PCN_ERROR("%s: Unable to kmalloc buffer for incoming message!  THIS IS BAD!\n", __func__);
+		win_advance_tail(rkvirt[my_cpu]);
+		return -1;
+	}
+
+	/* memcpy message from rbuf */
+	memcpy(&incoming->msg, msg,
+	       sizeof(struct pcn_kmsg_message));
+	win_advance_tail(rkvirt[my_cpu]);
+
+	PCN_DEBUG("%s: Received message, type %d, prio %d\n", __func__,
+	       incoming->msg.hdr.type, incoming->msg.hdr.prio);
+
+	/* add container to appropriate list */
+	switch (incoming->msg.hdr.prio) {
+		case PCN_KMSG_PRIO_HIGH:
+			PCN_DEBUG("%s: Adding to high-priority list...\n", __func__);
+			list_add_tail(&(incoming->list),
+				      &msglist_hiprio);
+			break;
+
+		case PCN_KMSG_PRIO_NORMAL:
+			PCN_DEBUG("%s: Adding to normal-priority list...\n", __func__);
+			list_add_tail(&(incoming->list),
+				      &msglist_normprio);
+			break;
+
+		default:
+			PCN_ERROR("%s: Priority value %d unknown -- THIS IS BAD!\n", __func__,
+			       incoming->msg.hdr.prio);
+	}
+
+	return rc;
+}
+
+static void process_mcast_queue(pcn_kmsg_mcast_id id)
+{
+	struct pcn_kmsg_message *msg;
+	while (!mcastwin_get(id, &msg)) {
+		PCN_DEBUG("%s: Got an mcast message!\n", __func__);
+
+		mcastwin_advance_tail(id);
+	}
+
+}
+
+/* bottom half */
+static void pcn_kmsg_action(struct softirq_action *h)
+{
+	int rc;
+	struct pcn_kmsg_message *msg;
+	int i;
+
+	PCN_DEBUG("%s: Popcorn kmsg softirq handler called...\n", __func__);
+
+	/* Get messages out of the buffer first */
+
+	while (!win_get(rkvirt[my_cpu], &msg)) {
+		PCN_DEBUG("%s: Got a message!\n", __func__);
+		/* Special processing for large messages */
+		if (msg->hdr.is_lg_msg) {
+			PCN_DEBUG("%s: Message is a large message!\n", __func__);
+			rc = process_large_message(msg);
+		} else {
+			PCN_DEBUG("%s: Message is a small message!\n",  __func__);
+			rc = process_small_message(msg);
+		}
+
+	}
+
+	PCN_DEBUG("%s: No more messages in ring buffer; checking multicast queues...\n", __func__);
+
+	for (i = 0; i < POPCORN_MAX_MCAST_CHANNELS; i++) {
+		if (MCASTWIN(i)) {
+			PCN_DEBUG("%s: mcast window %d mapped, processing it...\n", __func__, i);
+			process_mcast_queue(i);
+		}
+	}
+
+	PCN_DEBUG("%s: Done checking multicast queues; processing messages...\n", __func__);
+
+	/* Process high-priority queue first */
+	rc = process_message_list(&msglist_hiprio);
+
+	if (list_empty(&msglist_hiprio)) {
+		PCN_WARN("%s: High-priority queue is empty!\n", __func__);
+	}
+
+	/* Then process normal-priority queue */
+	rc = process_message_list(&msglist_normprio);
+
+	return;
+}
+
+/* Syscall for testing all this stuff */
+SYSCALL_DEFINE1(popcorn_test_kmsg, int, cpu)
+{
+	int rc = 0;
+
+#if 1
+	/* test mask includes specified CPU and CPU 0 */
+	unsigned long mask = (1 << cpu) | 1;
+	pcn_kmsg_mcast_id test_id = -1;
+
+	rc = pcn_kmsg_mcast_open(&test_id, mask);
+	if (rc) {
+		printk("POPCORN: pcn_kmsg_mcast_open returned %d, test_id %lu\n", 
+		       rc, test_id);
+	}
+
+#else
+
+	struct pcn_kmsg_long_message lmsg;
+	char *str = "This is a very long test message.  Don't be surprised if it gets corrupted; it probably will.  If it does, you're in for a lot more work, and may not get home to see your wife this weekend.  You should knock on wood before running this test.";
+
+
+	lmsg.hdr.type = PCN_KMSG_TYPE_TEST;
+	lmsg.hdr.prio = PCN_KMSG_PRIO_NORMAL;
+
+	strcpy(&lmsg.payload, str); 
+
+	printk("Message to send: %s\n", &lmsg.payload);
+
+	printk("POPCORN: syscall to test kernel messaging, to CPU %d\n", cpu);
+
+	rc = pcn_kmsg_send_long(cpu, &lmsg, strlen(str) + 5);
+
+	if (rc) {
+		printk("POPCORN: error: pcn_kmsg_send_long returned %d\n", rc);
+	}
+
+#endif
+
+	return rc;
+}
+
+/* MULTICAST */
+
+inline int count_members(unsigned long mask)
+{
+	int i, count = 0;
+
+	for (i = 0; i < POPCORN_MAX_CPUS; i++) {
+		if (mask & (1ULL << i)) {
+			count++;
+		}
+	}
+
+	return count;
+}
+
+void print_mcast_map(void)
+{
+	int i;
+
+	printk("ACTIVE MCAST GROUPS:\n");
+
+	for (i = 0; i < POPCORN_MAX_CPUS; i++) {
+		if (rkinfo->mcast_wininfo[i].mask) {
+			printk("group %d, mask 0x%lx, num_members %d\n", 
+			       i, rkinfo->mcast_wininfo[i].mask, 
+			       rkinfo->mcast_wininfo[i].num_members);
+		}
+	}
+	return;
+}
+
+/* Open a multicast group containing the CPUs specified in the mask. */
+int pcn_kmsg_mcast_open(pcn_kmsg_mcast_id *id, unsigned long mask)
+{
+	int rc, i, found_id = -1;
+	struct pcn_kmsg_mcast_message msg;
+	struct pcn_kmsg_mcast_wininfo *slot;
+	struct pcn_kmsg_mcast_window * new_win;
+
+	PCN_DEBUG("%s: Reached pcn_kmsg_mcast_open, mask 0x%lx\n", __func__, mask);
+
+	if (!(mask & (1 << my_cpu))) {
+		PCN_ERROR("%s: This CPU is not a member of the mcast group to be created, cpu %d, mask 0x%lx\n", __func__,
+		       my_cpu, mask);
+		return -1;
+	}
+
+	for (i = 0; i < POPCORN_MAX_MCAST_CHANNELS; i++) {
+		if (!rkinfo->mcast_wininfo[i].num_members) {
+			found_id = i;
+			break;
+		}
+	}
+
+	PCN_DEBUG("%s: Found channel ID %d\n", __func__, found_id);
+
+	if (found_id == -1) {
+		PCN_ERROR("%s: No free multicast channels!\n", __func__);
+		return -1;
+	}
+
+	/* TODO -- lock and check if channel is still unused; 
+	   otherwise, try again */
+
+	slot = &rkinfo->mcast_wininfo[found_id];
+
+	slot->mask = mask;
+	slot->num_members = count_members(mask);
+	slot->owner_cpu = my_cpu;
+
+	PCN_DEBUG("%s: Found %d members\n", __func__, slot->num_members);
+
+	new_win = kmalloc(sizeof(struct pcn_kmsg_mcast_window), GFP_ATOMIC);
+
+	if (!new_win) {
+		PCN_ERROR("%s: Failed to kmalloc mcast buffer!\n", __func__);
+		goto out;
+	}
+
+	MCASTWIN(found_id) = new_win;
+	slot->phys_addr = virt_to_phys(new_win);
+	PCN_DEBUG("%s: Malloced mcast receive window %d at phys addr 0x%lx\n", __func__,
+	       found_id, slot->phys_addr);
+
+	msg.hdr.type = PCN_KMSG_TYPE_MCAST;
+	msg.hdr.prio = PCN_KMSG_PRIO_HIGH;
+	msg.type = PCN_KMSG_MCAST_OPEN;
+	msg.id = found_id;
+	msg.mask = mask;
+	msg.num_members = slot->num_members;
+
+	/* send message to each member except self.  Can't use mcast yet because
+	   group is not yet established, so unicast to each CPU in mask. */
+	for (i = 0; i < POPCORN_MAX_CPUS; i++) {
+		if ((slot->mask & (1ULL << i)) && 
+		    (my_cpu != i)) {
+			PCN_DEBUG("%s: Sending message to CPU %d\n", __func__, i);
+
+			rc = pcn_kmsg_send(i, (struct pcn_kmsg_message *) &msg);
+
+			if (rc) {
+				PCN_ERROR("%s: Message send failed!\n", __func__);
+			}
+		}
+	}
+
+	*id = found_id;
+
+out:
+	/* TODO -- unlock */
+
+	return 0;
+}
+
+/* Add new members to a multicast group. */
+int pcn_kmsg_mcast_add_members(pcn_kmsg_mcast_id id, unsigned long mask)
+{
+	/* TODO -- lock! */
+
+	rkinfo->mcast_wininfo[id].mask |= mask; 
+
+	/* TODO -- unlock! */
+
+	return 0;
+}
+
+/* Remove existing members from a multicast group. */
+int pcn_kmsg_mcast_delete_members(pcn_kmsg_mcast_id id, unsigned long mask)
+{
+	/* TODO -- lock! */
+
+	rkinfo->mcast_wininfo[id].mask &= !mask;
+
+	/* TODO -- unlock! */
+
+
+	return 0;
+}
+
+inline int __pcn_kmsg_mcast_close(pcn_kmsg_mcast_id id)
+{
+	/* TODO -- lock! */
+
+	PCN_DEBUG("%s: Closing multicast channel %lu on CPU %d\n", __func__, id, my_cpu);
+
+	/* TODO --unlock! */
+
+	return 0;
+}
+
+/* Close a multicast group. */
+int pcn_kmsg_mcast_close(pcn_kmsg_mcast_id id)
+{
+	int rc;
+	struct pcn_kmsg_mcast_message msg;
+
+	/* broadcast message to close window globally */
+	msg.hdr.type = PCN_KMSG_TYPE_MCAST;
+	msg.hdr.prio = PCN_KMSG_PRIO_HIGH;
+	msg.type = PCN_KMSG_MCAST_CLOSE;
+	msg.id = id;
+
+	rc = pcn_kmsg_mcast_send(id, (struct pcn_kmsg_message *) &msg);
+	if (rc) {
+		PCN_ERROR("%s: POPCORN: failed to send mcast close message!\n", __func__);
+		return -1;
+	}
+
+	/* close window locally */
+	__pcn_kmsg_mcast_close(id);
+
+	rkinfo->mcast_wininfo[id].mask = 0;
+	rkinfo->mcast_wininfo[id].num_members = 0;
+
+	return 0;
+}
+
+/* Send a message to the specified multicast group. */
+int pcn_kmsg_mcast_send(pcn_kmsg_mcast_id id, struct pcn_kmsg_message *msg)
+{
+	int i, rc;
+
+	PCN_DEBUG("%s: Sending mcast message, id %lu\n", __func__, id);
+
+	/* quick hack for testing for now; 
+	   loop through mask and send individual messages */
+	for (i = 0; i < POPCORN_MAX_CPUS; i++) {
+		if (rkinfo->mcast_wininfo[id].mask & (0x1 << i)) {
+			rc = pcn_kmsg_send(i, msg);
+
+			if (rc) {
+				PCN_ERROR("%s: Batch send failed to CPU %d\n", __func__,  i);
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/* Send a message to the specified multicast group. */
+int pcn_kmsg_mcast_send_long(pcn_kmsg_mcast_id id, 
+			     struct pcn_kmsg_long_message *msg, 
+			     unsigned int payload_size)
+{
+	int i, rc;
+
+	PCN_DEBUG("%s: Sending long mcast message, id %lu, size %u\n", 
+	       __func__, id, payload_size);
+
+	/* quick hack for testing for now; 
+	   loop through mask and send individual messages */
+	for (i = 0; i < POPCORN_MAX_CPUS; i++) {
+		if (rkinfo->mcast_wininfo[id].mask & (0x1 << i)) {
+			rc = pcn_kmsg_send_long(i, msg, payload_size);
+
+			if (rc) {
+				PCN_ERROR("%s: Batch send failed to CPU %d\n", __func__, i);
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+static int pcn_kmsg_mcast_callback(struct pcn_kmsg_message *message) 
+{
+	int rc = 0;
+	struct pcn_kmsg_mcast_message *msg = 
+		(struct pcn_kmsg_mcast_message *) message;
+	pcn_kmsg_work_t *kmsg_work;
+
+	printk("Received mcast message, type %d\n", msg->type);
+
+	switch (msg->type) {
+		case PCN_KMSG_MCAST_OPEN:
+			PCN_DEBUG("%s: Processing mcast open message...\n", __func__);
+
+			/* Need to queue work to remap the window in a kernel
+			   thread; it can't happen here */
+			kmsg_work = kmalloc(sizeof(pcn_kmsg_work_t), GFP_ATOMIC);
+			if (kmsg_work) {
+				INIT_WORK((struct work_struct *) kmsg_work,
+					  process_kmsg_wq_item);
+				kmsg_work->op = PCN_KMSG_WQ_OP_MAP_MCAST_WIN;
+				kmsg_work->from_cpu = msg->hdr.from_cpu;
+				kmsg_work->id_to_join = msg->id;
+				queue_work(kmsg_wq, (struct work_struct *) kmsg_work);
+			} else {
+				PCN_ERROR("%s: Failed to kmalloc work structure; this is VERY BAD!\n", __func__);
+			}
+
+			break;
+
+		case PCN_KMSG_MCAST_ADD_MEMBERS:
+			PCN_DEBUG("%s: Processing mcast add members message...\n", __func__);
+			break;
+
+		case PCN_KMSG_MCAST_DEL_MEMBERS:
+			PCN_DEBUG("%s: Processing mcast del members message...\n", __func__);
+			break;
+
+		case PCN_KMSG_MCAST_CLOSE:
+			PCN_DEBUG("%s: Processing mcast close message...\n", __func__);
+			__pcn_kmsg_mcast_close(msg->id);
+			break;
+
+		default:
+			PCN_ERROR("%s: Invalid multicast message type %d\n", __func__,
+			       msg->type);
+			rc = -1;
+			goto out;
+	}
+
+	print_mcast_map();
+
+out:
+	kfree(message);
+	return rc;
+}
+
+
+
diff --git a/script64.gdb b/script64.gdb
new file mode 100644
index 0000000..2b3b217
--- /dev/null
+++ b/script64.gdb
@@ -0,0 +1,474 @@
+
+# scripts (tested on 64 bit machiens)
+# Antonio Barbalace 2012
+#
+
+define dump_page_flags_ext
+  set $_f=$arg0
+  	
+  if ($_f & 0x4000)
+    printf "head,"
+  end
+  if ($_f & 0x8000)
+    printf "tail,"
+  end
+  if ($_f & 0x010000)
+	printf "swapcache,"
+  end
+  if ($_f & 0x020000)
+	printf "mappedtodisk,"
+  end
+  if ($_f & 0x040000)
+    printf "reclaim,"
+  end
+  if ($_f & 0x080000)
+    printf "swapbacked,"
+  end
+  if ($_f & 0x100000)
+    printf "unevictable,"
+  end
+end
+
+define dump_page_flags_noext
+  set $_f=$arg0
+
+  if ($_f & 0x4000)
+    printf "compound,"
+  end
+  if ($_f & 0x8000)
+	printf "swapcache,"
+  end
+  if ($_f & 0x010000)
+	printf "mappedtodisk,"
+  end
+  if ($_f & 0x020000)
+    printf "reclaim,"
+  end
+  if ($_f & 0x040000)
+    printf "swapbacked,"
+  end
+  if ($_f & 0x080000)
+    printf "unevictable,"
+  end
+end
+
+define dump_page_flags
+  set $_e=(struct page *)$arg0
+  set $_f=$_e->flags
+  if ($_f & 0x01)
+    printf "locked,"
+  end
+  if ($_f & 0x02)
+    printf "error,"
+  end
+  if ($_f & 0x04)
+    printf "referenced,"
+  end
+  if ($_f & 0x08)
+    printf "uptodate,"
+  end
+  if ($_f & 0x10) 
+    print "dirty,"
+  end
+  if ($_f & 0x20)
+    printf "lru,"
+  end
+  if ($_f & 0x40)
+    printf "active,"
+  end
+  if ($_f & 0x80)
+    printf "slab,"
+  end
+  if ($_f & 0x0100)
+    printf "owner_priv_1,"
+  end
+  if ($_f & 0x0200)
+    printf "arch_1,"
+  end
+  if ($_f & 0x0400)
+    printf "reserved,"
+  end
+  if ($_f & 0x0800)
+    printf "private,"
+  end
+  if ($_f & 0x1000)
+    printf "private_2,"
+  end
+  if ($_f & 0x2000)
+    printf "writeback,"	
+  end
+  dump_page_flags_ext $_f
+  printf "\n"
+end
+
+define dump_page_mapping_print
+  set $_e=(struct page *)$arg0
+  set $_f=(unsigned long)$_e->mapping
+  if ($_f & 0x01)
+    printf "ANON,"
+    if ($_f & 0x02)
+      printf "KSM,"
+    end
+    printf "\n"
+    print *((struct anon_vma*)($_f & ~ 0x03))
+  else
+    printf "FILE,"
+    printf "\n"
+    print *((struct address_space*)($_f))
+  end
+end 
+
+define dump_page_mapping
+  set $_e=(struct page *)$arg0
+  set $_f=(unsigned long)$_e->mapping
+  if ($_f & 0x01)
+    printf "ANON,"
+    if ($_f & 0x02)
+      printf "KSM,"
+    end
+  else
+    printf "FILE,"
+  end
+  printf "\n"
+end 
+
+define walk_pages
+ set $_i=$arg0
+ set $_l=$arg1
+ set $_addr=(struct page *)$arg2 
+ printf "%d %d %p\n", $_i, $_l, $_addr
+ while ($_i < $_l)
+  if ( ((struct page *)$_addr)[$_i].mapping != 0 )
+   set $__arg= &((struct page *)$_addr)[$_i]
+ 
+   printf "****** id: %d (struct page*)%p\n", $_i, $__arg
+   printf "flags(%lx): ", ($__arg)->flags
+   dump_page_flags $__arg
+   printf "mapping(%p): ", (void *)(((long)($__arg)->mapping) & ~0x03)
+   dump_page_mapping $__arg
+  end
+  set $_i=$_i+1
+ end
+ echo "end"
+end
+
+define scan_first
+ set $_i=$arg0
+ set $_l=$arg1
+ set $_addr=(struct page *)$arg2 
+ printf "%d %d %p\n", $_i, $_l, $_addr
+ while ($_i < $_l)
+  if ( ((struct page *)$_addr)[$_i].mapping != 0 )
+   printf "***** %d *****\n", $_i 
+   print ((struct page *)$_addr)[$_i]
+  end
+  set $_i=$_i+1
+ end
+ echo "end"
+end
+
+#one struct anon_vma is mapped to one struct anon_vma_chain that is connected to oh
+define walk_same_vma
+
+define walk_same_anon_vma
+
+define dinitcall
+  # as ps first argument is relocation on 32bit
+  set $offset=$arg0
+  set $s=(char *)&__early_initcall_end
+  set $s=(initcall_t *)($s + $offset)
+  set $e=(char *)&__initcall_end
+  set $e=(initcall_t *)($e + $offset)
+  while $s!=$e
+    print *((initcall_t *)$s)
+	set $s=$s+1
+  end
+end
+
+define dearly
+  # as ps first argument is relocation on 32bit
+  set $offset=$arg0
+  set $s=(char *)&__initcall_start
+  set $s=(initcall_t *)($s + $offset)
+  set $e=(char *)&__early_initcall_end
+  set $e=(initcall_t *)($e + $offset)
+  while $s!=$e
+    print *((initcall_t *)$s)
+	set $s=$s+1
+  end
+end
+
+
+define task_struct_show
+   # task_struct addr and PID
+   set $st=(struct task_struct *)$arg0
+   #printf "0x%08X %5d ", $st, $st->pid
+   printf "%p %5d ", $st, $st->pid
+
+   # State
+   if ($st->state == 0)
+     printf "Running   "
+   else
+     if ($st->state == 1)
+       printf "Sleeping  "
+     else
+       if ($st->state == 2)
+         printf "Disksleep "
+       else
+         if ($st->state == 4)
+           printf "Zombie    "
+         else
+           if ($st->state == 8)
+             printf "sTopped   "
+           else
+             if ($st->state == 16)
+               printf "Wpaging   "
+             else
+               printf "%2d        ", $st->state
+             end
+           end
+         end
+       end
+     end
+   end
+
+   # User NIP
+   #printf "0x%08X ", $st->thread.ip #not working on 64bit
+   
+   # Display the kernel stack pointer
+   #printf "0x%08X ", $st->thread.sp
+   printf "%p ", $st->thread.sp
+   
+   # Display the processor id
+   printf "cpu %d ", ((struct thread_info *)($st)->stack)->cpu
+   #printf "on(cpu:%d,rq:%d) ", ($st)->on_cpu, ($st)->on_rq
+   #printf "prio:%d:%d:%d:%d ", $st->prio, $st->static_prio, $st->normal_prio, $st->rt_priority
+   
+   # Scheduling info
+ if ($st->sched_class == &stop_sched_class)
+   printf "STOP "
+ else 
+   if ($st->sched_class == &rt_sched_class)
+     printf "RT    %d ", $st->rt.rt_rq->rq->cpu
+   else
+     if ($st->sched_class == &fair_sched_class)
+       printf "FAIR %d ", $st->se.cfs_rq->rq->cpu
+     else
+       if ($st->sched_class == &idle_sched_class)
+         printf "IDLE "
+       else
+         printf "none "
+       end
+     end
+   end
+ end
+      
+   # comm
+   printf "%s\n", $st->comm
+end
+
+define find_next_task
+  # Given a task address, find the next task in the linked list
+  set $t = (struct task_struct *)$arg0
+  set $off=( (char *)&($t->tasks) - (char *)$t)
+  set $t=(struct task_struct *)( (char *)$t->tasks.next - $off)
+end
+
+define ps
+  # first argument handle eventual relocation on 32bit
+  set $offset=$arg0
+  set $t=(char *)&init_task
+  set $t=$t + $offset
+  print/x $t
+  task_struct_show $t
+  find_next_task $t
+  # Walk the list
+  while ((char *)&init_task +$offset)!=$t
+    # Display useful info about each task
+    task_struct_show $t
+    find_next_task $t
+  end
+end
+document ps
+this version works only in kernel space, if the actual kernel is in user space this dumper does not work
+we will solve this issue in a further version
+this version support kernel relocation the only argument is the kernel relocation offset 
+end
+
+#from Documentation/kdump/gdbmacro.txt
+define bttnobp
+  set $tasks_off=((size_t)&((struct task_struct *)0)->tasks)
+  set $pid_off=((size_t)&((struct task_struct *)0)->pids[1].node.next)
+  set $init_t=&init_task
+  set $next_t=(((char *)($init_t->tasks).next) - $tasks_off)
+  
+  while ($next_t != $init_t)
+    set $next_t=(struct task_struct *)$next_t
+    printf "\npid %d; comm %s:\n", $next_t.pid, $next_t.comm
+    printf "===================\n"
+    set var $stackp = $next_t.thread.sp
+    set var $stack_top = ($stackp & ~4095) + 4096
+
+    while ($stackp < $stack_top)
+      if (*($stackp) > _stext && *($stackp) < _sinittext)
+        #info line *($stackp)
+        info symbol *($stackp)
+      end
+      set $stackp += 8
+    end
+
+    set $next_t=(char *)($next_t->tasks.next) - $tasks_off
+  end
+end
+
+# The following code is not clear why it exists
+# it dumps all the stack changing pid?!?! walk per pid instead of task list
+    set $next_th=(((char *)$next_t->pids[1].node.next) - $pid_off)
+    while ($next_th != $next_t)
+      set $next_th=(struct task_struct *)$next_th
+      printf "\npid %d; comm %s:\n", $next_t.pid, $next_t.comm
+      printf "===================\n"
+      set var $stackp = $next_t.thread.sp
+      set var $stack_top = ($stackp & ~4095) + 4096
+
+      while ($stackp < $stack_top)
+        if (*($stackp) > _stext && *($stackp) < _sinittext)
+          info symbol *($stackp)
+        end
+        set $stackp += 8
+      end
+      set $next_th=(((char *)$next_th->pids[1].node.next) - $pid_off)
+    end
+    
+    
+
+define btt
+  set $tasks_off=((size_t)&((struct task_struct *)0)->tasks)
+  set $pid_off=((size_t)&((struct task_struct *)0)->pids[1].node.next)
+  set $init_t=&init_task
+  set $next_t=(((char *)($init_t->tasks).next) - $tasks_off)
+
+  while ($next_t != $init_t)
+    set $next_t=(struct task_struct *)$next_t
+    printf "\npid %d; comm %s:\n", $next_t.pid, $next_t.comm
+    printf "===================\n"
+    set var $stackp = $next_t.thread.sp
+    set var $stack_top = ($stackp & ~4095) + 4096
+    set var $stack_bot = ($stackp & ~4095)
+
+    set $stackp = *($stackp)
+    while (($stackp < $stack_top) && ($stackp > $stack_bot))
+      set var $addr = *($stackp + 8)
+      info symbol $addr
+      set $stackp = *($stackp)
+    end
+
+    set $next_th=(((char *)$next_t->pids[1].node.next) - $pid_off)
+    while ($next_th != $next_t)
+      set $next_th=(struct task_struct *)$next_th
+      printf "\npid %d; comm %s:\n", $next_t.pid, $next_t.comm
+      printf "===================\n"
+      set var $stackp = $next_t.thread.sp
+      set var $stack_top = ($stackp & ~4095) + 4096
+      set var $stack_bot = ($stackp & ~4095)
+
+      set $stackp = *($stackp)
+      while (($stackp < $stack_top) && ($stackp > $stack_bot))
+        set var $addr = *($stackp + 8)
+        info symbol $addr
+        set $stackp = *($stackp)
+      end
+      set $next_th=(((char *)$next_th->pids[1].node.next) - $pid_off)
+    end
+    set $next_t=(char *)($next_t->tasks.next) - $tasks_off
+  end
+end
+
+define btpid
+  set var $pid = $arg0
+  set $tasks_off=((size_t)&((struct task_struct *)0)->tasks)
+  set $pid_off=((size_t)&((struct task_struct *)0)->pids[1].node.next)
+  set $init_t=&init_task
+  set $next_t=(((char *)($init_t->tasks).next) - $tasks_off)
+  set var $pid_task = 0
+
+  while ($next_t != $init_t)
+    set $next_t=(struct task_struct *)$next_t
+
+    if ($next_t.pid == $pid)
+      set $pid_task = $next_t
+    end
+
+    set $next_t=(char *)($next_t->tasks.next) - $tasks_off
+  end
+
+  printf "\npid %d; comm %s; sp %p:\n", $pid_task.pid, $pid_task.comm, $pid_task.thread.sp
+  printf "===================\n"
+  set var $stackp = $pid_task.thread.sp
+  set var $stack_top = ($stackp & ~8181) + 8182
+  #set var $stack_bot = ($stackp & ~4095)
+
+  #set $stackp = *($stackp)
+  #while (($stackp < $stack_top) && ($stackp > $stack_bot))
+#    set var $addr = *($stackp + 8)
+#    info symbol $addr
+#    set $stackp = *($stackp)
+  #end
+  
+    while ($stackp < $stack_top)
+      if (*($stackp) > _stext && *($stackp) < _sinittext)
+        printf " %p - %p \n", *($stackp), $stackp
+        info symbol *($stackp)
+        info line *(*($stackp))  
+      end
+      set $stackp += 4
+    end
+  
+end
+
+define dmesg
+  set $__log_buf = (char*)$arg0
+  set $log_start = *(unsigned int*)$arg1
+  set $log_end = *(unsigned int*)$arg2
+  set $x = $log_start
+  printf "%p %d %d %d\n", $__log_buf, $log_start, $log_end, $x 
+  while ($x < $log_end)
+    set $c = (char)(($__log_buf)[$x++])
+    printf "%c" , $c
+  end
+  printf "\n"
+end
+document dmesg 
+dmesg __log_buf log_start log_end
+Print the content of the kernel message buffer
+from elinux.org
+end
+
+define trapinfo
+  set var $pid = $arg0
+  set $tasks_off=((size_t)&((struct task_struct *)0)->tasks)
+  set $init_t=&init_task
+  set $next_t=(((char *)($init_t->tasks).next) - $tasks_off)
+  set var $pid_task = 0
+
+  while ($next_t != $init_t)
+    set $next_t=(struct task_struct *)$next_t
+
+    if ($next_t.pid == $pid)
+      set $pid_task = $next_t
+    end
+
+    set $next_t=(char *)($next_t->tasks.next) - $tasks_off
+  end
+
+  printf "Trapno %ld, cr2 0x%lx, error_code %ld\n", $pid_task.thread.trap_no, \
+    $pid_task.thread.cr2, $pid_task.thread.error_code
+    
+end
+document trapinfo
+	Run info threads and lookup pid of thread #1
+	'trapinfo <pid>' will tell you by which trap & possibly
+	address the kernel panicked.
+end
+
+
